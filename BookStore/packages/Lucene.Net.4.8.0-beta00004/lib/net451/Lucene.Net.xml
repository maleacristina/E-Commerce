<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Lucene.Net</name>
    </assembly>
    <members>
        <member name="T:Lucene.Net.Analysis.Analyzer">
            <summary>
            An <see cref="T:Lucene.Net.Analysis.Analyzer"/> builds <see cref="T:Lucene.Net.Analysis.TokenStream"/>s, which analyze text.  It thus represents a
            policy for extracting index terms from text.
            <para/>
            In order to define what analysis is done, subclasses must define their
            <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> in <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>.
            The components are then reused in each call to <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            <para/>
            Simple example:
            <code>
            Analyzer analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
            {
                Tokenizer source = new FooTokenizer(reader);
                TokenStream filter = new FooFilter(source);
                filter = new BarFilter(filter);
                return new TokenStreamComponents(source, filter);
            });
            </code>
            For more examples, see the <see cref="N:Lucene.Net.Analysis"/> namespace documentation.
            <para/>
            For some concrete implementations bundled with Lucene, look in the analysis modules:
            <list type="bullet">
              <item>Common:
                  Analyzers for indexing content in different languages and domains.</item>
              <item>ICU:
                  Exposes functionality from ICU to Apache Lucene.</item>
              <item>Kuromoji:
                  Morphological analyzer for Japanese text.</item>
              <item>Morfologik:
                  Dictionary-driven lemmatization for the Polish language.</item>
              <item>Phonetic:
                  Analysis for indexing phonetic signatures (for sounds-alike search).</item>
              <item>Smart Chinese:
                  Analyzer for Simplified Chinese, which indexes words.</item>
              <item>Stempel:
                  Algorithmic Stemmer for the Polish Language.</item>
              <item>UIMA:
                  Analysis integration with Apache UIMA.</item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.#ctor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Analysis.Analyzer"/>, reusing the same set of components per-thread
            across calls to <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.#ctor(Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Expert: create a new Analyzer with a custom <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            <para/>
            NOTE: if you just want to reuse on a per-field basis, its easier to
            use a subclass of <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/> such as
            <c>Lucene.Net.Analysis.Common.Miscellaneous.PerFieldAnalyzerWrapper</c>
            instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            An delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents},Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter and allows the use of a <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                }, reuseStrategy);
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            An delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <param name="reuseStrategy">A custom <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> instance.</param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents},System.Func{System.String,System.IO.TextReader,System.IO.TextReader})">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter, the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method through the <paramref name="initReader"/> parameter.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                }, initReader: (fieldName, reader) => 
                {
                    return new HTMLStripCharFilter(reader);
                });
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <param name="initReader">A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:System.IO.TextReader"/> that can be modified or wrapped by the <paramref name="initReader"/> method.</param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents},System.Func{System.String,System.IO.TextReader,System.IO.TextReader},Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Creates a new instance with the ability to specify the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/>
            method through the <paramref name="createComponents"/> parameter, the body of the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method through the <paramref name="initReader"/> parameter, and allows the use of a <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            Simple example: 
            <code>
                var analyzer = Analyzer.NewAnonymous(createComponents: (fieldName, reader) => 
                {
                    Tokenizer source = new FooTokenizer(reader);
                    TokenStream filter = new FooFilter(source);
                    filter = new BarFilter(filter);
                    return new TokenStreamComponents(source, filter);
                }, initReader: (fieldName, reader) => 
                {
                    return new HTMLStripCharFilter(reader);
                }, reuseStrategy);
            </code>
            <para/>
            LUCENENET specific
            </summary>
            <param name="createComponents">
            A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> 
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer.
            </param>
            <param name="initReader">A delegate method that represents (is called by) the <see cref="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)"/>
            method. It accepts a <see cref="T:System.String"/> fieldName and a <see cref="T:System.IO.TextReader"/> reader and 
            returns the <see cref="T:System.IO.TextReader"/> that can be modified or wrapped by the <paramref name="initReader"/> method.</param>
            <param name="reuseStrategy">A custom <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> instance.</param>
            <returns> A new <see cref="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> instance for this analyzer.
            </summary>
            <param name="fieldName">
                     the name of the fields content passed to the
                     <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> sink as a reader </param>
            <param name="reader">
                     the reader passed to the <see cref="T:Lucene.Net.Analysis.Tokenizer"/> constructor </param>
            <returns> the <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for this analyzer. </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Analysis.TokenStream"/> suitable for <paramref name="fieldName"/>, tokenizing
            the contents of <c>text</c>.
            <para/>
            This method uses <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> to obtain an
            instance of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>. It returns the sink of the
            components and stores the components internally. Subsequent calls to this
            method will reuse the previously stored components after resetting them
            through <see cref="M:Lucene.Net.Analysis.TokenStreamComponents.SetReader(System.IO.TextReader)"/>.
            <para/>
            <b>NOTE:</b> After calling this method, the consumer must follow the
            workflow described in <see cref="T:Lucene.Net.Analysis.TokenStream"/> to properly consume its contents.
            See the <see cref="N:Lucene.Net.Analysis"/> namespace documentation for
            some examples demonstrating this.
            </summary>
            <param name="fieldName"> the name of the field the created <see cref="T:Lucene.Net.Analysis.TokenStream"/> is used for </param>
            <param name="reader"> the reader the streams source reads from </param>
            <returns> <see cref="T:Lucene.Net.Analysis.TokenStream"/> for iterating the analyzed content of <see cref="T:System.IO.TextReader"/> </returns>
            <exception cref="T:System.ObjectDisposedException"> if the Analyzer is disposed. </exception>
            <exception cref="T:System.IO.IOException"> if an i/o error occurs (may rarely happen for strings). </exception>
            <seealso cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Analysis.TokenStream"/> suitable for <paramref name="fieldName"/>, tokenizing
            the contents of <paramref name="text"/>.
            <para/>
            This method uses <see cref="M:Lucene.Net.Analysis.Analyzer.CreateComponents(System.String,System.IO.TextReader)"/> to obtain an
            instance of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>. It returns the sink of the
            components and stores the components internally. Subsequent calls to this
            method will reuse the previously stored components after resetting them
            through <see cref="M:Lucene.Net.Analysis.TokenStreamComponents.SetReader(System.IO.TextReader)"/>.
            <para/>
            <b>NOTE:</b> After calling this method, the consumer must follow the 
            workflow described in <see cref="T:Lucene.Net.Analysis.TokenStream"/> to properly consume its contents.
            See the <see cref="N:Lucene.Net.Analysis"/> namespace documentation for
            some examples demonstrating this.
            </summary>
            <param name="fieldName">the name of the field the created <see cref="T:Lucene.Net.Analysis.TokenStream"/> is used for</param>
            <param name="text">the <see cref="T:System.String"/> the streams source reads from </param>
            <returns><see cref="T:Lucene.Net.Analysis.TokenStream"/> for iterating the analyzed content of <paramref name="reader"/></returns>
            <exception cref="T:System.ObjectDisposedException"> if the Analyzer is disposed. </exception>
            <exception cref="T:System.IO.IOException"> if an i/o error occurs (may rarely happen for strings). </exception>
            <seealso cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.InitReader(System.String,System.IO.TextReader)">
            <summary>
            Override this if you want to add a <see cref="T:Lucene.Net.Analysis.CharFilter"/> chain.
            <para/>
            The default implementation returns <paramref name="reader"/>
            unchanged.
            </summary>
            <param name="fieldName"> <see cref="T:Lucene.Net.Index.IIndexableField"/> name being indexed </param>
            <param name="reader"> original <see cref="T:System.IO.TextReader"/> </param>
            <returns> reader, optionally decorated with <see cref="T:Lucene.Net.Analysis.CharFilter"/>(s) </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetPositionIncrementGap(System.String)">
            <summary>
            Invoked before indexing a <see cref="T:Lucene.Net.Index.IIndexableField"/> instance if
            terms have already been added to that field.  This allows custom
            analyzers to place an automatic position increment gap between
            <see cref="T:Lucene.Net.Index.IIndexableField"/> instances using the same field name.  The default value
            position increment gap is 0.  With a 0 position increment gap and
            the typical default token position increment of 1, all terms in a field,
            including across <see cref="T:Lucene.Net.Index.IIndexableField"/> instances, are in successive positions, allowing
            exact <see cref="T:Lucene.Net.Search.PhraseQuery"/> matches, for instance, across <see cref="T:Lucene.Net.Index.IIndexableField"/> instance boundaries.
            </summary>
            <param name="fieldName"> <see cref="T:Lucene.Net.Index.IIndexableField"/> name being indexed. </param>
            <returns> position increment gap, added to the next token emitted from <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
                    this value must be <c>&gt;= 0</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GetOffsetGap(System.String)">
            <summary>
            Just like <see cref="M:Lucene.Net.Analysis.Analyzer.GetPositionIncrementGap(System.String)"/>, except for
            <see cref="T:Lucene.Net.Analysis.Token"/> offsets instead.  By default this returns 1.
            this method is only called if the field
            produced at least one token for indexing.
            </summary>
            <param name="fieldName"> the field just indexed </param>
            <returns> offset gap, added to the next token emitted from <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
                    this value must be <c>&gt;= 0</c>. </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.Analyzer.Strategy">
            <summary>
            Returns the used <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.Dispose">
            <summary>
            Frees persistent resources used by this <see cref="T:Lucene.Net.Analysis.Analyzer"/> </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.GLOBAL_REUSE_STRATEGY">
            <summary>
            A predefined <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/>  that reuses the same components for
            every field.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.GlobalReuseStrategy">
            <summary>
            Implementation of <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> that reuses the same components for
            every field. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Analyzer.GlobalReuseStrategy.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass constructors, typically implicit.) </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY">
            <summary>
            A predefined <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> that reuses components per-field by
            maintaining a Map of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> per field name.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.PerFieldReuseStrategy">
            <summary>
            Implementation of <see cref="T:Lucene.Net.Analysis.ReuseStrategy"/> that reuses components per-field by
            maintaining a Map of <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> per field name.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Analyzer.AnonymousAnalyzer">
            <summary>
            LUCENENET specific helper class to mimick Java's ability to create anonymous classes.
            Clearly, the design of <see cref="T:Lucene.Net.Analysis.Analyzer"/> took this feature of Java into consideration.
            Since it doesn't exist in .NET, we can use a delegate method to call the constructor of
            this concrete instance to fake it (by calling <see cref="M:Lucene.Net.Analysis.Analyzer.NewAnonymous(System.Func{System.String,System.IO.TextReader,Lucene.Net.Analysis.TokenStreamComponents})"/>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenStreamComponents">
            <summary>
            This class encapsulates the outer components of a token stream. It provides
            access to the source (<see cref="T:Lucene.Net.Analysis.Tokenizer"/>) and the outer end (sink), an
            instance of <see cref="T:Lucene.Net.Analysis.TokenFilter"/> which also serves as the
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> returned by
            <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamComponents.m_source">
            <summary>
            Original source of the tokens.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamComponents.m_sink">
            <summary>
            Sink tokenstream, such as the outer tokenfilter decorating
            the chain. This can be the source if there are no filters.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamComponents.reusableStringReader">
            <summary>
            Internal cache only used by <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamComponents.#ctor(Lucene.Net.Analysis.Tokenizer,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> instance.
            </summary>
            <param name="source">
                     the analyzer's tokenizer </param>
            <param name="result">
                     the analyzer's resulting token stream </param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamComponents.#ctor(Lucene.Net.Analysis.Tokenizer)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> instance.
            </summary>
            <param name="source">
                     the analyzer's tokenizer </param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamComponents.SetReader(System.IO.TextReader)">
            <summary>
            Resets the encapsulated components with the given reader. If the components
            cannot be reset, an Exception should be thrown.
            </summary>
            <param name="reader">
                     a reader to reset the source component </param>
            <exception cref="T:System.IO.IOException">
                      if the component's reset method throws an <seealso cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamComponents.TokenStream">
            <summary>
            Returns the sink <see cref="T:Lucene.Net.Analysis.TokenStream"/>
            </summary>
            <returns> the sink <see cref="T:Lucene.Net.Analysis.TokenStream"/> </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamComponents.Tokenizer">
            <summary>
            Returns the component's <see cref="T:Lucene.Net.Analysis.Tokenizer"/>
            </summary>
            <returns> Component's <see cref="T:Lucene.Net.Analysis.Tokenizer"/> </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.ReuseStrategy">
            <summary>
            Strategy defining how <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> are reused per call to
            <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.IO.TextReader)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.GetReusableComponents(Lucene.Net.Analysis.Analyzer,System.String)">
            <summary>
            Gets the reusable <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for the field with the given name.
            </summary>
            <param name="analyzer"> <see cref="T:Lucene.Net.Analysis.Analyzer"/> from which to get the reused components. Use
                   <see cref="M:Lucene.Net.Analysis.ReuseStrategy.GetStoredValue(Lucene.Net.Analysis.Analyzer)"/> and <see cref="M:Lucene.Net.Analysis.ReuseStrategy.SetStoredValue(Lucene.Net.Analysis.Analyzer,System.Object)"/>
                   to access the data on the <see cref="T:Lucene.Net.Analysis.Analyzer"/>. </param>
            <param name="fieldName"> Name of the field whose reusable <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/>
                   are to be retrieved </param>
            <returns> Reusable <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> for the field, or <c>null</c>
                    if there was no previous components for the field </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.SetReusableComponents(Lucene.Net.Analysis.Analyzer,System.String,Lucene.Net.Analysis.TokenStreamComponents)">
            <summary>
            Stores the given <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> as the reusable components for the
            field with the give name.
            </summary>
            <param name="fieldName"> Name of the field whose <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> are being set </param>
            <param name="components"> <see cref="T:Lucene.Net.Analysis.TokenStreamComponents"/> which are to be reused for the field </param>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.GetStoredValue(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Returns the currently stored value.
            </summary>
            <returns> Currently stored value or <c>null</c> if no value is stored </returns>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Analysis.Analyzer"/> is closed. </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.ReuseStrategy.SetStoredValue(Lucene.Net.Analysis.Analyzer,System.Object)">
            <summary>
            Sets the stored value.
            </summary>
            <param name="storedValue"> Value to store </param>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Analysis.Analyzer"/> is closed. </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.AnalyzerWrapper">
            <summary>
            Extension to <see cref="T:Lucene.Net.Analysis.Analyzer"/> suitable for <see cref="T:Lucene.Net.Analysis.Analyzer"/>s which wrap
            other <see cref="T:Lucene.Net.Analysis.Analyzer"/>s.
            <para/>
            <see cref="M:Lucene.Net.Analysis.AnalyzerWrapper.GetWrappedAnalyzer(System.String)"/> allows the <see cref="T:Lucene.Net.Analysis.Analyzer"/>
            to wrap multiple <see cref="T:Lucene.Net.Analysis.Analyzer"/>s which are selected on a per field basis.
            <para/>
            <see cref="!:WrapComponents(string, Analyzer.TokenStreamComponents)"/> allows the
            <see cref="!:Analyzer.TokenStreamComponents"/> of the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/> to then be wrapped
            (such as adding a new <see cref="T:Lucene.Net.Analysis.TokenFilter"/> to form new <see cref="!:Analyzer.TokenStreamComponents"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/>.  Since the <see cref="!:Analyzer.ReuseStrategy"/> of
            the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/>s are unknown, <see cref="F:Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY"/> is assumed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.#ctor(Lucene.Net.Analysis.ReuseStrategy)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/> with the given reuse strategy.
            <para/>If you want to wrap a single delegate <see cref="T:Lucene.Net.Analysis.Analyzer"/> you can probably
            reuse its strategy when instantiating this subclass:
            <c>base(innerAnalyzer.Strategy)</c>.
            <para/>If you choose different analyzers per field, use
            <see cref="F:Lucene.Net.Analysis.Analyzer.PER_FIELD_REUSE_STRATEGY"/>.
            </summary>
            <seealso cref="P:Lucene.Net.Analysis.Analyzer.Strategy"/>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.GetWrappedAnalyzer(System.String)">
            <summary>
            Retrieves the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/> appropriate for analyzing the field with
            the given name
            </summary>
            <param name="fieldName"> Name of the field which is to be analyzed </param>
            <returns> <see cref="T:Lucene.Net.Analysis.Analyzer"/> for the field with the given name.  Assumed to be non-null </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.WrapComponents(System.String,Lucene.Net.Analysis.TokenStreamComponents)">
            <summary>
            Wraps / alters the given <see cref="!:Analyzer.TokenStreamComponents"/>, taken from the wrapped
            <see cref="T:Lucene.Net.Analysis.Analyzer"/>, to form new components. It is through this method that new
            <see cref="T:Lucene.Net.Analysis.TokenFilter"/>s can be added by <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/>s. By default, the given
            components are returned.
            </summary>
            <param name="fieldName">
                     Name of the field which is to be analyzed </param>
            <param name="components">
                     <see cref="!:Analyzer.TokenStreamComponents"/> taken from the wrapped <see cref="T:Lucene.Net.Analysis.Analyzer"/> </param>
            <returns> Wrapped / altered <see cref="!:Analyzer.TokenStreamComponents"/>. </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.AnalyzerWrapper.WrapReader(System.String,System.IO.TextReader)">
            <summary>
            Wraps / alters the given <see cref="T:System.IO.TextReader"/>. Through this method <see cref="T:Lucene.Net.Analysis.AnalyzerWrapper"/>s can
            implement <see cref="M:Lucene.Net.Analysis.AnalyzerWrapper.InitReader(System.String,System.IO.TextReader)"/>. By default, the given reader
            is returned.
            </summary>
            <param name="fieldName">
                     name of the field which is to be analyzed </param>
            <param name="reader">
                     the reader to wrap </param>
            <returns> the wrapped reader </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.CachingTokenFilter">
             <summary>
             This class can be used if the token attributes of a <see cref="T:Lucene.Net.Analysis.TokenStream"/>
             are intended to be consumed more than once. It caches
             all token attribute states locally in a List.
            
             <para/><see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> implements the optional method
             <see cref="M:Lucene.Net.Analysis.TokenStream.Reset"/>, which repositions the
             stream to the first <see cref="T:Lucene.Net.Analysis.Token"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CachingTokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/> around <paramref name="input"/>,
            caching its token attributes, which can be replayed again
            after a call to <see cref="M:Lucene.Net.Analysis.CachingTokenFilter.Reset"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CachingTokenFilter.Reset">
            <summary>
            Rewinds the iterator to the beginning of the cached list.
            <para/>
            Note that this does not call <see cref="M:Lucene.Net.Analysis.CachingTokenFilter.Reset"/> on the wrapped tokenstream ever, even
            the first time. You should <see cref="M:Lucene.Net.Analysis.CachingTokenFilter.Reset"/> the inner tokenstream before wrapping
            it with <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.CharFilter">
            <summary>
            Subclasses of <see cref="T:Lucene.Net.Analysis.CharFilter"/> can be chained to filter a <see cref="T:System.IO.TextReader"/>
            They can be used as <see cref="T:System.IO.TextReader"/> with additional offset
            correction. <see cref="T:Lucene.Net.Analysis.Tokenizer"/>s will automatically use <see cref="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)"/>
            if a <see cref="T:Lucene.Net.Analysis.CharFilter"/> subclass is used.
            <para/>
            This class is abstract: at a minimum you must implement <see cref="M:System.IO.TextReader.Read(System.Char[],System.Int32,System.Int32)"/>,
            transforming the input in some way from <see cref="F:Lucene.Net.Analysis.CharFilter.m_input"/>, and <seealso cref="M:Lucene.Net.Analysis.CharFilter.Correct(System.Int32)"/>
            to adjust the offsets to match the originals.
            <para/>
            You can optionally provide more efficient implementations of additional methods
            like <see cref="M:System.IO.TextReader.Read"/>, but this is not required.
            <para/>
            For examples and integration with <see cref="T:Lucene.Net.Analysis.Analyzer"/>, see the
            <see cref="N:Lucene.Net.Analysis"/> namespace documentation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.CharFilter.m_input">
            <summary>
            The underlying character-input stream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.#ctor(System.IO.TextReader)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Analysis.CharFilter"/> wrapping the provided reader. </summary>
            <param name="input"> a <see cref="T:System.IO.TextReader"/>, can also be a <see cref="T:Lucene.Net.Analysis.CharFilter"/> for chaining. </param>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Dispose(System.Boolean)">
            <summary>
            Closes the underlying input stream.
            <para/>
            <b>NOTE:</b>
            The default implementation closes the input <see cref="T:System.IO.TextReader"/>, so
            be sure to call <c>base.Dispose(disposing)</c> when overriding this method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Correct(System.Int32)">
            <summary>
            Subclasses override to correct the current offset.
            </summary>
            <param name="currentOff"> current offset </param>
            <returns> corrected offset </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)">
            <summary>
            Chains the corrected offset through the input
            <see cref="T:Lucene.Net.Analysis.CharFilter"/>(s).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Skip(System.Int32)">
            <summary>
            Skips characters. This method will block until some characters are available, an I/O error occurs, or the end of the stream is reached.
            
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <param name="n">The number of characters to skip</param>
            <returns>The number of characters actually skipped</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Reset">
            <summary>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Lucene.Net.Analysis.CharFilter.IsReady">
            <summary>
            Tells whether this stream is ready to be read.
            <para/>
            True if the next <see cref="M:System.IO.TextReader.Read"/> is guaranteed not to block for input, false otherwise. Note 
            that returning false does not guarantee that the next read will block.
            <para/>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.CharFilter.IsMarkSupported">
            <summary>
            Tells whether this stream supports the <see cref="M:Lucene.Net.Analysis.CharFilter.Mark(System.Int32)"/> operation. The default implementation always 
            returns false. Subclasses should override this method.
            <para/>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <returns>true if and only if this stream supports the mark operation.</returns>
        </member>
        <member name="M:Lucene.Net.Analysis.CharFilter.Mark(System.Int32)">
            <summary>
            Marks the present position in the stream. Subsequent calls to <see cref="M:Lucene.Net.Analysis.CharFilter.Reset"/> will attempt to 
            reposition the stream to this point. Not all character-input streams support the <see cref="M:Lucene.Net.Analysis.CharFilter.Mark(System.Int32)"/> operation.
            <para/>
            LUCENENET specific. Moved here from the Reader class (in Java) so it can be overridden to provide reader buffering.
            </summary>
            <param name="readAheadLimit">Limit on the number of characters that may be read while still preserving the mark. After 
            reading this many characters, attempting to reset the stream may fail.</param>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream">
             <summary>
             <b>Expert:</b> this class provides a <see cref="T:Lucene.Net.Analysis.TokenStream"/>
             for indexing numeric values that can be used by <see cref="T:Lucene.Net.Search.NumericRangeQuery"/>
             or <see cref="T:Lucene.Net.Search.NumericRangeFilter"/>.
            
             <para/>Note that for simple usage, <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/>, 
             <see cref="T:Lucene.Net.Documents.SingleField"/> or <see cref="T:Lucene.Net.Documents.DoubleField"/> is
             recommended.  These fields disable norms and
             term freqs, as they are not usually needed during
             searching.  If you need to change these settings, you
             should use this class.
            
             <para/>Here's an example usage, for an <see cref="T:System.Int32"/> field:
            
             <code>
                 FieldType fieldType = new FieldType(TextField.TYPE_NOT_STORED)
                 {
                     OmitNorms = true,
                     IndexOptions = IndexOptions.DOCS_ONLY
                 };
                 Field field = new Field(name, new NumericTokenStream(precisionStep).SetInt32Value(value), fieldType);
                 document.Add(field);
             </code>
            
             <para/>For optimal performance, re-use the <see cref="T:Lucene.Net.Analysis.TokenStream"/> and <see cref="T:Lucene.Net.Documents.Field"/> instance
             for more than one document:
            
             <code>
                 NumericTokenStream stream = new NumericTokenStream(precisionStep);
                 FieldType fieldType = new FieldType(TextField.TYPE_NOT_STORED)
                 {
                     OmitNorms = true,
                     IndexOptions = IndexOptions.DOCS_ONLY
                 };
                 Field field = new Field(name, stream, fieldType);
                 Document document = new Document();
                 document.Add(field);
            
                 for(all documents) 
                 {
                     stream.SetInt32Value(value)
                     writer.AddDocument(document);
                 }
             </code>
            
             <para>this stream is not intended to be used in analyzers;
             it's more for iterating the different precisions during
             indexing a specific numeric value.</para>
            
             <para><b>NOTE</b>: as token streams are only consumed once
             the document is added to the index, if you index more
             than one numeric field, use a separate <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>
             instance for each.</para>
            
             <para>See <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> for more details on the
             <c>precisionStep</c> parameter as well as how numeric fields work under the hood.
             </para>
            
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.NumericTokenStream.TOKEN_TYPE_FULL_PREC">
            <summary>
            The full precision token gets this token type assigned. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.NumericTokenStream.TOKEN_TYPE_LOWER_PREC">
            <summary>
            The lower precision tokens gets this token type assigned. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute">
            <summary>
            <b>Expert:</b> Use this attribute to get the details of the currently generated token.
            @lucene.experimental
            @since 4.0
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Shift">
            <summary>
            Returns current shift value, undefined before first token </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.RawValue">
            <summary>
            Returns current token's raw value as <see cref="T:System.Int64"/> with all <see cref="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Shift"/> applied, undefined before first token </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.ValueSize">
            <summary>
            Returns value size in bits (32 for <see cref="T:System.Single"/>, <see cref="T:System.Int32"/>; 64 for <see cref="T:System.Double"/>, <see cref="T:System.Int64"/>) </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.Init(System.Int64,System.Int32,System.Int32,System.Int32)">
            <summary>
            <em>Don't call this method!</em>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute.IncShift">
            <summary>
            <em>Don't call this method!</em>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute">
            <summary>
            Implementation of <see cref="T:Lucene.Net.Analysis.NumericTokenStream.INumericTermAttribute"/>.
            @lucene.internal
            @since 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute.#ctor">
            <summary>
            Creates, but does not yet initialize this attribute instance
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.NumericTokenStream.NumericTermAttribute.Init(System.Int64,System.Int32,System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor">
            <summary>
            Creates a token stream for numeric values using the default <seealso cref="F:Lucene.Net.Analysis.NumericTokenStream.precisionStep"/>
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). The stream is not yet initialized,
            before using set a value using the various Set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor(System.Int32)">
            <summary>
            Creates a token stream for numeric values with the specified
            <paramref name="precisionStep"/>. The stream is not yet initialized,
            before using set a value using the various Set<em>???</em>Value() methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory,System.Int32)">
            <summary>
            Expert: Creates a token stream for numeric values with the specified
            <paramref name="precisionStep"/> using the given
            <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            The stream is not yet initialized,
            before using set a value using the various Set<em>???</em>Value() methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.NumericTokenStream.SetInt64Value(System.Int64)" -->
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetInt32Value(System.Int32)">
            <summary>
            Initializes the token stream with the supplied <see cref="T:System.Int32"/> value.
            <para/>
            NOTE: This was setIntValue() in Lucene
            </summary>
            <param name="value"> the value, for which this <see cref="T:Lucene.Net.Analysis.TokenStream"/> should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).SetInt32Value(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetDoubleValue(System.Double)">
            <summary>
            Initializes the token stream with the supplied <see cref="T:System.Double"/> value. </summary>
            <param name="value"> the value, for which this <see cref="T:Lucene.Net.Analysis.TokenStream"/> should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).SetDoubleValue(value))</code> </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.NumericTokenStream.SetSingleValue(System.Single)">
            <summary>
            Initializes the token stream with the supplied <see cref="T:System.Single"/> value. 
            <para/>
            NOTE: This was setFloatValue() in Lucene
            </summary>
            <param name="value"> the value, for which this <see cref="T:Lucene.Net.Analysis.TokenStream"/> should enumerate tokens. </param>
            <returns> this instance, because of this you can use it the following way:
            <code>new Field(name, new NumericTokenStream(precisionStep).SetSingleValue(value))</code> </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.NumericTokenStream.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.ReusableStringReader">
            <summary>
            Internal class to enable reuse of the string reader by <see cref="M:Lucene.Net.Analysis.Analyzer.GetTokenStream(System.String,System.String)"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Token">
             <summary>
             A <see cref="T:Lucene.Net.Analysis.Token"/> is an occurrence of a term from the text of a field.  It consists of
             a term's text, the start and end offset of the term in the text of the field,
             and a type string.
             <para/>
             The start and end offsets permit applications to re-associate a token with
             its source text, e.g., to display highlighted query terms in a document
             browser, or to show matching text fragments in a KWIC (KeyWord In Context)
             display, etc.
             <para/>
             The type is a string, assigned by a lexical analyzer
             (a.k.a. tokenizer), naming the lexical or syntactic class that the token
             belongs to.  For example an end of sentence marker token might be implemented
             with type "eos".  The default token type is "word".
             <para/>
             A Token can optionally have metadata (a.k.a. payload) in the form of a variable
             length byte array. Use <see cref="M:Lucene.Net.Index.DocsAndPositionsEnum.GetPayload"/> to retrieve the
             payloads from the index.
            
             <para/><para/>
            
             <para/><b>NOTE:</b> As of 2.9, Token implements all <see cref="T:Lucene.Net.Util.IAttribute"/> interfaces
             that are part of core Lucene and can be found in the <see cref="N:Lucene.Net.Analysis.TokenAttributes"/> namespace.
             Even though it is not necessary to use <see cref="T:Lucene.Net.Analysis.Token"/> anymore, with the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API it can
             be used as convenience class that implements all <see cref="T:Lucene.Net.Util.IAttribute"/>s, which is especially useful
             to easily switch from the old to the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API.
            
             <para/><para/>
            
             <para><see cref="T:Lucene.Net.Analysis.Tokenizer"/>s and <see cref="T:Lucene.Net.Analysis.TokenFilter"/>s should try to re-use a <see cref="T:Lucene.Net.Analysis.Token"/>
             instance when possible for best performance, by
             implementing the <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> API.
             Failing that, to create a new <see cref="T:Lucene.Net.Analysis.Token"/> you should first use
             one of the constructors that starts with null text.  To load
             the token from a char[] use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/>.
             To load from a <see cref="T:System.String"/> use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetEmpty"/> followed by 
             <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String)"/> or <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String,System.Int32,System.Int32)"/>.
             Alternatively you can get the <see cref="T:Lucene.Net.Analysis.Token"/>'s termBuffer by calling either <see cref="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Buffer"/>,
             if you know that your text is shorter than the capacity of the termBuffer
             or <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)"/>, if there is any possibility
             that you may need to grow the buffer. Fill in the characters of your term into this
             buffer, with <see cref="M:System.String.ToCharArray(System.Int32,System.Int32)"/> if loading from a string,
             or with <see cref="M:System.Array.Copy(System.Array,System.Int32,System.Array,System.Int32,System.Int32)"/>, 
             and finally call <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)"/> to
             set the length of the term text.  See <a target="_top"
             href="https://issues.apache.org/jira/browse/LUCENE-969">LUCENE-969</a>
             for details.</para>
             <para>Typical Token reuse patterns:
             <list type="bullet">
                 <item> Copying text from a string (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(string, startOffset, endOffset[, type]);
                 </code>
                 </item>
                 <item> Copying some text from a string (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(string, 0, string.Length, startOffset, endOffset[, type]);
                 </code>
                 </item>
                 <item> Copying text from char[] buffer (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(buffer, 0, buffer.Length, startOffset, endOffset[, type]);
                 </code>
                 </item>
                 <item> Copying some text from a char[] buffer (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(buffer, start, end - start, startOffset, endOffset[, type]);
                 </code>
                 </item>
                 <item> Copying from one one <see cref="T:Lucene.Net.Analysis.Token"/> to another (type is reset to <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> if not specified):
                 <code>
                     return reusableToken.Reinit(source.Buffer, 0, source.Length, source.StartOffset, source.EndOffset[, source.Type]);
                 </code>
                 </item>
             </list>
             A few things to note:
             <list type="bullet">
                 <item><see cref="M:Lucene.Net.Analysis.Token.Clear"/> initializes all of the fields to default values. this was changed in contrast to Lucene 2.4, but should affect no one.</item>
                 <item>Because <see cref="T:Lucene.Net.Analysis.TokenStream"/>s can be chained, one cannot assume that the <see cref="T:Lucene.Net.Analysis.Token"/>'s current type is correct.</item>
                 <item>The startOffset and endOffset represent the start and offset in the source text, so be careful in adjusting them.</item>
                 <item>When caching a reusable token, clone it. When injecting a cached token into a stream that can be reset, clone it again.</item>
             </list>
             </para>
             <para>
             <b>Please note:</b> With Lucene 3.1, the <see cref="M:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.ToString"/> method had to be changed to match the
             <see cref="T:Lucene.Net.Support.ICharSequence"/> interface introduced by the interface <see cref="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute"/>.
             this method now only prints the term text, no additional information anymore.
             </para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> will null text. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with null text and start &amp; end
            offsets. </summary>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text  </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with null text and start &amp; end
            offsets plus the <see cref="T:Lucene.Net.Analysis.Token"/> type. </summary>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="typ"> the lexical type of this <see cref="T:Lucene.Net.Analysis.Token"/>  </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with null text and start &amp; end
            offsets plus flags. NOTE: flags is EXPERIMENTAL. </summary>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="flags"> The bits to set for this token </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given term text, and start
            &amp; end offsets.  The type defaults to "word."
            <b>NOTE:</b> for better indexing speed you should
            instead use the char[] termBuffer methods to set the
            term text. </summary>
            <param name="text"> term text </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given text, start and end
            offsets, &amp; type.  <b>NOTE:</b> for better indexing
            speed you should instead use the char[] termBuffer
            methods to set the term text. </summary>
            <param name="text"> term text </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="typ"> token type </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given text, start and end
            offsets, &amp; type.  <b>NOTE:</b> for better indexing
            speed you should instead use the char[] termBuffer
            methods to set the term text. </summary>
            <param name="text"> term text </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
            <param name="flags"> token type bits </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.#ctor(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Analysis.Token"/> with the given term buffer (offset
            &amp; length), start and end offsets
            </summary>
            <param name="startTermBuffer"> buffer containing term text </param>
            <param name="termBufferOffset"> the index in the buffer of the first character </param>
            <param name="termBufferLength"> number of valid characters in the buffer </param>
            <param name="start"> start offset in the source text </param>
            <param name="end"> end offset in the source text </param>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.PositionIncrement">
            <summary>
            Gets or Sets the position increment (the distance from the prior term). The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value is set to a negative value. </exception>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.PositionLength">
            <summary>
            Gets or Sets the position length of this <see cref="T:Lucene.Net.Analysis.Token"/> (how many positions this token
            spans).
            <para/>
            The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value
                    is set to zero or negative. </exception>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.StartOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s starting offset, the position of the first character
            corresponding to this token in the source text.
            <para/>
            Note that the difference between <see cref="P:Lucene.Net.Analysis.Token.EndOffset"/> and <see cref="P:Lucene.Net.Analysis.Token.StartOffset"/>
            may not be equal to termText.Length, as the term text may have been altered by a
            stemmer or some other filter.
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.EndOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s ending offset, one greater than the position of the
            last character corresponding to this token in the source text. The length
            of the token in the source text is (<code>EndOffset</code> - <see cref="P:Lucene.Net.Analysis.Token.StartOffset"/>).
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)">
            <summary>
            Set the starting and ending offset.
            </summary>
            <exception cref="T:System.ArgumentException"> If <paramref name="startOffset"/> or <paramref name="endOffset"/>
                    are negative, or if <paramref name="startOffset"/> is greater than
                    <paramref name="endOffset"/> </exception>
            <seealso cref="P:Lucene.Net.Analysis.Token.StartOffset"/>
            <seealso cref="P:Lucene.Net.Analysis.Token.EndOffset"/>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.Type">
            <summary>Gets or Sets this <see cref="T:Lucene.Net.Analysis.Token"/>'s lexical type.  Defaults to "word". </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.Flags">
            <summary>
            Get the bitset for any bits that have been set.
            <para/>
            This is completely distinct from <see cref="P:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute.Type" />, although they do share similar purposes.
            The flags can be used to encode information about the token for use by other <see cref="T:Lucene.Net.Analysis.TokenFilter" />s.
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute"/>
        </member>
        <member name="P:Lucene.Net.Analysis.Token.Payload">
            <summary>
            Gets or Sets this <see cref="T:Lucene.Net.Analysis.Token"/>'s payload.
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Clear">
            <summary>
            Resets the term text, payload, flags, and positionIncrement,
            startOffset, endOffset and token type to default.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Clone(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Makes a clone, but replaces the term buffer &amp;
            start/end offset in the process.  This is more
            efficient than doing a full clone (and then calling
            <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/>) because it saves a wasted copy of the old
            termBuffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="!:CopyBuffer(char[], int, int)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="!:CopyBuffer(char[], int, int)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) on <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="!:Append(string)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.String)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="!:Append(string, int, int)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="!:Append(string)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) on <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Shorthand for calling <see cref="M:Lucene.Net.Analysis.Token.Clear"/>,
            <see cref="!:Append(string, int, int)"/>,
            <see cref="M:Lucene.Net.Analysis.Token.SetOffset(System.Int32,System.Int32)"/>,
            <see cref="P:Lucene.Net.Analysis.Token.Type"/> (set) on <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
            <returns> this <see cref="T:Lucene.Net.Analysis.Token"/> instance  </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token)">
            <summary>
            Copy the prototype token's fields into this one. Note: Payloads are shared. </summary>
            <param name="prototype"> source <see cref="T:Lucene.Net.Analysis.Token"/> to copy fields from </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.String)">
            <summary>
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared. </summary>
            <param name="prototype"> existing <see cref="T:Lucene.Net.Analysis.Token"/> </param>
            <param name="newTerm"> new term text </param>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.Reinit(Lucene.Net.Analysis.Token,System.Char[],System.Int32,System.Int32)">
            <summary>
            Copy the prototype token's fields into this one, with a different term. Note: Payloads are shared. </summary>
            <param name="prototype"> existing <see cref="T:Lucene.Net.Analysis.Token"/> </param>
            <param name="newTermBuffer"> buffer containing new term text </param>
            <param name="offset"> the index in the buffer of the first character </param>
            <param name="length"> number of valid characters in the buffer </param>
        </member>
        <member name="F:Lucene.Net.Analysis.Token.TOKEN_ATTRIBUTE_FACTORY">
            <summary>
            Convenience factory that returns <see cref="T:Lucene.Net.Analysis.Token"/> as implementation for the basic
            attributes and return the default impl (with &quot;Impl&quot; appended) for all other
            attributes.
            @since 3.0
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.Token.TokenAttributeFactory">
            <summary>
            <b>Expert:</b> Creates a <see cref="T:Lucene.Net.Analysis.Token.TokenAttributeFactory"/> returning <see cref="T:Lucene.Net.Analysis.Token"/> as instance for the basic attributes
            and for all other attributes calls the given delegate factory.
            @since 3.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Token.TokenAttributeFactory.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            <b>Expert</b>: Creates an <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> returning <see cref="T:Lucene.Net.Analysis.Token"/> as instance for the basic attributes
            and for all other attributes calls the given delegate factory.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenFilter">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenFilter"/> is a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is another <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            <para/>
            This is an abstract class; subclasses must override <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Analysis.TokenStream"/>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenFilter.m_input">
            <summary>
            The source of tokens for this filter. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.#ctor(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Construct a token stream filtering the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.End">
            <summary>
            This method is called by the consumer after the last token has been
            consumed, after <see cref="!:IncrementToken()"/> returned <c>false</c>
            (using the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API). Streams implementing the old API
            should upgrade to use this feature.
            <para/>
            This method can be used to perform any end-of-stream operations, such as
            setting the final offset of a stream. The final offset of a stream might
            differ from the offset of the last token eg in case one or more whitespaces
            followed after the last token, but a WhitespaceTokenizer was used.
            <para/>
            Additionally any skipped positions (such as those removed by a stopfilter)
            can be applied to the position increment, or any adjustment of other
            attributes where the end-of-stream value may be important.
            <para/>
            <b>NOTE:</b>
            The default implementation chains the call to the input TokenStream, so
            be sure to call <c>base.End()</c> first when overriding this method.
            </summary>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this stream.
            <para/>
            If you override this method, always call <c>base.Dispose(disposing)</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on reuse).
            <para/>
            <b>NOTE:</b>
            The default implementation chains the call to the input TokenStream, so
            be sure to call <c>base.Dispose(disposing)</c> when overriding this method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenFilter.Reset">
            <summary>
            This method is called by a consumer before it begins consumption using
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            <para/>
            Resets this stream to a clean state. Stateful implementations must implement
            this method so that they can be reused, just as if they had been created fresh.
            <para/>
            If you override this method, always call <c>base.Reset()</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on further usage).
            </summary>
            <remarks>
            <b>NOTE:</b>
            The default implementation chains the call to the input <see cref="T:Lucene.Net.Analysis.TokenStream"/>, so
            be sure to call <c>base.Reset()</c> when overriding this method.
            </remarks>
        </member>
        <member name="T:Lucene.Net.Analysis.Tokenizer">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.Tokenizer"/> is a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is a <see cref="T:System.IO.TextReader"/>.
            <para/>
            This is an abstract class; subclasses must override <seealso cref="!:#IncrementToken()"/>
            <para/>
            NOTE: Subclasses overriding <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> must
            call <see cref="M:Lucene.Net.Util.AttributeSource.ClearAttributes"/> before
            setting attributes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Tokenizer.m_input">
            <summary>
            The text source for this <see cref="T:Lucene.Net.Analysis.Tokenizer"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.Tokenizer.inputPending">
            <summary>
            Pending reader: not actually assigned to input until <see cref="M:Lucene.Net.Analysis.Tokenizer.Reset"/> </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(System.IO.TextReader)">
            <summary>
            Construct a token stream processing the given input. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory,System.IO.TextReader)">
            <summary>
            Construct a token stream processing the given input using the given <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this stream.
            <para/>
            If you override this method, always call <c>base.Dispose(disposing)</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on reuse).
            </summary>
            <remarks>
            <b>NOTE:</b>
            The default implementation closes the input <see cref="T:System.IO.TextReader"/>, so
            be sure to call <c>base.Dispose(disposing)</c> when overriding this method.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.CorrectOffset(System.Int32)">
            <summary>
            Return the corrected offset. If <see cref="F:Lucene.Net.Analysis.Tokenizer.m_input"/> is a <see cref="T:Lucene.Net.Analysis.CharFilter"/> subclass
            this method calls <see cref="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)"/>, else returns <paramref name="currentOff"/>. </summary>
            <param name="currentOff"> offset as seen in the output </param>
            <returns> corrected offset based on the input </returns>
            <seealso cref="M:Lucene.Net.Analysis.CharFilter.CorrectOffset(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.Tokenizer.SetReader(System.IO.TextReader)">
            <summary>
            Expert: Set a new reader on the <see cref="T:Lucene.Net.Analysis.Tokenizer"/>. Typically, an
            analyzer (in its tokenStream method) will use
            this to re-use a previously created tokenizer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenStream">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> enumerates the sequence of tokens, either from
            <see cref="T:Lucene.Net.Documents.Field"/>s of a <see cref="T:Lucene.Net.Documents.Document"/> or from query text.
            <para/>
            this is an abstract class; concrete subclasses are:
            <list type="bullet">
                <item><see cref="T:Lucene.Net.Analysis.Tokenizer"/>, a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is a <see cref="T:System.IO.TextReader"/>; and</item>
                <item><see cref="T:Lucene.Net.Analysis.TokenFilter"/>, a <see cref="T:Lucene.Net.Analysis.TokenStream"/> whose input is another
                    <see cref="T:Lucene.Net.Analysis.TokenStream"/>.</item>
            </list>
            A new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API has been introduced with Lucene 2.9. this API
            has moved from being <see cref="T:Lucene.Net.Analysis.Token"/>-based to <see cref="T:Lucene.Net.Util.IAttribute"/>-based. While
            <see cref="T:Lucene.Net.Analysis.Token"/> still exists in 2.9 as a convenience class, the preferred way
            to store the information of a <see cref="T:Lucene.Net.Analysis.Token"/> is to use <see cref="T:System.Attribute"/>s.
            <para/>
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> now extends <see cref="T:Lucene.Net.Util.AttributeSource"/>, which provides
            access to all of the token <see cref="T:Lucene.Net.Util.IAttribute"/>s for the <see cref="T:Lucene.Net.Analysis.TokenStream"/>.
            Note that only one instance per <see cref="T:System.Attribute"/> is created and reused
            for every token. This approach reduces object creation and allows local
            caching of references to the <see cref="T:System.Attribute"/>s. See
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> for further details.
            <para/>
            <b>The workflow of the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API is as follows:</b>
            <list type="number">
                <item>Instantiation of <see cref="T:Lucene.Net.Analysis.TokenStream"/>/<see cref="T:Lucene.Net.Analysis.TokenFilter"/>s which add/get
                    attributes to/from the <see cref="T:Lucene.Net.Util.AttributeSource"/>.</item>
                <item>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.Reset"/>.</item>
                <item>The consumer retrieves attributes from the stream and stores local
                    references to all attributes it wants to access.</item>
                <item>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> until it returns false
                    consuming the attributes after each call.</item>
                <item>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.End"/> so that any end-of-stream operations
                    can be performed.</item>
                <item>The consumer calls <see cref="M:Lucene.Net.Analysis.TokenStream.Dispose"/> to release any resource when finished
                    using the <see cref="T:Lucene.Net.Analysis.TokenStream"/>.</item>
            </list>
            To make sure that filters and consumers know which attributes are available,
            the attributes must be added during instantiation. Filters and consumers are
            not required to check for availability of attributes in
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            <para/>
            You can find some example code for the new API in the analysis 
            documentation.
            <para/>
            Sometimes it is desirable to capture a current state of a <see cref="T:Lucene.Net.Analysis.TokenStream"/>,
            e.g., for buffering purposes (see <see cref="T:Lucene.Net.Analysis.CachingTokenFilter"/>,
            TeeSinkTokenFilter). For this usecase
            <see cref="M:Lucene.Net.Util.AttributeSource.CaptureState"/> and <see cref="M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)"/>
            can be used.
            <para/>The <see cref="T:Lucene.Net.Analysis.TokenStream"/>-API in Lucene is based on the decorator pattern.
            Therefore all non-abstract subclasses must be sealed or have at least a sealed
            implementation of <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>! This is checked when assertions are enabled.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> using the default attribute factory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor(Lucene.Net.Util.AttributeSource)">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> that uses the same attributes as the supplied one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.TokenStream"/> using the supplied <see cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> 
            for creating new <see cref="T:Lucene.Net.Util.IAttribute"/> instances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.IncrementToken">
            <summary>
            Consumers (i.e., <see cref="T:Lucene.Net.Index.IndexWriter"/>) use this method to advance the stream to
            the next token. Implementing classes must implement this method and update
            the appropriate <see cref="T:Lucene.Net.Util.IAttribute"/>s with the attributes of the next
            token.
            <para/>
            The producer must make no assumptions about the attributes after the method
            has been returned: the caller may arbitrarily change it. If the producer
            needs to preserve the state for subsequent calls, it can use
            <see cref="M:Lucene.Net.Util.AttributeSource.CaptureState"/> to create a copy of the current attribute state.
            <para/>
            this method is called for every token of a document, so an efficient
            implementation is crucial for good performance. To avoid calls to
            <see cref="M:Lucene.Net.Util.AttributeSource.AddAttribute``1"/> and <see cref="M:Lucene.Net.Util.AttributeSource.GetAttribute``1"/>,
            references to all <see cref="T:Lucene.Net.Util.IAttribute"/>s that this stream uses should be
            retrieved during instantiation.
            <para/>
            To ensure that filters and consumers know which attributes are available,
            the attributes must be added during instantiation. Filters and consumers
            are not required to check for availability of attributes in
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            </summary>
            <returns> false for end of stream; true otherwise </returns>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.End">
            <summary>
            This method is called by the consumer after the last token has been
            consumed, after <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/> returned <c>false</c>
            (using the new <see cref="T:Lucene.Net.Analysis.TokenStream"/> API). Streams implementing the old API
            should upgrade to use this feature.
            <para/>
            This method can be used to perform any end-of-stream operations, such as
            setting the final offset of a stream. The final offset of a stream might
            differ from the offset of the last token eg in case one or more whitespaces
            followed after the last token, but a WhitespaceTokenizer was used.
            <para/>
            Additionally any skipped positions (such as those removed by a stopfilter)
            can be applied to the position increment, or any adjustment of other
            attributes where the end-of-stream value may be important.
            <para/>
            If you override this method, always call <c>base.End();</c>.
            </summary>
            <exception cref="T:System.IO.IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Reset">
            <summary>
            This method is called by a consumer before it begins consumption using
            <see cref="M:Lucene.Net.Analysis.TokenStream.IncrementToken"/>.
            <para/>
            Resets this stream to a clean state. Stateful implementations must implement
            this method so that they can be reused, just as if they had been created fresh.
            <para/>
            If you override this method, always call <c>base.Reset()</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on further usage).
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStream.Dispose(System.Boolean)">
            <summary>
            Releases resources associated with this stream.
            <para/>
            If you override this method, always call <c>base.Dispose(disposing)</c>, otherwise
            some internal state will not be correctly reset (e.g., <see cref="T:Lucene.Net.Analysis.Tokenizer"/> will
            throw <see cref="T:System.InvalidOperationException"/> on reuse).
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenStreamToAutomaton">
             <summary>
             Consumes a <see cref="T:Lucene.Net.Analysis.TokenStream"/> and creates an <see cref="T:Lucene.Net.Util.Automaton.Automaton"/>
             where the transition labels are UTF8 bytes (or Unicode
             code points if unicodeArcs is true) from the <see cref="T:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute"/>.
             Between tokens we insert
             <see cref="F:Lucene.Net.Analysis.TokenStreamToAutomaton.POS_SEP"/> and for holes we insert <see cref="F:Lucene.Net.Analysis.TokenStreamToAutomaton.HOLE"/>.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamToAutomaton.PreservePositionIncrements">
            <summary>
            Whether to generate holes in the automaton for missing positions, <c>true</c> by default. </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenStreamToAutomaton.UnicodeArcs">
            <summary>
            Whether to make transition labels Unicode code points instead of UTF8 bytes,
            <c>false</c> by default
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.ChangeToken(Lucene.Net.Util.BytesRef)">
            <summary>
            Subclass &amp; implement this if you need to change the
            token (such as escaping certain bytes) before it's
            turned into a graph.
            </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamToAutomaton.POS_SEP">
            <summary>
            We create transition between two adjacent tokens. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenStreamToAutomaton.HOLE">
            <summary>
            We add this arc to represent a hole. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenStreamToAutomaton.ToAutomaton(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Pulls the graph (including <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute"/>
            from the provided <see cref="T:Lucene.Net.Analysis.TokenStream"/>, and creates the corresponding
            automaton where arcs are bytes (or Unicode code points
            if unicodeArcs = true) from each term.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.#ctor">
            <summary>
            Initialize this attribute with empty term text </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute.ToString">
            <summary>
            Returns solely the term text as specified by the
            <see cref="T:Lucene.Net.Support.ICharSequence"/> interface.
            <para/>
            this method changed the behavior with Lucene 3.1,
            before it returned a String representation of the whole
            term with all attributes.
            this affects especially the
            <see cref="T:Lucene.Net.Analysis.Token"/> subclass.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.FlagsAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.FlagsAttribute.#ctor">
            <summary>
            Initialize this attribute with no bits set </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute">
            <summary>
            The term text of a <see cref="T:Lucene.Net.Analysis.Token"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the contents of buffer, starting at offset for
            length characters, into the termBuffer array. </summary>
            <param name="buffer"> the buffer to copy </param>
            <param name="offset"> the index in the buffer of the first character to copy </param>
            <param name="length"> the number of characters to copy </param>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Buffer">
            <summary>
            Returns the internal termBuffer character array which
            you can then directly alter.  If the array is too
            small for your token, use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)"/>
            to increase it.  After
            altering the buffer be sure to call <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)"/> 
            to record the number of valid
            characters that were placed into the termBuffer.
            <para>
            <b>NOTE</b>: The returned buffer may be larger than
            the valid <see cref="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length"/>.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)">
            <summary>
            Grows the termBuffer to at least size <paramref name="newSize"/>, preserving the
            existing content. </summary>
            <param name="newSize"> minimum size of the new termBuffer </param>
            <returns> newly created termBuffer with length >= newSize </returns>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length">
            <summary>
            Gets or Sets the number of valid characters (in
            the termBuffer array.
            <seealso cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetLength(System.Int32)">
            <summary>
            Set number of valid characters (length of the term) in
            the termBuffer array. Use this to truncate the termBuffer
            or to synchronize with external manipulation of the termBuffer.
            Note: to grow the size of the array,
            use <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.ResizeBuffer(System.Int32)"/> first. 
            NOTE: This is exactly the same operation as calling the <see cref="P:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Length"/> setter, the primary 
            difference is that this method returns a reference to the current object so it can be chained.
            <code>
            obj.SetLength(30).Append("hey you");
            </code>
            </summary>
            <param name="length"> the truncated length </param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.SetEmpty">
            <summary>
            Sets the length of the termBuffer to zero.
            Use this method before appending contents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(Lucene.Net.Support.ICharSequence)">
            <summary>
            Appends the contents of the <see cref="T:Lucene.Net.Support.ICharSequence"/> to this character sequence.
            <para>
            The characters of the <see cref="T:Lucene.Net.Support.ICharSequence"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, then the four
            characters <c>"null"</c> are appended.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(Lucene.Net.Support.ICharSequence,System.Int32,System.Int32)">
            <summary>
            Appends the contents of the <see cref="T:Lucene.Net.Support.ICharSequence"/> to this character sequence, beginning and ending
            at the specified indices.
            <para>
            The characters of the <see cref="T:Lucene.Net.Support.ICharSequence"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, then the four
            characters <c>"null"</c> are appended.
            </para>
            </summary>
            <param name="csq">The index of the first character in the subsequence.</param>
            <param name="start">The start index of the <see cref="T:Lucene.Net.Support.ICharSequence"/> to begin copying characters.</param>
            <param name="end">The index of the character following the last character in the subsequence.</param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Char)">
            <summary>
            Appends the supplied <see cref="T:System.Char"/> to this character sequence.
            </summary>
            <param name="c">The <see cref="T:System.Char"/> to append.</param>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Char[])">
            <summary>
            Appends the contents of the <see cref="!:char[]"/> array to this character sequence.
            <para>
            The characters of the <see cref="!:char[]"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, then the four
            characters <c>"null"</c> are appended.
            </para>
            </summary>
            <param name="csq">The <see cref="!:char[]"/> array to append.</param>
            <remarks>
            LUCENENET specific method, added to simulate using the CharBuffer class in Java.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Char[],System.Int32,System.Int32)">
            <summary>
            Appends the contents of the <see cref="!:char[]"/> array to this character sequence, beginning and ending
            at the specified indices.
            <para>
            The characters of the <see cref="!:char[]"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, then the four
            characters <c>"null"</c> are appended.
            </para>
            </summary>
            <param name="csq">The <see cref="!:char[]"/> array to append.</param>
            <param name="start">The start index of the <see cref="!:char[]"/> to begin copying characters.</param>
            <param name="end">The index of the character following the last character in the subsequence.</param>
            <remarks>
            LUCENENET specific method, added to simulate using the CharBuffer class in Java. Note that
            the <see cref="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.CopyBuffer(System.Char[],System.Int32,System.Int32)"/> method provides similar functionality, except for
            the last argument of this method is an index of the array rather than the length of characters to copy.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String)">
            <summary>
            Appends the specified <see cref="T:System.String"/> to this character sequence.
            <para>
            The characters of the <see cref="T:System.String"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, then the four
            characters <c>"null"</c> are appended.
            </para>
            </summary>
            <remarks>
            LUCENENET specific method, added because the .NET <see cref="T:System.String"/> data type 
            doesn't implement <see cref="T:Lucene.Net.Support.ICharSequence"/>. 
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.String,System.Int32,System.Int32)">
            <summary>
            Appends the contents of the <see cref="T:System.String"/> to this character sequence, beginning and ending
            at the specified indices.
            <para>
            The characters of the <see cref="T:System.String"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, then the four
            characters <c>"null"</c> are appended.
            </para>
            </summary>
            <param name="csq">The index of the first character in the subsequence.</param>
            <param name="start">The start index of the <see cref="T:System.String"/> to begin copying characters.</param>
            <param name="end">The index of the character following the last character in the subsequence.</param>
            <remarks>
            LUCENENET specific method, added because the .NET <see cref="T:System.String"/> data type 
            doesn't implement <see cref="T:Lucene.Net.Support.ICharSequence"/>. 
            </remarks>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Text.StringBuilder)">
            <summary>
            Appends the specified <see cref="T:System.Text.StringBuilder"/> to this character sequence.
            <para>
            The characters of the <see cref="T:System.Text.StringBuilder"/> argument are appended, in order, increasing the length of
            this sequence by the length of the argument. If argument is <c>null</c>, then the four
            characters <c>"null"</c> are appended.
            </para>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(System.Text.StringBuilder,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute.Append(Lucene.Net.Analysis.TokenAttributes.ICharTermAttribute)" -->
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute">
            <summary> This attribute can be used to pass different flags down the <see cref="T:Lucene.Net.Analysis.Tokenizer" /> chain,
            eg from one TokenFilter to another one.
            <para/>
            This is completely distinct from <see cref="T:Lucene.Net.Analysis.TokenAttributes.TypeAttribute"/>, although they do share similar purposes.
            The flags can be used to encode information about the token for use by other 
            <see cref="T:Lucene.Net.Analysis.TokenFilter"/>s.
            @lucene.experimental While we think this is here to stay, we may want to change it to be a long.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IFlagsAttribute.Flags">
            <summary>
            Get the bitset for any bits that have been set.
            <para/>
            This is completely distinct from <see cref="P:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute.Type" />, although they do share similar purposes.
            The flags can be used to encode information about the token for use by other <see cref="T:Lucene.Net.Analysis.TokenFilter" />s.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute">
            <summary>
            This attribute can be used to mark a token as a keyword. Keyword aware
            <see cref="T:Lucene.Net.Analysis.TokenStream"/>s can decide to modify a token based on the return value
            of <see cref="P:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute.IsKeyword"/> if the token is modified. Stemming filters for
            instance can use this attribute to conditionally skip a term if
            <see cref="P:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute.IsKeyword"/> returns <c>true</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute.IsKeyword">
            <summary>
            Gets or Sets whether the current token is a keyword. <c>true</c> if the current token is a keyword, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute">
            <summary>
            The start and end character offset of a <see cref="T:Lucene.Net.Analysis.Token"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s starting offset, the position of the first character
            corresponding to this token in the source text.
            <para/>
            Note that the difference between <see cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.EndOffset"/> and <see cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset"/>
            may not be equal to termText.Length, as the term text may have been altered by a
            stemmer or some other filter.
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.SetOffset(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.SetOffset(System.Int32,System.Int32)">
            <summary>
            Set the starting and ending offset.
            </summary>
            <exception cref="T:System.ArgumentException"> If <paramref name="startOffset"/> or <paramref name="endOffset"/>
                    are negative, or if <paramref name="startOffset"/> is greater than
                    <paramref name="endOffset"/> </exception>
            <seealso cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset"/>
            <seealso cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.EndOffset"/>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.EndOffset">
            <summary>
            Returns this <see cref="T:Lucene.Net.Analysis.Token"/>'s ending offset, one greater than the position of the
            last character corresponding to this token in the source text. The length
            of the token in the source text is (<code>EndOffset</code> - <see cref="P:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.StartOffset"/>).
            </summary>
            <seealso cref="M:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute.SetOffset(System.Int32,System.Int32)"/>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute">
            <summary>
            The payload of a Token.
            <para/>
            The payload is stored in the index at each position, and can
            be used to influence scoring when using Payload-based queries
            in the <see cref="N:Lucene.Net.Search.Payloads"/> and
            <see cref="N:Lucene.Net.Search.Spans"/> namespaces.
            <para/>
            NOTE: because the payload will be stored at each position, its usually
            best to use the minimum number of bytes necessary. Some codec implementations
            may optimize payload storage when all payloads have the same length.
            </summary>
            <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute.Payload">
            <summary>
            Gets or Sets this <see cref="T:Lucene.Net.Analysis.Token"/>'s payload.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute">
             <summary>
             Determines the position of this token
             relative to the previous <see cref="T:Lucene.Net.Analysis.Token"/> in a <see cref="T:Lucene.Net.Analysis.TokenStream"/>, used in phrase
             searching.
            
             <para/>The default value is one.
            
             <para/>Some common uses for this are:
             
             <list type="bullet">
             <item>Set it to zero to put multiple terms in the same position.  this is
             useful if, e.g., a word has multiple stems.  Searches for phrases
             including either stem will match.  In this case, all but the first stem's
             increment should be set to zero: the increment of the first instance
             should be one.  Repeating a token with an increment of zero can also be
             used to boost the scores of matches on that token.</item>
            
             <item>Set it to values greater than one to inhibit exact phrase matches.
             If, for example, one does not want phrases to match across removed stop
             words, then one could build a stop word filter that removes stop words and
             also sets the increment to the number of stop words removed before each
             non-stop word.  Then exact phrase queries will only match when the terms
             occur with no intervening stop words.</item>
             </list>
             </summary>
             <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute.PositionIncrement">
            <summary>
            Gets or Sets the position increment (the distance from the prior term). The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value is set to a negative value. </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute">
             <summary>
             Determines how many positions this
             token spans.  Very few analyzer components actually
             produce this attribute, and indexing ignores it, but
             it's useful to express the graph structure naturally
             produced by decompounding, word splitting/joining,
             synonym filtering, etc.
            
             <para/>NOTE: this is optional, and most analyzers
             don't change the default value (1).
             </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute.PositionLength">
            <summary>
            Gets or Sets the position length of this <see cref="T:Lucene.Net.Analysis.Token"/> (how many positions this token
            spans).
            <para/>
            The default value is one.
            </summary>
            <exception cref="T:System.ArgumentException"> if value
                    is set to zero or negative. </exception>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute">
             <summary>
             This attribute is requested by TermsHashPerField to index the contents.
             This attribute can be used to customize the final byte[] encoding of terms.
             <para/>
             Consumers of this attribute call <see cref="P:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.BytesRef"/> up-front, and then
             invoke <see cref="M:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.FillBytesRef"/> for each term. Example:
             <code>
               TermToBytesRefAttribute termAtt = tokenStream.GetAttribute&lt;TermToBytesRefAttribute&gt;;
               BytesRef bytes = termAtt.BytesRef;
            
               while (tokenStream.IncrementToken()
               {
                 // you must call termAtt.FillBytesRef() before doing something with the bytes.
                 // this encodes the term value (internally it might be a char[], etc) into the bytes.
                 int hashCode = termAtt.FillBytesRef();
            
                 if (IsInteresting(bytes))
                 {
                   // because the bytes are reused by the attribute (like CharTermAttribute's char[] buffer),
                   // you should make a copy if you need persistent access to the bytes, otherwise they will
                   // be rewritten across calls to IncrementToken()
            
                   DoSomethingWith(new BytesRef(bytes));
                 }
               }
               ...
             </code>
             @lucene.experimental this is a very expert API, please use
             <see cref="T:Lucene.Net.Analysis.TokenAttributes.CharTermAttribute"/> and its implementation of this method
             for UTF-8 terms.
             </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.FillBytesRef">
            <summary>
            Updates the bytes <see cref="T:Lucene.Net.Util.BytesRef"/> to contain this term's
            final encoding.
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.BytesRef">
            <summary>
            Retrieve this attribute's <see cref="T:Lucene.Net.Util.BytesRef"/>. The bytes are updated
            from the current term when the consumer calls <see cref="M:Lucene.Net.Analysis.TokenAttributes.ITermToBytesRefAttribute.FillBytesRef"/>.
            </summary>
            <returns> this <see cref="T:Lucene.Net.Util.IAttribute"/>s internal <see cref="T:Lucene.Net.Util.BytesRef"/>. </returns>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute">
            <summary>
            A <see cref="T:Lucene.Net.Analysis.Token"/>'s lexical type. The Default value is "word".
            </summary>
        </member>
        <member name="P:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute.Type">
            <summary>
            Gets or Sets the lexical type. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.TypeAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.ITypeAttribute"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE">
            <summary>
            the default type
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.#ctor">
            <summary>
            Initialize this attribute with <see cref="F:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.DEFAULT_TYPE"/> </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.TypeAttribute.#ctor(System.String)">
            <summary>
            Initialize this attribute with <paramref name="type"/> </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.KeywordAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IKeywordAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.KeywordAttribute.#ctor">
            <summary>
            Initialize this attribute with the keyword value as false. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.OffsetAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IOffsetAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.OffsetAttribute.#ctor">
            <summary>
            Initialize this attribute with startOffset and endOffset of 0. </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.PayloadAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPayloadAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PayloadAttribute.#ctor">
            <summary>
            Initialize this attribute with no payload.
            </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PayloadAttribute.#ctor(Lucene.Net.Util.BytesRef)">
            <summary>
            Initialize this attribute with the given payload.
            </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.PositionIncrementAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionIncrementAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PositionIncrementAttribute.#ctor">
            <summary>
            Initialize this attribute with position increment of 1 </summary>
        </member>
        <member name="T:Lucene.Net.Analysis.TokenAttributes.PositionLengthAttribute">
            <summary>
            Default implementation of <see cref="T:Lucene.Net.Analysis.TokenAttributes.IPositionLengthAttribute"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Analysis.TokenAttributes.PositionLengthAttribute.#ctor">
            <summary>
            Initializes this attribute with position length of 1. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTermState">
            <summary>
            Holds all state required for <seealso cref="T:Lucene.Net.Codecs.PostingsReaderBase"/>
            to produce a <seealso cref="T:Lucene.Net.Index.DocsEnum"/> without re-seeking the
            terms dict.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.DocFreq">
            <summary>
            how many docs have this term </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.TotalTermFreq">
            <summary>
            total number of occurrences of this term </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.TermBlockOrd">
            <summary>
            the term's ord in the current block </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTermState.BlockFilePointer">
            <summary>
            fp into the terms dict primary file (_X.tim) that holds this term </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTermState.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.BlockTreeTermsReader" -->
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.dirOffset">
            <summary>
            File offset where the directory starts in the terms file. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsReader.indexDirOffset">
            <summary>
            File offset where the directory starts in the index file. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Codecs.PostingsReaderBase,Lucene.Net.Store.IOContext,System.String,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.ReadHeader(Lucene.Net.Store.IndexInput)">
            <summary>
            Reads terms file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.ReadIndexHeader(Lucene.Net.Store.IndexInput)">
            <summary>
            Reads index file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.SeekDir(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>
            Seek {@code input} to the directory offset. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsReader.Stats">
            <summary>
            BlockTree statistics for a single field
            returned by <seealso cref="!:FieldReader#computeStats()"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexNodeCount">
            <summary>
            How many nodes in the index FST. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexArcCount">
            <summary>
            How many arcs in the index FST. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.IndexNumBytes">
            <summary>
            Byte size of the index. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalTermCount">
            <summary>
            Total number of terms in the field. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalTermBytes">
            <summary>
            Total number of bytes (sum of term lengths) across all terms in the field. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.NonFloorBlockCount">
            <summary>
            The number of normal (non-floor) blocks in the terms file. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.FloorBlockCount">
            <summary>
            The number of floor blocks (meta-blocks larger than the
             allowed {@code maxItemsPerBlock}) in the terms file.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.FloorSubBlockCount">
            <summary>
            The number of sub-blocks within the floor blocks. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.MixedBlockCount">
            <summary>
            The number of "internal" blocks (that have both
             terms and sub-blocks).
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TermsOnlyBlockCount">
            <summary>
            The number of "leaf" blocks (blocks that have only
             terms).
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.SubBlocksOnlyBlockCount">
            <summary>
            The number of "internal" blocks that do not contain
             terms (have only sub-blocks).
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockCount">
            <summary>
            Total number of blocks. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.BlockCountByPrefixLen">
            <summary>
            Number of blocks at each prefix depth. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockSuffixBytes">
            <summary>
            Total number of bytes used to store term suffixes. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockStatsBytes">
            <summary>
            Total number of bytes used to store term stats (not
             including what the <seealso cref="T:Lucene.Net.Codecs.PostingsBaseFormat"/>
             stores.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.TotalBlockOtherBytes">
            <summary>
            Total bytes stored by the <seealso cref="T:Lucene.Net.Codecs.PostingsBaseFormat"/>,
             plus the other few vInts stored in the frame.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.Segment">
            <summary>
            Segment name. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.Stats.Field">
            <summary>
            Field name. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader">
            <summary>
            BlockTree's implementation of <seealso cref="M:Lucene.Net.Codecs.BlockTreeTermsReader.GetTerms(System.String)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.ComputeStats">
            <summary>
            For debugging -- used by CheckIndex too </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.IntersectEnum.Frame.Int64s">
            <summary>
            NOTE: This was longs (field) in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.SegmentTermsEnum.ComputeBlockStats">
            <summary>
            Runs next() through the entire terms dict,
             computing aggregate statistics.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsReader.FieldReader.SegmentTermsEnum.Frame.Int64s">
            <summary>
            NOTE: This was longs (field) in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.BlockTreeTermsWriter" -->
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.DEFAULT_MIN_BLOCK_SIZE">
            <summary>
            Suggested default value for the {@code
             minItemsInBlock} parameter to {@link
             #BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.DEFAULT_MAX_BLOCK_SIZE">
            <summary>
            Suggested default value for the {@code
             maxItemsInBlock} parameter to {@link
             #BlockTreeTermsWriter(SegmentWriteState,PostingsWriterBase,int,int)}.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.TERMS_EXTENSION">
            <summary>
            Extension of terms file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_START">
            <summary>
            Initial terms format. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_APPEND_ONLY">
            <summary>
            Append-only </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_META_ARRAY">
            <summary>
            Meta data as array </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_CHECKSUM">
            <summary>
            checksums </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.VERSION_CURRENT">
            <summary>
            Current terms format. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.BlockTreeTermsWriter.TERMS_INDEX_EXTENSION">
            <summary>
            Extension of terms index file </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.BlockTreeTermsWriter.FieldMetaData.Int64sSize">
            <summary>
            NOTE: This was longsSize (field) in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,Lucene.Net.Codecs.PostingsWriterBase,System.Int32,System.Int32)">
            <summary>
            Create a new writer.  The number of items (terms or
             sub-blocks) per block will aim to be between
             minItemsPerBlock and maxItemsPerBlock, though in some
             cases the blocks may be smaller than the min.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteHeader(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the terms file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteIndexHeader(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the index file header. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteTrailer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Writes the terms file trailer. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.BlockTreeTermsWriter.WriteIndexTrailer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Writes the index file trailer. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Codec">
            <summary>
            Encodes/decodes an inverted index segment.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.Codec.Name"/>) is
            written into the index. In order for the segment to be read, the
            name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.Codec.ForName(System.String)"/>.
            This method uses <see cref="M:Lucene.Net.Codecs.ICodecFactory.GetCodec(System.String)"/> to resolve codec names.
            <para/>
            To implement your own codec:
            <list type="number">
                <item>Subclass this class.</item>
                <item>Subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>, override the <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize"/> method,
                    and add the line <c>base.ScanForCodecs(typeof(YourCodec).GetTypeInfo().Assembly)</c>. 
                    If you have any codec classes in your assembly 
                    that are not meant for reading, you can add the <see cref="T:Lucene.Net.Codecs.ExcludeCodecFromScanAttribute"/> 
                    to them so they are ignored by the scan.</item>
                <item>set the new <see cref="T:Lucene.Net.Codecs.ICodecFactory"/> by calling <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/> at application startup.</item>
            </list>
            If your codec has dependencies, you may also override <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.Type)"/> to inject 
            them via pure DI or a DI container. See <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI-Friendly Framework</a>
            to understand the approach used.
            <para/>
            <b>Codec Names</b>
            <para/>
            Unlike the Java version, codec names are by default convention-based on the class name. 
            If you name your custom codec class "MyCustomCodec", the codec name will the same name 
            without the "Codec" suffix: "MyCustom".
            <para/>
            You can override this default behavior by using the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/> to
            name the codec differently than this convention. Codec names must be all ASCII alphanumeric, 
            and less than 128 characters in length.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.ICodecFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Codecs.ICodecFactory"/> instance used to instantiate
            <see cref="T:Lucene.Net.Codecs.Codec"/> subclasses.
            </summary>
            <param name="codecFactory">The new <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="codecFactory"/> parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.GetCodecFactory">
            <summary>
            Gets the associated codec factory.
            </summary>
            <returns>The codec factory.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.#ctor">
            <summary>
            Creates a new codec.
            <para/>
            The <see cref="P:Lucene.Net.Codecs.Codec.Name"/> will be written into the index segment: in order for
            the segment to be read this class should be registered by subclassing <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> and
            calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/> in the class constructor. 
            The new <see cref="T:Lucene.Net.Codecs.ICodecFactory"/> can be registered by calling <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/> at application startup.</summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.Name">
            <summary>
            Returns this codec's name </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.PostingsFormat">
            <summary>
            Encodes/decodes postings </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.DocValuesFormat">
            <summary>
            Encodes/decodes docvalues </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.StoredFieldsFormat">
            <summary>
            Encodes/decodes stored fields </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.TermVectorsFormat">
            <summary>
            Encodes/decodes term vectors </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.FieldInfosFormat">
            <summary>
            Encodes/decodes field infos file </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.SegmentInfoFormat">
            <summary>
            Encodes/decodes segment info file </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.NormsFormat">
            <summary>
            Encodes/decodes document normalization values </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.LiveDocsFormat">
            <summary>
            Encodes/decodes live docs </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.ForName(System.String)">
            <summary>
            looks up a codec by name </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.AvailableCodecs">
            <summary>
            returns a list of all available codec names </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Codec.Default">
            <summary>
            expert: returns the default codec used for newly created
             <seealso cref="!:IndexWriterConfig"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Codec.ToString">
            <summary>
            returns the codec's name. Subclasses can override to provide
            more detail (such as parameters).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.CodecUtil" -->
        <member name="F:Lucene.Net.Codecs.CodecUtil.CODEC_MAGIC">
            <summary>
            Constant to identify the start of a codec header.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.CodecUtil.FOOTER_MAGIC">
            <summary>
            Constant to identify the start of a codec footer.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.HeaderLength(System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.CheckHeader(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckHeaderNoMagic(Lucene.Net.Store.DataInput,System.String,System.Int32,System.Int32)">
            <summary>
            Like {@link
             #checkHeader(DataInput,String,int,int)} except this
             version assumes the first int has already been read
             and validated from the input.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.FooterLength" -->
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckFooter(Lucene.Net.Store.ChecksumIndexInput)">
            <summary>
            Validates the codec footer previously written by <seealso cref="!:#writeFooter"/>. </summary>
            <returns> actual checksum value </returns>
            <exception cref="!:IOException"> if the footer is invalid, if the checksum does not match,
                                or if {@code in} is not properly positioned before the footer
                                at the end of the stream. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.RetrieveChecksum(Lucene.Net.Store.IndexInput)">
            <summary>
            Returns (but does not validate) the checksum previously written by <seealso cref="!:#checkFooter"/>. </summary>
            <returns> actual checksum value </returns>
            <exception cref="!:IOException"> if the footer is invalid </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.CodecUtil.CheckEOF(Lucene.Net.Store.IndexInput)">
            <summary>
            Checks that the stream is positioned at the end, and throws exception
            if it is not. </summary>
            @deprecated Use <seealso cref="!:#checkFooter"/> instead, this should only used for files without checksums
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.CodecUtil.ChecksumEntireFile(Lucene.Net.Store.IndexInput)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.DocValuesConsumer" -->
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddNumericField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes numeric docvalues for a field. </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of numeric values (one for each document). {@code null} indicates
                          a missing value. </param>
            <exception cref="!:IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddBinaryField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            Writes binary docvalues for a field. </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of binary values (one for each document). {@code null} indicates
                          a missing value. </param>
            <exception cref="!:IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes pre-sorted binary docvalues for a field. </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of binary values in sorted order (deduplicated). </param>
            <param name="docToOrd"> Iterable of ordinals (one for each document). {@code -1} indicates
                            a missing value. </param>
            <exception cref="!:IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.AddSortedSetField(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}},System.Collections.Generic.IEnumerable{System.Nullable{System.Int64}})">
            <summary>
            Writes pre-sorted set docvalues for a field </summary>
            <param name="field"> field information </param>
            <param name="values"> Iterable of binary values in sorted order (deduplicated). </param>
            <param name="docToOrdCount"> Iterable of the number of values for each document. A zero ordinal
                                 count indicates a missing value. </param>
            <param name="ords"> Iterable of ordinal occurrences (docToOrdCount*maxDoc total). </param>
            <exception cref="!:IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeNumericField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.NumericDocValues},System.Collections.Generic.IList{Lucene.Net.Util.IBits})">
            <summary>
            Merges the numeric docvalues from <code>toMerge</code>.
            <p>
            The default implementation calls <seealso cref="!:#addNumericField"/>, passing
            an Iterable that merges and filters deleted documents on the fly.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesConsumer.MergeBinaryField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.BinaryDocValues},System.Collections.Generic.IList{Lucene.Net.Util.IBits})" -->
        <member name="M:Lucene.Net.Codecs.DocValuesConsumer.MergeSortedField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.SortedDocValues})">
            <summary>
            Merges the sorted docvalues from <code>toMerge</code>.
            <p>
            The default implementation calls <seealso cref="!:#addSortedField"/>, passing
            an Iterable that merges ordinals and values and filters deleted documents.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesConsumer.MergeSortedSetField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.MergeState,System.Collections.Generic.IList{Lucene.Net.Index.SortedSetDocValues})" -->
        <member name="T:Lucene.Net.Codecs.DocValuesFormat">
            <summary>
            Encodes/decodes per-document values.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.DocValuesFormat.Name"/>) may
            written into the index in certain configurations. In order for the segment
            to be read, the name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.DocValuesFormat.ForName(System.String)"/>.
            this method uses <see cref="M:Lucene.Net.Codecs.IDocValuesFormatFactory.GetDocValuesFormat(System.String)"/> to resolve format names.
            <para/>
            To implement your own format:
            <list type="number">
                <item>Subclass this class.</item>
                <item>Subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>, override the <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize"/> method,
                    and add the line <c>base.ScanForDocValuesFormats(typeof(YourDocValuesFormat).GetTypeInfo().Assembly)</c>. 
                    If you have any format classes in your assembly 
                    that are not meant for reading, you can add the <see cref="T:Lucene.Net.Codecs.ExcludeDocValuesFormatFromScanAttribute"/> 
                    to them so they are ignored by the scan.</item>
                <item>Set the new <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/> by calling <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>
                    at application startup.</item>
            </list>
            If your format has dependencies, you may also override <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.Type)"/>
            to inject them via pure DI or a DI container. See <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI-Friendly Framework</a>
            to understand the approach used.
            <para/>
            <b>DocValuesFormat Names</b>
            <para/>
            Unlike the Java version, format names are by default convention-based on the class name. 
            If you name your custom format class "MyCustomDocValuesFormat", the format name will the same name 
            without the "DocValuesFormat" suffix: "MyCustom".
            <para/>
            You can override this default behavior by using the <see cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/> to
            name the format differently than this convention. Format names must be all ASCII alphanumeric, 
            and less than 128 characters in length.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/>
        </member>
        <member name="F:Lucene.Net.Codecs.DocValuesFormat.name">
            <summary>
            Unique name that's used to retrieve this format when
            reading the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/> instance used to instantiate
            <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> subclasses.
            </summary>
            <param name="docValuesFormatFactory">The new <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="docValuesFormatFactory"/> parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.GetDocValuesFormatFactory">
            <summary>
            Gets the associated <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> factory.
            </summary>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> factory.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.#ctor">
            <summary>
            Creates a new docvalues format.
            <para/>
            The provided name will be written into the index segment in some configurations
            (such as when using <see cref="T:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat"/>): in such configurations,
            for the segment to be read this class should be registered by subclassing <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> and
            calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/> in the class constructor.
            The new <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/> can be registered by calling <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>
            at application startup.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.DocValuesConsumer"/> to write docvalues to the
            index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.FieldsProducer(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Codecs.DocValuesProducer"/> to read docvalues from the index.
            <para/>
            NOTE: by the time this call returns, it must hold open any files it will
            need to use; else, those files may be deleted. Additionally, required files
            may be deleted during the execution of this call before there is a chance
            to open them. Under these circumstances an IOException should be thrown by
            the implementation. IOExceptions are expected and will automatically cause
            a retry of the segment opening logic with the newly revised segments.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.DocValuesFormat.Name">
            <summary>
            Unique name that's used to retrieve this format when
            reading the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.ForName(System.String)">
            <summary>
            looks up a format by name </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesFormat.AvailableDocValuesFormats">
            <summary>
            returns a list of all available format names </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.DocValuesProducer">
             <summary>
             Abstract API that produces numeric, binary and
             sorted docvalues.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetNumeric(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetBinary(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetSorted(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetSortedSet(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SortedSetDocValues"/> for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.GetDocsWithField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Util.IBits"/> at the size of <code>reader.maxDoc()</code>,
             with turned on bits for each docid that does have a value for this field.
             The returned instance need not be thread-safe: it will only be
             used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DocValuesProducer.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.DocValuesProducer.CheckIntegrity" -->
        <member name="T:Lucene.Net.Codecs.FieldInfosFormat">
            <summary>
            Encodes/decodes <seealso cref="T:Lucene.Net.Index.FieldInfos"/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosReader">
            <summary>
            Returns a <seealso cref="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosReader"/> to read field infos
             from the index
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosWriter">
            <summary>
            Returns a <seealso cref="P:Lucene.Net.Codecs.FieldInfosFormat.FieldInfosWriter"/> to write field infos
             to the index
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldInfosReader">
            <summary>
            Codec API for reading <seealso cref="T:Lucene.Net.Index.FieldInfos"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosReader.Read(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Read the <seealso cref="T:Lucene.Net.Index.FieldInfos"/> previously written with {@link
             FieldInfosWriter}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldInfosWriter">
            <summary>
            Codec API for writing <seealso cref="T:Lucene.Net.Index.FieldInfos"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldInfosWriter.Write(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Writes the provided <seealso cref="T:Lucene.Net.Index.FieldInfos"/> to the
             directory.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.FieldsConsumer" -->
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.AddField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Add a new field </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Dispose">
            <summary>
            Called when we are done adding everything. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Dispose(System.Boolean)">
            <summary>
            Called when we are done adding everything. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsConsumer.Merge(Lucene.Net.Index.MergeState,Lucene.Net.Index.Fields)">
            <summary>
            Called during merging to merge all <seealso cref="T:Lucene.Net.Index.Fields"/> from
             sub-readers.  this must recurse to merge all postings
             (terms, docs, positions, etc.).  A {@link
             PostingsFormat} can override this default
             implementation to do its own merging.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.FieldsProducer">
             <summary>
             Abstract API that produces terms, doc, freq, prox, offset and
              payloads postings.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FieldsProducer.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.FieldsProducer.CheckIntegrity" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.FilterCodec" -->
        <member name="F:Lucene.Net.Codecs.FilterCodec.m_delegate">
            <summary>
            The codec to filter. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.FilterCodec.#ctor(Lucene.Net.Codecs.Codec)">
            <summary>
            Sole constructor. When subclassing this codec,
            create a no-arg ctor and pass the delegate codec
            and a unique name to this ctor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.LiveDocsFormat">
            <summary>
            Format for live/deleted documents
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.NewLiveDocs(System.Int32)">
            <summary>
            Creates a new MutableBits, with all bits set, for the specified size. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.NewLiveDocs(Lucene.Net.Util.IBits)">
            <summary>
            Creates a new mutablebits of the same bits set and size of existing. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.ReadLiveDocs(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Read live docs bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.WriteLiveDocs(Lucene.Net.Util.IMutableBits,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentCommitInfo,System.Int32,Lucene.Net.Store.IOContext)">
            <summary>
            Persist live docs bits.  Use {@link
             SegmentCommitInfo#getNextDelGen} to determine the
             generation of the deletes file you should write to.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.LiveDocsFormat.Files(Lucene.Net.Index.SegmentCommitInfo,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Records all files in use by this <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/> into the files argument. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum">
             <summary>
             Exposes flex API, merged from flex API of sub-segments,
             remapping docIDs (this is used for segment merging).
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.MergeState">
            <summary>
            Sets the <seealso cref="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.MergeState"/>, which is used to re-map
             document IDs.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsAndPositionsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MappingMultiDocsEnum">
             <summary>
             Exposes flex API, merged from flex API of sub-segments,
             remapping docIDs (this is used for segment merging).
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MappingMultiDocsEnum.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsEnum.MergeState">
            <summary>
            Sets the <seealso cref="P:Lucene.Net.Codecs.MappingMultiDocsEnum.MergeState"/>, which is used to re-map
             document IDs.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Codecs.MappingMultiDocsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Codecs.MappingMultiDocsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListReader">
             <summary>
             this abstract class reads skip lists with multiple levels.
            
             See <seealso cref="T:Lucene.Net.Codecs.MultiLevelSkipListWriter"/> for the information about the encoding
             of the multi level skip lists.
            
             Subclasses must implement the abstract method <seealso cref="!:#readSkipData(int, IndexInput)"/>
             which defines the actual format of the skip data.
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.m_maxNumberOfSkipLevels">
            <summary>
            the maximum number of skip levels possible for this index </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipStream">
            <summary>
            skipStream for each level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipPointer">
            <summary>
            The start pointer of each skip level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.skipInterval">
            <summary>
             skipInterval of each level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.numSkipped">
            <summary>
            Number of docs skipped per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.m_skipDoc">
            <summary>
            Doc id of current skip entry per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.lastDoc">
            <summary>
            Doc id of last read skip entry with docId &lt;= target. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.childPointer">
            <summary>
            Child pointer of current skip entry per level. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListReader.lastChildPointer">
            <summary>
            childPointer of last read skip entry with docId &lt;=
             target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListReader}. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListReader}, where
             {@code skipInterval} and {@code skipMultiplier} are
             the same.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.MultiLevelSkipListReader.Doc">
            <summary>
            Returns the id of the doc to which the last call of <seealso cref="!:#skipTo(int)"/>
             has skipped.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipTo(System.Int32)">
            <summary>
            Skips entries to the first beyond the current whose document number is
             greater than or equal to <i>target</i>. Returns the current doc count.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SeekChild(System.Int32)">
            <summary>
            Seeks the skip entry on the given level </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.Init(System.Int64,System.Int32)">
            <summary>
            Initializes the reader, for reuse on a new term. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.LoadSkipLevels">
            <summary>
            Loads the skip levels </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.ReadSkipData(System.Int32,Lucene.Net.Store.IndexInput)">
            <summary>
            Subclasses must implement the actual skip data encoding in this method.
            </summary>
            <param name="level"> the level skip data shall be read from </param>
            <param name="skipStream"> the skip stream to read from </param>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListReader.SetLastSkipData(System.Int32)">
            <summary>
            Copies the values of the last read skip entry on this <paramref name="level"/> </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListReader.SkipBuffer">
            <summary>
            used to buffer the top skip levels </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.MultiLevelSkipListWriter">
             <summary>
             this abstract class writes skip lists with multiple levels.
            
             <pre>
            
             Example for skipInterval = 3:
                                                                 c            (skip level 2)
                             c                 c                 c            (skip level 1)
                 x     x     x     x     x     x     x     x     x     x      (skip level 0)
             d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d d  (posting list)
                 3     6     9     12    15    18    21    24    27    30     (df)
            
             d - document
             x - skip data
             c - skip data with child pointer
            
             Skip level i contains every skipInterval-th entry from skip level i-1.
             Therefore the number of entries on level i is: floor(df / ((skipInterval ^ (i + 1))).
            
             Each skip entry on a level i>0 contains a pointer to the corresponding skip entry in list i-1.
             this guarantees a logarithmic amount of skips to find the target document.
            
             While this class takes care of writing the different skip levels,
             subclasses must define the actual format of the skip data.
             </pre>
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.m_numberOfSkipLevels">
            <summary>
            number of levels in this skip list </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipInterval">
            <summary>
            the skip interval in the list with level = 0 </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipMultiplier">
            <summary>
            skipInterval used for level &gt; 0 </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.MultiLevelSkipListWriter.skipBuffer">
            <summary>
            for every skip level a different buffer is used </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListWriter}. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a {@code MultiLevelSkipListWriter}, where
             {@code skipInterval} and {@code skipMultiplier} are
             the same.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.Init">
            <summary>
            Allocates internal skip buffers. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.ResetSkip">
            <summary>
            Creates new buffers or empties the existing ones </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.WriteSkipData(System.Int32,Lucene.Net.Store.IndexOutput)">
            <summary>
            Subclasses must implement the actual skip data encoding in this method.
            </summary>
            <param name="level"> the level skip data shall be writing for </param>
            <param name="skipBuffer"> the skip buffer to write to </param>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.BufferSkip(System.Int32)">
            <summary>
            Writes the current skip data to the buffers. The current document frequency determines
            the max level is skip data is to be written to.
            </summary>
            <param name="df"> the current document frequency </param>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.MultiLevelSkipListWriter.WriteSkip(Lucene.Net.Store.IndexOutput)">
            <summary>
            Writes the buffered skip lists to the given output.
            </summary>
            <param name="output"> the IndexOutput the skip lists shall be written to </param>
            <returns> the pointer the skip list starts </returns>
        </member>
        <member name="T:Lucene.Net.Codecs.NormsFormat">
            <summary>
            Encodes/decodes per-document score normalization values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.NormsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.NormsFormat.NormsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.DocValuesConsumer"/> to write norms to the
             index.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.NormsFormat.NormsProducer(Lucene.Net.Index.SegmentReadState)" -->
        <member name="T:Lucene.Net.Codecs.PostingsBaseFormat">
             <summary>
             Provides a <seealso cref="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> and {@link
             PostingsWriterBase}.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.PostingsBaseFormat.Name">
            <summary>
            Unique name that's used to retrieve this codec when
             reading the index
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.#ctor(System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Creates the <seealso cref="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> for this
             format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsWriterBase(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Creates the <seealso cref="M:Lucene.Net.Codecs.PostingsBaseFormat.PostingsWriterBase(Lucene.Net.Index.SegmentWriteState)"/> for this
             format.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.PostingsConsumer" -->
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.StartDoc(System.Int32,System.Int32)">
            <summary>
            Adds a new doc in this term.
            <code>freq</code> will be -1 when term frequencies are omitted
            for the field.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsConsumer.AddPosition(System.Int32,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsConsumer.FinishDoc" -->
        <member name="M:Lucene.Net.Codecs.PostingsConsumer.Merge(Lucene.Net.Index.MergeState,Lucene.Net.Index.IndexOptions,Lucene.Net.Index.DocsEnum,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Default merge impl: append documents, mapping around
             deletes
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsFormat">
            <summary>
            Encodes/decodes terms, postings, and proximity data.
            <para/>
            Note, when extending this class, the name (<see cref="P:Lucene.Net.Codecs.PostingsFormat.Name"/>) may
            written into the index in certain configurations. In order for the segment
            to be read, the name must resolve to your implementation via <see cref="M:Lucene.Net.Codecs.PostingsFormat.ForName(System.String)"/>.
            this method uses <see cref="M:Lucene.Net.Codecs.IPostingsFormatFactory.GetPostingsFormat(System.String)"/> to resolve format names.
            <para/>
            If you implement your own format:
            <list type="number">
                <item>Subclass this class.</item>
                <item>Subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>, override <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize"/>,
                    and add the line <c>base.ScanForPostingsFormats(typeof(YourPostingsFormat).GetTypeInfo().Assembly)</c>. 
                    If you have any format classes in your assembly 
                    that are not meant for reading, you can add the <see cref="T:Lucene.Net.Codecs.ExcludePostingsFormatFromScanAttribute"/> 
                    to them so they are ignored by the scan.</item>
                <item>Set the new <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> by calling <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/> 
                    at application startup.</item>
            </list>
            If your format has dependencies, you may also override <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.Type)"/> to inject 
            them via pure DI or a DI container. See <a href="http://blog.ploeh.dk/2014/05/19/di-friendly-framework/">DI-Friendly Framework</a>
            to understand the approach used.
            <para/>
            <b>PostingsFormat Names</b>
            <para/>
            Unlike the Java version, format names are by default convention-based on the class name. 
            If you name your custom format class "MyCustomPostingsFormat", the codec name will the same name 
            without the "PostingsFormat" suffix: "MyCustom".
            <para/>
            You can override this default behavior by using the <see cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/> to
            name the format differently than this convention. Format names must be all ASCII alphanumeric, 
            and less than 128 characters in length.
            <para/>
            @lucene.experimental
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>
            <seealso cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/>
        </member>
        <member name="F:Lucene.Net.Codecs.PostingsFormat.EMPTY">
            <summary>
            Zero-length <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> array. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PostingsFormat.name">
            <summary>
            Unique name that's used to retrieve this format when
            reading the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)">
            <summary>
            Sets the <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> instance used to instantiate
            <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> subclasses.
            </summary>
            <param name="postingsFormatFactory">The new <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="postingsFormatFactory"/> parameter is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.GetPostingsFormatFactory">
            <summary>
            Gets the associated <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> factory.
            </summary>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> factory.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.#ctor">
            <summary>
            Creates a new postings format.
            <para/>
            The provided name will be written into the index segment in some configurations
            (such as when using <see cref="T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat"/>): in such configurations,
            for the segment to be read this class should be registered by subclassing <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> and
            calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/> in the class constructor. 
            The new <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> can be registered by calling <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/> at application startup.</summary>
        </member>
        <member name="P:Lucene.Net.Codecs.PostingsFormat.Name">
            <summary>
            Returns this posting format's name </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.FieldsConsumer(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Writes a new segment </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.FieldsProducer(Lucene.Net.Index.SegmentReadState)">
            <summary>
            Reads a segment.  NOTE: by the time this call
            returns, it must hold open any files it will need to
            use; else, those files may be deleted.
            Additionally, required files may be deleted during the execution of
            this call before there is a chance to open them. Under these
            circumstances an IOException should be thrown by the implementation.
            IOExceptions are expected and will automatically cause a retry of the
            segment opening logic with the newly revised segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.ForName(System.String)">
            <summary>
            looks up a format by name </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsFormat.AvailablePostingsFormats">
            <summary>
            returns a list of all available format names </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsReaderBase">
            <summary>
            The core terms dictionaries (BlockTermsReader,
             BlockTreeTermsReader) interact with a single instance
             of this class to manage creation of <seealso cref="T:Lucene.Net.Index.DocsEnum"/> and
             <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> instances.  It provides an
             IndexInput (termsIn) where this class may read any
             previously stored data that it had written in its
             corresponding <seealso cref="T:Lucene.Net.Codecs.PostingsWriterBase"/> at indexing
             time.
             @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Init(Lucene.Net.Store.IndexInput)">
            <summary>
            Performs any initialization, such as reading and
             verifying the header from the provided terms
             dictionary <seealso cref="T:Lucene.Net.Store.IndexInput"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.NewTermState">
            <summary>
            Return a newly created empty TermState </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsReaderBase.DecodeTerm(System.Int64[],Lucene.Net.Store.DataInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,System.Boolean)" -->
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.Docs(Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)">
            <summary>
            Must fully consume state, since after this call that
             TermState may be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.DocsAndPositions(Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)">
            <summary>
            Must fully consume state, since after this call that
             TermState may be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsReaderBase.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PostingsReaderBase.CheckIntegrity" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.PostingsWriterBase" -->
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.Init(Lucene.Net.Store.IndexOutput)">
            <summary>
            Called once after startup, before any terms have been
             added.  Implementations typically write a header to
             the provided {@code termsOut}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.NewTermState">
            <summary>
            Return a newly created empty TermState </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.StartTerm">
            <summary>
            Start a new term.  Note that a matching call to {@link
             #finishTerm(BlockTermState)} is done, only if the term has at least one
             document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.FinishTerm(Lucene.Net.Codecs.BlockTermState)">
            <summary>
            Finishes the current term.  The provided {@link
             BlockTermState} contains the term's summary statistics,
             and will holds metadata from PBF when returned
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.EncodeTerm(System.Int64[],Lucene.Net.Store.DataOutput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.BlockTermState,System.Boolean)">
             <summary>
             Encode metadata as long[] and byte[]. {@code absolute} controls whether
             current term is delta encoded according to latest term.
             Usually elements in {@code longs} are file pointers, so each one always
             increases when a new term is consumed. {@code out} is used to write generic
             bytes, which are not monotonic.
            
             NOTE: sometimes long[] might contain "don't care" values that are unused, e.g.
             the pointer to postings list may not be defined for some terms but is defined
             for others, if it is designed to inline  some postings data in term dictionary.
             In this case, the postings writer should always use the last value, so that each
             element in metadata long[] remains monotonic.
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PostingsWriterBase.SetField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Sets the current field for writing, and returns the
            fixed length of long[] metadata (which is fixed per
            field), called when the writing switches to another field.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.SegmentInfoFormat" -->
        <member name="M:Lucene.Net.Codecs.SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoReader">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoReader"/> for reading
             <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoWriter">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Codecs.SegmentInfoFormat.SegmentInfoWriter"/> for writing
             <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> instances.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.SegmentInfoReader">
            <summary>
            Specifies an API for classes that can read <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> information.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoReader.Read(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Read <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> data from a directory. </summary>
            <param name="directory"> directory to read from </param>
            <param name="segmentName"> name of the segment to read </param>
            <returns> infos instance to be populated with data </returns>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.SegmentInfoWriter">
            <summary>
            Specifies an API for classes that can write out <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> data.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Write <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> data. </summary>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.StoredFieldsFormat">
            <summary>
            Controls the format of stored fields
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.FieldsReader(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.StoredFieldsReader"/> to load stored
             fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsFormat.FieldsWriter(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.StoredFieldsWriter"/> to write stored
             fields.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.StoredFieldsReader">
            <summary>
            Codec API for reading stored fields.
            
            You need to implement visitDocument(int, StoredFieldVisitor) to
            read the stored fields for a document, implement clone( (creating
            clones of any IndexInputs used, etc), and close() 
            
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.VisitDocument(System.Int32,Lucene.Net.Index.StoredFieldVisitor)">
            <summary>
            Visit the stored fields for document <code>n</code> </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsReader.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.StoredFieldsWriter" -->
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.StartDocument(System.Int32)">
            <summary>
            Called before writing the stored fields of the document.
             <seealso cref="!:#writeField(FieldInfo, IndexableField)"/> will be called
             <code>numStoredFields</code> times. Note that this is
             called even if the document has no stored fields, in
             this case <code>numStoredFields</code> will be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.FinishDocument">
            <summary>
            Called when a document and all its fields have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.WriteField(Lucene.Net.Index.FieldInfo,Lucene.Net.Index.IIndexableField)">
            <summary>
            Writes a single stored field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Abort">
            <summary>
            Aborts writing entirely, implementation should remove
             any partially-written files, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)">
            <summary>
            Called before <seealso cref="!:#close()"/>, passing in the number
             of documents that were written. Note that this is
             intentionally redundant (equivalent to the number of
             calls to <seealso cref="!:#startDocument(int)"/>, but a Codec should
             check that this is the case to detect the JRE bug described
             in LUCENE-1282.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.Merge(Lucene.Net.Index.MergeState)">
            <summary>
            Merges in the stored fields from the readers in
             <code>mergeState</code>. The default implementation skips
             over deleted documents, and uses <seealso cref="!:#startDocument(int)"/>,
             <seealso cref="!:#writeField(FieldInfo, IndexableField)"/>, and <seealso cref="!:#finish(FieldInfos, int)"/>,
             returning the number of documents that were written.
             Implementations can override this method for more sophisticated
             merging (bulk-byte copying, etc).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.StoredFieldsWriter.AddDocument``1(System.Collections.Generic.IEnumerable{``0},Lucene.Net.Index.FieldInfos)">
            <summary>
            sugar method for startDocument() + writeField() for every stored field in the document </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.TermsConsumer" -->
        <member name="M:Lucene.Net.Codecs.TermsConsumer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.StartTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            Starts a new term in this field; this may be called
             with no corresponding call to finish if the term had
             no docs.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.FinishTerm(Lucene.Net.Util.BytesRef,Lucene.Net.Codecs.TermStats)">
            <summary>
            Finishes the current term; numDocs must be > 0.
             <code>stats.totalTermFreq</code> will be -1 when term
             frequencies are omitted for the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.Finish(System.Int64,System.Int64,System.Int32)">
            <summary>
            Called when we are done adding terms to this field.
             <code>sumTotalTermFreq</code> will be -1 when term
             frequencies are omitted for the field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermsConsumer.Comparer">
            <summary>
            Return the BytesRef Comparer used to sort terms
             before feeding to this API.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermsConsumer.Merge(Lucene.Net.Index.MergeState,Lucene.Net.Index.IndexOptions,Lucene.Net.Index.TermsEnum)">
            <summary>
            Default merge impl </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.TermStats" -->
        <member name="P:Lucene.Net.Codecs.TermStats.DocFreq">
            <summary>
            How many documents have at least one occurrence of
             this term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermStats.TotalTermFreq">
            <summary>
            Total number of times this term occurs across all
             documents in the field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermStats.#ctor(System.Int32,System.Int64)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermVectorsFormat">
            <summary>
            Controls the format of term vectors
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.VectorsReader(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.TermVectorsReader"/> to read term
             vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsFormat.VectorsWriter(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Codecs.TermVectorsWriter"/> to write term
             vectors.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.TermVectorsReader">
             <summary>
             Codec API for reading term vectors:
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Get(System.Int32)">
            <summary>
            Returns term vectors for this document, or null if
             term vectors were not indexed. If offsets are
             available they are in an <seealso cref="T:Lucene.Net.Analysis.TokenAttributes.OffsetAttribute"/>
             available from the <seealso cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.TermVectorsReader.CheckIntegrity" -->
        <member name="M:Lucene.Net.Codecs.TermVectorsReader.Clone">
            <summary>
            Create a clone that one caller at a time may use to
             read term vectors.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.TermVectorsWriter" -->
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartDocument(System.Int32)">
            <summary>
            Called before writing the term vectors of the document.
             <seealso cref="!:#startField(FieldInfo, int, boolean, boolean, boolean)"/> will
             be called <code>numVectorFields</code> times. Note that if term
             vectors are enabled, this is called even if the document
             has no vector fields, in this case <code>numVectorFields</code>
             will be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishDocument">
            <summary>
            Called after a doc and all its fields have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartField(Lucene.Net.Index.FieldInfo,System.Int32,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Called before writing the terms of the field.
             <seealso cref="!:#startTerm(BytesRef, int)"/> will be called <code>numTerms</code> times.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishField">
            <summary>
            Called after a field and all its terms have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.StartTerm(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Adds a term and its term frequency <code>freq</code>.
            If this field has positions and/or offsets enabled, then
            <seealso cref="!:#addPosition(int, int, int, BytesRef)"/> will be called
            <code>freq</code> times respectively.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.FinishTerm">
            <summary>
            Called after a term and all its positions have been added. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.AddPosition(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a term position and offsets </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Abort">
            <summary>
            Aborts writing entirely, implementation should remove
             any partially-written files, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Finish(Lucene.Net.Index.FieldInfos,System.Int32)">
            <summary>
            Called before <seealso cref="!:#close()"/>, passing in the number
             of documents that were written. Note that this is
             intentionally redundant (equivalent to the number of
             calls to <seealso cref="!:#startDocument(int)"/>, but a Codec should
             check that this is the case to detect the JRE bug described
             in LUCENE-1282.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.TermVectorsWriter.AddProx(System.Int32,Lucene.Net.Store.DataInput,Lucene.Net.Store.DataInput)" -->
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.Merge(Lucene.Net.Index.MergeState)">
            <summary>
            Merges in the term vectors from the readers in
             <code>mergeState</code>. The default implementation skips
             over deleted documents, and uses <seealso cref="!:#startDocument(int)"/>,
             <seealso cref="!:#startField(FieldInfo, int, boolean, boolean, boolean)"/>,
             <seealso cref="!:#startTerm(BytesRef, int)"/>, <seealso cref="!:#addPosition(int, int, int, BytesRef)"/>,
             and <seealso cref="!:#finish(FieldInfos, int)"/>,
             returning the number of documents that were written.
             Implementations can override this method for more sophisticated
             merging (bulk-byte copying, etc).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.TermVectorsWriter.AddAllDocVectors(Lucene.Net.Index.Fields,Lucene.Net.Index.MergeState)">
            <summary>
            Safe (but, slowish) default method to write every
             vector field in the document.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.TermVectorsWriter.Comparer">
            <summary>
            Return the BytesRef Comparer used to sort terms
             before feeding to this API.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.#ctor(System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat.#ctor(System.String,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)" -->
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexReader">
            <summary>
            Random-access reader for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter" -->
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.StoredFieldsReader"/> impl for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this FieldsReader is closed </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Close the underlying <seealso cref="T:Lucene.Net.Store.IndexInput"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.ChunkSize">
            <summary>
            Return the decompressed size of the chunk
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.Next(System.Int32)">
            <summary>
            Go to the chunk containing the provided doc ID.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.Decompress">
            <summary>
            Decompress the chunk.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.CopyCompressedData(Lucene.Net.Store.DataOutput)">
            <summary>
            Copy compressed data.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsReader.ChunkIterator.CheckIntegrity">
            <summary>
            Check integrity of the data. The iterator is not usable after this method has been called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.StoredFieldsWriter"/> impl for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.NUMERIC_INT32">
            <summary>
            NOTE: This was NUMERIC_INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.NUMERIC_SINGLE">
            <summary>
            NOTE: This was NUMERIC_FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.NUMERIC_INT64">
            <summary>
            NOTE:This was NUMERIC_LONG in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsWriter.SaveInt32s(System.Int32[],System.Int32,Lucene.Net.Store.DataOutput)">
            <summary>
            NOTE: This was saveInts() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat">
            <summary>
            A <seealso cref="T:Lucene.Net.Codecs.TermVectorsFormat"/> that compresses chunks of documents together in
            order to improve the compression ratio.
            @lucene.experimental
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat.#ctor(System.String,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)" -->
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.TermVectorsReader"/> for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.PackedInt32sVersion">
            <summary>
            NOTE: This was getPackedIntsVersion() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this TermVectorsReader is closed </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter">
            <summary>
            <seealso cref="T:Lucene.Net.Codecs.TermVectorsWriter"/> for <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsFormat"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.DocData">
            <summary>
            a pending doc </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.FieldData">
            <summary>
            a pending field </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,System.String,Lucene.Net.Store.IOContext,System.String,Lucene.Net.Codecs.Compressing.CompressionMode,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressingTermVectorsWriter.FlushFieldNums">
            <summary>
            Returns a sorted array containing unique field numbers </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.CompressionMode">
            <summary>
            A compression mode. Tells how much effort should be spent on compression and
            decompression of stored fields.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.FAST">
            <summary>
            A compression mode that trades compression ratio for speed. Although the
            compression ratio might remain high, compression and decompression are
            very fast. Use this mode with indices that have a high update rate but
            should be able to load documents from disk quickly.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.HIGH_COMPRESSION">
            <summary>
            A compression mode that trades speed for compression ratio. Although
            compression and decompression might be slow, this compression mode should
            provide a good compression ratio. this mode might be interesting if/when
            your index size is much bigger than your OS cache.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Compressing.CompressionMode.FAST_DECOMPRESSION">
            <summary>
            this compression mode is similar to <seealso cref="!:#FAST"/> but it spends more time
            compressing in order to improve the compression ratio. this compression
            mode is best used with indices that have a low update rate but should be
            able to load documents from disk quickly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.NewCompressor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Codecs.Compressing.Compressor"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.CompressionMode.NewDecompressor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Codecs.Compressing.Decompressor"/> instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.Compressor">
            <summary>
            A data compressor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Compressor.#ctor">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Compressor.Compress(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput)">
            <summary>
            Compress bytes into <code>out</code>. It it the responsibility of the
            compressor to add all necessary information so that a <seealso cref="T:Lucene.Net.Codecs.Compressing.Decompressor"/>
            will know when to stop decompressing bytes from the stream.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.Decompressor">
            <summary>
            A decompressor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Decompressor.#ctor">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.Decompressor.Decompress(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress bytes that were stored between offsets <code>offset</code> and
            <code>offset+length</code> in the original stream from the compressed
            stream <code>in</code> to <code>bytes</code>. After returning, the length
            of <code>bytes</code> (<code>bytes.length</code>) must be equal to
            <code>length</code>. Implementations of this method are free to resize
            <code>bytes</code> depending on their needs.
            </summary>
            <param name="in"> the input that stores the compressed stream </param>
            <param name="originalLength"> the length of the original data (before compression) </param>
            <param name="offset"> bytes before this offset do not need to be decompressed </param>
            <param name="length"> bytes after <code>offset+length</code> do not need to be decompressed </param>
            <param name="bytes"> a <seealso cref="T:Lucene.Net.Util.BytesRef"/> where to store the decompressed data </param>
        </member>
        <member name="T:Lucene.Net.Codecs.Compressing.LZ4">
             <summary>
             LZ4 compression and decompression routines.
            
             http://code.google.com/p/lz4/
             http://fastcompression.blogspot.fr/p/lz4.html
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.ReadInt32(System.Byte[],System.Int32)">
            <summary>
            NOTE: This was readInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.ReadInt32Equals(System.Byte[],System.Int32,System.Int32)">
            <summary>
            NOTE: This was readIntEquals() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.Decompress(Lucene.Net.Store.DataInput,System.Int32,System.Byte[],System.Int32)">
            <summary>
            Decompress at least <code>decompressedLen</code> bytes into
            <code>dest[dOff:]</code>. Please note that <code>dest</code> must be large
            enough to be able to hold <b>all</b> decompressed data (meaning that you
            need to know the total decompressed length).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.Compress(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput,Lucene.Net.Codecs.Compressing.LZ4.HashTable)">
            <summary>
            Compress <code>bytes[off:off+len]</code> into <code>out</code> using
            at most 16KB of memory. <code>ht</code> shouldn't be shared across threads
            but can safely be reused.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Compressing.LZ4.CompressHC(System.Byte[],System.Int32,System.Int32,Lucene.Net.Store.DataOutput,Lucene.Net.Codecs.Compressing.LZ4.HCHashTable)">
            <summary>
            Compress <code>bytes[off:off+len]</code> into <code>out</code>. Compared to
            <seealso cref="!:LZ4#compress(byte[], int, int, DataOutput, HashTable)"/>, this method
            is slower and uses more memory (~ 256KB per thread) but should provide
            better compression ratios (especially on large inputs) because it chooses
            the best match among up to 256 candidates and then performs trade-offs to
            fix overlapping matches. <code>ht</code> shouldn't be shared across threads
            but can safely be reused.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec">
            <summary>
            Supports the Lucene 3.x index format (readonly) </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec.COMPOUND_FILE_STORE_EXTENSION">
            <summary>
            Extension of compound file for doc store files </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xCodec.GetDocStoreFiles(Lucene.Net.Index.SegmentInfo)">
            <summary>
            Returns file names for shared doc stores, if any, else
            null.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosFormat">
            <summary>
            Lucene3x ReadOnly FieldInfosFromat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosReader">
            <summary>
            @lucene.experimental </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xFieldInfosReader.FIELD_INFOS_EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xFields">
            <summary>
            Exposes flex API on a pre-flex index, as a codec.
            @lucene.experimental </summary>
            @deprecated (4.0)
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsFormat">
            <summary>
            Lucene3x ReadOnly NormsFormat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer">
            <summary>
            Reads Lucene 3.x norms format and exposes it via DocValues API
            @lucene.experimental </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.NORMS_HEADER">
            <summary>
            norms header placeholder </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.NORMS_EXTENSION">
            <summary>
            Extension of norms file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xNormsProducer.SEPARATE_NORMS_EXTENSION">
            <summary>
            Extension of separate norms file </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat">
            <summary>
            Codec that reads the pre-flex-indexing postings
             format.  It does not provide a writer because newly
             written segments should use the Codec configured on IndexWriter.
            </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.TERMS_EXTENSION">
            <summary>
            Extension of terms file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.TERMS_INDEX_EXTENSION">
            <summary>
            Extension of terms index file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.FREQ_EXTENSION">
            <summary>
            Extension of freq postings file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xPostingsFormat.PROX_EXTENSION">
            <summary>
            Extension of prox postings file </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat">
            <summary>
            Lucene3x ReadOnly SegmentInfoFormat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_DIAGNOSTICS">
            <summary>
            this format adds optional per-segment String
             diagnostics storage, and switches userData to Map
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_HAS_VECTORS">
            <summary>
            Each segment records whether it has term vectors </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.FORMAT_3_1">
            <summary>
            Each segment records the Lucene version that created it. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.UPGRADED_SI_EXTENSION">
            <summary>
            Extension used for saving each SegmentInfo, once a 3.x
             index is first committed to with 4.0.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreOffset(Lucene.Net.Index.SegmentInfo)" -->
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreSegment(Lucene.Net.Index.SegmentInfo)">
            <returns> name used to derive fields/vectors file we share with other segments </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoFormat.GetDocStoreIsCompoundFile(Lucene.Net.Index.SegmentInfo)">
            <returns> whether doc store files are stored in compound file (*.cfx) </returns>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoReader">
            <summary>
            Lucene 3x implementation of <seealso cref="T:Lucene.Net.Codecs.SegmentInfoReader"/>.
            @lucene.experimental </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xSegmentInfoReader.ReadLegacySegmentInfo(Lucene.Net.Store.Directory,System.Int32,Lucene.Net.Store.IndexInput)">
            <summary>
            reads from legacy 3.x segments_N </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader">
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.FreqPointer">
            <summary>
            Returns the freq pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.ProxPointer">
            <summary>
            Returns the prox pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xSkipListReader.PayloadLength">
            <summary>
            Returns the payload length of the payload stored just before
            the doc to which the last call of <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/>
            has skipped.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsFormat">
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader">
            <summary>
            Class responsible for access to stored document fields.
            <p/>
            It uses &lt;segment&gt;.fdt and &lt;segment&gt;.fdx; files.
            </summary>
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.FIELDS_EXTENSION">
            <summary>
            Extension of stored fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.FIELDS_INDEX_EXTENSION">
            <summary>
            Extension of stored fields index file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.Clone">
            <summary>
            Returns a cloned FieldsReader that shares open
             IndexInputs with the original one.  It is the caller's
             job not to close the original FieldsReader until all
             clones are called (eg, currently SegmentReader manages
             this logic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.CheckCodeVersion(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Verifies that the code version which wrote the segment is supported. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this FieldsReader is closed </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.Lucene3xStoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Closes the underlying <seealso cref="T:Lucene.Net.Store.IndexInput"/> streams.
            this means that the Fields values will not be accessible.
            </summary>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsFormat">
            <summary>
            Lucene3x ReadOnly TermVectorsFormat implementation </summary>
            @deprecated (4.0) this is only used to read indexes created
            before 4.0.
            @lucene.experimental
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader">
            @deprecated Only for reading existing 3.x indexes
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_FIELDS_EXTENSION">
            <summary>
            Extension of vectors fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_DOCUMENTS_EXTENSION">
            <summary>
            Extension of vectors documents file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.VECTORS_INDEX_EXTENSION">
            <summary>
            Extension of vectors index file </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.Lucene3xTermVectorsReader.Count">
            <summary>The number of documents in the reader. NOTE: This was size() in Lucene.</summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs">
            @deprecated (4.0)
             @lucene.experimental
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.Read(System.Int32[],System.Int32[])">
            <summary>
            Optimized implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.SkipProx(System.Int64,System.Int32)">
            <summary>
            Overridden by SegmentTermPositions to skip in prox stream. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermDocs.SkipTo(System.Int32)">
            <summary>
            Optimized implementation. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum">
            @deprecated (4.0) No longer used with flex indexing, except for
            reading old segments
            @lucene.experimental
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Next">
            <summary>
            Increments the enumeration to the next element.  True if one exists. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Term">
            <summary>
            Returns the current Term in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Prev">
            <summary>
            Returns the previous Term enumerated. Initially null. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.TermInfo">
            <summary>
            Returns the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.TermInfo(Lucene.Net.Codecs.Lucene3x.TermInfo)">
            <summary>
            Sets the argument to the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.DocFreq">
            <summary>
            Returns the docFreq from the current TermInfo in the enumeration.
            Initially invalid, valid after next() called for the first time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermEnum.Dispose">
            <summary>
            Closes the enumeration to further activity, freeing resources. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.SegmentTermPositions">
            <summary>
            @lucene.experimental </summary>
            @deprecated (4.0)
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.SegmentTermPositions.SkipProx(System.Int64,System.Int32)">
            <summary>
            Called by super.skipTo(). </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermBuffer">
            <summary>
            @lucene.experimental </summary>
            @deprecated (4.0)
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfo">
            <summary>
            A TermInfo is the record of information stored for a
            term </summary>
            @deprecated (4.0) this class is no longer used in flexible
            indexing.
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.TermInfo.DocFreq">
            <summary>
            The number of documents which contain the term. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene3x.TermInfosReader" -->
        <member name="T:Lucene.Net.Codecs.Lucene3x.TermInfosReader.ThreadResources">
            <summary>
            Per-thread resources managed by ThreadLocal
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Count">
            <summary>
            Returns the number of term/value pairs in the set. 
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Get(Lucene.Net.Index.Term)">
            <summary>
            Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Get(Lucene.Net.Index.Term,System.Boolean)">
            <summary>
            Returns the TermInfo for a Term in the set, or null. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.GetPosition(Lucene.Net.Index.Term)">
            <summary>
            Returns the position of a Term in the set or -1. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Terms">
            <summary>
            Returns an enumeration of all the Terms and TermInfos in the set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReader.Terms(Lucene.Net.Index.Term)">
            <summary>
            Returns an enumeration of terms starting at or after the named term. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex" -->
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.#ctor(Lucene.Net.Codecs.Lucene3x.SegmentTermEnum,System.Int32,System.Int64,System.Int32)">
            <summary>
            Loads the segment information at segment load time.
            </summary>
            <param name="indexEnum">
                     the term enum. </param>
            <param name="indexDivisor">
                     the index divisor. </param>
            <param name="tiiFileLength">
                     the size of the tii file, used to approximate the size of the
                     buffer. </param>
            <param name="totalIndexInterval">
                     the total index interval. </param>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.GetIndexOffset(Lucene.Net.Index.Term)">
            <summary>
            Binary search for the given term.
            </summary>
            <param name="term">
                     the term to locate. </param>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.GetTerm(System.Int32)">
            <summary>
            Gets the term at the given position.  For testing.
            </summary>
            <param name="termIndex">
                     the position to read the term from the index. </param>
            <returns> the term. </returns>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.Length">
            <summary>
            Returns the number of terms.
            </summary>
            <returns> int. </returns>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareTo(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            The compares the given term against the term in the index specified by the
            term index. ie It returns negative N when term is less than index term;
            </summary>
            <param name="term">
                     the given term. </param>
            <param name="termIndex">
                     the index of the of term to compare. </param>
            <returns> int. </returns>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareTo(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Util.PagedBytes.PagedBytesDataInput,Lucene.Net.Util.BytesRef)">
            <summary>
            Compare the fields of the terms first, and if not equals return from
            compare. If equal compare terms.
            </summary>
            <param name="term">
                     the term to compare. </param>
            <param name="termIndex">
                     the position of the term in the input to compare </param>
            <param name="input">
                     the input buffer. </param>
            <returns> int. </returns>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene3x.TermInfosReaderIndex.CompareField(Lucene.Net.Index.Term,System.Int32,Lucene.Net.Util.PagedBytes.PagedBytesDataInput)">
            <summary>
            Compares the fields before checking the text of the terms.
            </summary>
            <param name="term">
                     the given term. </param>
            <param name="termIndex">
                     the term that exists in the data block. </param>
            <param name="input">
                     the data block. </param>
            <returns> int. </returns>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.BitVector">
             <summary>
             Optimized implementation of a vector of bits.  this is more-or-less like
              java.util.BitSet, but also includes the following:
              <ul>
              <li>a count() method, which efficiently computes the number of one bits;</li>
              <li>optimized read from and write to disk;</li>
              <li>inlinable get() method;</li>
              <li>store and load, as bit set or d-gaps, depending on sparseness;</li>
              </ul>
            
              @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.#ctor(System.Int32)">
            <summary>
            Constructs a vector capable of holding <code>n</code> bits. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Set(System.Int32)">
            <summary>
            Sets the value of <code>bit</code> to one. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.GetAndSet(System.Int32)">
            <summary>
            Sets the value of <code>bit</code> to true, and
             returns true if bit was already set
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Clear(System.Int32)">
            <summary>
            Sets the value of <code>bit</code> to zero. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Get(System.Int32)">
            <summary>
            Returns <code>true</code> if <code>bit</code> is one and
             <code>false</code> if it is zero.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.BitVector.Length">
            <summary>
            Returns the number of bits in this vector.  this is also one greater than
            the number of the largest valid bit number.
            This is the equivalent of either size() or length() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Count">
            <summary>
            Returns the total number of one bits in this vector.  this is efficiently
             computed and cached, so that, if the vector is not changed, no
             recomputation is done for repeated calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.GetRecomputedCount">
            <summary>
            For testing </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.Write(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Writes this vector to the file <code>name</code> in Directory
             <code>d</code>, in a format that can be read by the constructor {@link
             #BitVector(Directory, String, IOContext)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.InvertAll">
            <summary>
            Invert all bits </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.SetAll">
            <summary>
            Set all bits </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.WriteBits(Lucene.Net.Store.IndexOutput)">
            <summary>
            Write as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.WriteClearedDgaps(Lucene.Net.Store.IndexOutput)">
            <summary>
            Write as a d-gaps list </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.BitVector.IsSparse">
            <summary>
            Indicates if the bit vector is sparse and should be saved as a d-gaps list, or dense, and should be saved as a bit set. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Constructs a bit vector from the file <code>name</code> in Directory
             <code>d</code>, as written by the <seealso cref="!:#write"/> method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadBits(Lucene.Net.Store.IndexInput)">
            <summary>
            Read as a bit set </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadSetDgaps(Lucene.Net.Store.IndexInput)">
            <summary>
            read as a d-gaps list </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.BitVector.ReadClearedDgaps(Lucene.Net.Store.IndexInput)">
            <summary>
            read as a d-gaps cleared bits list </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene40"
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat.MAX_BINARY_FIELD_LENGTH">
            <summary>
            Maximum length for each binary doc values field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader">
            <summary>
            Reads the 4.0 format of norms/docvalues
            @lucene.experimental </summary>
            @deprecated Only for reading old 4.0 and 4.1 segments
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadVarInt32sField(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadVarIntsField() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadInt16Field(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadShortField() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadInt32Field(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadIntField() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadInt64Field(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadLongField() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40DocValuesReader.LoadSingleField(Lucene.Net.Index.FieldInfo,Lucene.Net.Store.IndexInput)">
            <summary>
            NOTE: This was loadFloatField() in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosFormat.FIELD_INFOS_EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat.DELETES_EXTENSION">
            <summary>
            Extension of deletes </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40LiveDocsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40NormsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40NormsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat">
            <summary>
            Provides a <seealso cref="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> and {@link
            PostingsWriterBase}.
            </summary>
            @deprecated Only for reading old 4.0 segments
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsBaseFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.m_minBlockSize">
            <summary>
            minimum items (terms or sub-blocks) per block for BlockTree </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.m_maxBlockSize">
            <summary>
            maximum items (terms or sub-blocks) per block for BlockTree </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.#ctor">
            <summary>
            Creates {@code Lucene40PostingsFormat} with default
             settings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.#ctor(System.Int32,System.Int32)" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.FREQ_EXTENSION">
            <summary>
            Extension of freq postings file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40PostingsFormat.PROX_EXTENSION">
            <summary>
            Extension of prox postings file </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.SegmentDocsAndPositionsEnum.GetPayload">
            <summary>
            Returns the payload at this position, or null if no
             payload was indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40PostingsReader.SegmentFullPositionsEnum.GetPayload">
            <summary>
            Returns the payload at this position, or null if no
             payload was indexed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoFormat.SI_EXTENSION">
            <summary>
            File extension used to store <seealso cref="T:Lucene.Net.Index.SegmentInfo"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Save a single segment's info. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.Init(System.Int64,System.Int64,System.Int64,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Per-term initialization. </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.FreqPointer">
            <summary>
            Returns the freq pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.ProxPointer">
            <summary>
            Returns the prox pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.PayloadLength">
            <summary>
            Returns the payload length of the payload stored just before
            the doc to which the last call of <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/>
            has skipped.
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40SkipListReader.OffsetLength">
            <summary>
            Returns the offset length (endOffset-startOffset) of the position stored just before
            the doc to which the last call of <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/>
            has skipped.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Clone">
            <summary>
            Returns a cloned FieldsReader that shares open
             IndexInputs with the original one.  It is the caller's
             job not to close the original FieldsReader until all
             clones are called (eg, currently SegmentReader manages
             this logic).
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.#ctor(Lucene.Net.Index.FieldInfos,System.Int32,System.Int32,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput)">
            <summary>
            Used only by clone. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this FieldsReader is closed </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Dispose(System.Boolean)">
            <summary>
            Closes the underlying <seealso cref="T:Lucene.Net.Store.IndexInput"/> streams.
            this means that the Fields values will not be accessible.
            </summary>
            <exception cref="!:IOException"> If an I/O error occurs </exception>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.Count">
            <summary>
            Returns number of documents.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsReader.RawDocs(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Returns the length in bytes of each raw document in a
             contiguous range of length numDocs starting with
             startDocID.  Returns the IndexInput (the fieldStream),
             already seeked to the starting point for startDocID.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.FIELDS_EXTENSION">
            <summary>
            Extension of stored fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.FIELDS_INDEX_EXTENSION">
            <summary>
            Extension of stored fields index file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.AddRawDocuments(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32)">
            <summary>
            Bulk write a contiguous series of documents.  The
             lengths array is the length (in bytes) of each raw
             document.  The stream IndexInput is the
             fieldsStream from which we should bulk-copy all
             bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsWriter.MAX_RAW_MERGE_DOCS">
            <summary>
            Maximum number of contiguous documents to bulk-copy
               when merging stored fields
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat">
            <summary>
            Lucene 4.0 Term Vectors format.
            <p>Term Vector support is an optional on a field by field basis. It consists of
            3 files.</p>
            <ol>
            <li><a name="tvx" id="tvx"></a>
            <p>The Document Index or .tvx file.</p>
            <p>For each document, this stores the offset into the document data (.tvd) and
            field data (.tvf) files.</p>
            <p>DocumentIndex (.tvx) --&gt; Header,&lt;DocumentPosition,FieldPosition&gt;
            <sup>NumDocs</sup></p>
            <ul>
              <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
              <li>DocumentPosition --&gt; <seealso cref="!:DataOutput#writeLong UInt64"/> (offset in the .tvd file)</li>
              <li>FieldPosition --&gt; <seealso cref="!:DataOutput#writeLong UInt64"/> (offset in the .tvf file)</li>
            </ul>
            </li>
            <li><a name="tvd" id="tvd"></a>
            <p>The Document or .tvd file.</p>
            <p>this contains, for each document, the number of fields, a list of the fields
            with term vector info and finally a list of pointers to the field information
            in the .tvf (Term Vector Fields) file.</p>
            <p>The .tvd file is used to map out the fields that have term vectors stored
            and where the field information is in the .tvf file.</p>
            <p>Document (.tvd) --&gt; Header,&lt;NumFields, FieldNums,
            FieldPositions&gt; <sup>NumDocs</sup></p>
            <ul>
              <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
              <li>NumFields --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>FieldNums --&gt; &lt;FieldNumDelta&gt; <sup>NumFields</sup></li>
              <li>FieldNumDelta --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>FieldPositions --&gt; &lt;FieldPositionDelta&gt; <sup>NumFields-1</sup></li>
              <li>FieldPositionDelta --&gt; <seealso cref="!:DataOutput#writeVLong VLong"/></li>
            </ul>
            </li>
            <li><a name="tvf" id="tvf"></a>
            <p>The Field or .tvf file.</p>
            <p>this file contains, for each field that has a term vector stored, a list of
            the terms, their frequencies and, optionally, position, offset, and payload
            information.</p>
            <p>Field (.tvf) --&gt; Header,&lt;NumTerms, Flags, TermFreqs&gt;
            <sup>NumFields</sup></p>
            <ul>
              <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
              <li>NumTerms --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>Flags --&gt; <seealso cref="!:DataOutput#writeByte Byte"/></li>
              <li>TermFreqs --&gt; &lt;TermText, TermFreq, Positions?, PayloadData?, Offsets?&gt;
                  <sup>NumTerms</sup></li>
              <li>TermText --&gt; &lt;PrefixLength, Suffix&gt;</li>
              <li>PrefixLength --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>Suffix --&gt; <seealso cref="!:DataOutput#writeString String"/></li>
              <li>TermFreq --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>Positions --&gt; &lt;PositionDelta PayloadLength?&gt;<sup>TermFreq</sup></li>
              <li>PositionDelta --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>PayloadLength --&gt; <seealso cref="!:DataOutput#writeVInt VInt"/></li>
              <li>PayloadData --&gt; <seealso cref="!:DataOutput#writeByte Byte"/><sup>NumPayloadBytes</sup></li>
              <li>Offsets --&gt; &lt;<seealso cref="!:DataOutput#writeVInt VInt"/>, <seealso cref="!:DataOutput#writeVInt VInt"/>&gt;<sup>TermFreq</sup></li>
            </ul>
            <p>Notes:</p>
            <ul>
            <li>Flags byte stores whether this term vector has position, offset, payload.
            information stored.</li>
            <li>Term byte prefixes are shared. The PrefixLength is the number of initial
            bytes from the previous term which must be pre-pended to a term's suffix
            in order to form the term's bytes. Thus, if the previous term's text was "bone"
            and the term is "boy", the PrefixLength is two and the suffix is "y".</li>
            <li>PositionDelta is, if payloads are disabled for the term's field, the
            difference between the position of the current occurrence in the document and
            the previous occurrence (or zero, if this is the first occurrence in this
            document). If payloads are enabled for the term's field, then PositionDelta/2
            is the difference between the current and the previous position. If payloads
            are enabled and PositionDelta is odd, then PayloadLength is stored, indicating
            the length of the payload at the current term position.</li>
            <li>PayloadData is metadata associated with a term position. If
            PayloadLength is stored at the current position, then it indicates the length
            of this payload. If PayloadLength is not stored, then this payload has the same
            length as the payload at the previous position. PayloadData encodes the
            concatenated bytes for all of a terms occurrences.</li>
            <li>Offsets are stored as delta encoded VInts. The first VInt is the
            startOffset, the second is the endOffset.</li>
            </ul>
            </li>
            </ol>
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader" -->
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_FIELDS_EXTENSION">
            <summary>
            Extension of vectors fields file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_DOCUMENTS_EXTENSION">
            <summary>
            Extension of vectors documents file </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.VECTORS_INDEX_EXTENSION">
            <summary>
            Extension of vectors index file </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.#ctor(Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput,Lucene.Net.Store.IndexInput,System.Int32,System.Int32)">
            <summary>
            Used by clone. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.RawDocs(System.Int32[],System.Int32[],System.Int32,System.Int32)" -->
        <member name="P:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader.Count">
            <summary>
            The number of documents in the reader 
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter" -->
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.AddRawDocuments(Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsReader,System.Int32[],System.Int32[],System.Int32)">
            <summary>
            Do a bulk copy of numDocs documents from reader to our
            streams.  this is used to expedite merging, if the
            field numbers are congruent.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.MAX_RAW_MERGE_DOCS">
            <summary>
            Maximum number of contiguous documents to bulk-copy
               when merging term vectors
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene40.Lucene40TermVectorsWriter.Dispose(System.Boolean)">
            <summary>
            Close all streams. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.ForUtil">
            <summary>
            Encode all values in normal area with fixed bit width,
            which is determined by the max value in this block.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.ALL_VALUES_EQUAL">
            <summary>
            Special number of bits per value used whenever all values to encode are equal.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.MAX_ENCODED_SIZE">
            <summary>
            Upper limit of the number of bytes that might be required to stored
            <code>BLOCK_SIZE</code> encoded values.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.ForUtil.MAX_DATA_SIZE">
            <summary>
            Upper limit of the number of values that might be decoded in a single call to
            <seealso cref="!:#readBlock(IndexInput, byte[], int[])"/>. Although values after
            <code>BLOCK_SIZE</code> are garbage, it is necessary to allocate value buffers
            whose size is >= MAX_DATA_SIZE to avoid <seealso cref="!:ArrayIndexOutOfBoundsException"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.ComputeIterations(Lucene.Net.Util.Packed.PackedInt32s.IDecoder)">
            <summary>
            Compute the number of iterations required to decode <code>BLOCK_SIZE</code>
            values with the provided <seealso cref="!:Decoder"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.EncodedSize(Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32)">
            <summary>
            Compute the number of bytes required to encode a block of values that require
            <code>bitsPerValue</code> bits per value with format <code>format</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.#ctor(System.Single,Lucene.Net.Store.DataOutput)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Codecs.Lucene41.ForUtil"/> instance and save state into <code>out</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Restore a <seealso cref="T:Lucene.Net.Codecs.Lucene41.ForUtil"/> from a <seealso cref="T:Lucene.Net.Store.DataInput"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.WriteBlock(System.Int32[],System.Byte[],Lucene.Net.Store.IndexOutput)">
            <summary>
            Write a block of data (<code>For</code> format).
            </summary>
            <param name="data">     the data to write </param>
            <param name="encoded">  a buffer to use to encode data </param>
            <param name="out">      the destination output </param>
            <exception cref="!:IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.ReadBlock(Lucene.Net.Store.IndexInput,System.Byte[],System.Int32[])">
            <summary>
            Read the next block of data (<code>For</code> format).
            </summary>
            <param name="in">        the input to use to read data </param>
            <param name="encoded">   a buffer that can be used to store encoded data </param>
            <param name="decoded">   where to write decoded data </param>
            <exception cref="!:IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.SkipBlock(Lucene.Net.Store.IndexInput)">
            <summary>
            Skip the next block of data.
            </summary>
            <param name="in">      the input where to read data </param>
            <exception cref="!:IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.ForUtil.BitsRequired(System.Int32[])">
            <summary>
            Compute the number of bits required to serialize any of the longs in
            <code>data</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat">
             <summary>
             Provides a <seealso cref="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat.PostingsReaderBase(Lucene.Net.Index.SegmentReadState)"/> and {@link
             PostingsWriterBase}.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsBaseFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.DOC_EXTENSION">
            <summary>
            Filename extension for document number, frequencies, and skip data.
            See chapter: <a href="#Frequencies">Frequencies and Skip Data</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.POS_EXTENSION">
            <summary>
            Filename extension for positions.
            See chapter: <a href="#Positions">Positions</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.PAY_EXTENSION">
            <summary>
            Filename extension for payloads and offsets.
            See chapter: <a href="#Payloads">Payloads and Offsets</a>
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.BLOCK_SIZE">
            <summary>
            Fixed packed block size, number of integers encoded in
            a single packed block.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor">
            <summary>
            Creates {@code Lucene41PostingsFormat} with default
             settings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.FieldInfos,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsReader.ReadVInt32Block(Lucene.Net.Store.IndexInput,System.Int32[],System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Read values that have been written using variable-length encoding instead of bit-packing.
            <para/>
            NOTE: This was readVIntBlock() in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter" -->
        <member name="F:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.maxSkipLevels">
            <summary>
            Expert: The maximum number of skip levels. Smaller values result in
            slightly smaller indexes, but slower skipping in big posting lists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.#ctor(Lucene.Net.Index.SegmentWriteState,System.Single)">
            <summary>
            Creates a postings writer with the specified PackedInts overhead ratio </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.#ctor(Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Creates a postings writer with <code>PackedInts.COMPACT</code> </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.Int32BlockTermState">
            <summary>
            NOTE: This was IntBlockTermState in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.AddPosition(System.Int32,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsWriter.FinishTerm(Lucene.Net.Codecs.BlockTermState)">
            <summary>
            Called when we are done adding docs to this term </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader">
             <summary>
             Implements the skip list reader for block postings format
             that stores positions and payloads.
            
             Although this skipper uses MultiLevelSkipListReader as an interface,
             its definition of skip position will be a little different.
            
             For example, when skipInterval = blockSize = 3, df = 2*skipInterval = 6,
            
             0 1 2 3 4 5
             d d d d d d    (posting list)
                 ^     ^    (skip point in MultiLeveSkipWriter)
                   ^        (skip point in Lucene41SkipWriter)
            
             In this case, MultiLevelSkipListReader will use the last document as a skip point,
             while Lucene41SkipReader should assume no skip point will comes.
            
             If we use the interface directly in Lucene41SkipReader, it may silly try to read
             another skip data after the only skip point is loaded.
            
             To illustrate this, we can call skipTo(d[5]), since skip point d[3] has smaller docId,
             and numSkipped+blockSize== df, the MultiLevelSkipListReader will assume the skip list
             isn't exhausted yet, and try to load a non-existed skip point
            
             Therefore, we'll trim df before passing it to the interface. see trim(int)
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader.Trim(System.Int32)">
             <summary>
             Trim original docFreq to tell skipReader read proper number of skip points.
            
             Since our definition in Lucene41Skip* is a little different from MultiLevelSkip*
             this trimmed docFreq will prevent skipReader from:
             1. silly reading a non-existed skip point after the last block boundary
             2. moving into the vInt block
            
             </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene41.Lucene41SkipReader.DocPointer">
            <summary>
            Returns the doc pointer of the doc to which the last call of
            <seealso cref="!:MultiLevelSkipListReader#skipTo(int)"/> has skipped.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter">
             <summary>
             Write skip lists with multiple levels, and support skip within block ints.
            
             Assume that docFreq = 28, skipInterval = blockSize = 12
            
              |       block#0       | |      block#1        | |vInts|
              d d d d d d d d d d d d d d d d d d d d d d d d d d d d (posting list)
                                      ^                       ^       (level 0 skip point)
            
             Note that skipWriter will ignore first document in block#0, since
             it is useless as a skip point.  Also, we'll never skip into the vInts
             block, only record skip data at the start its start point(if it exist).
            
             For each skip point, we will record:
             1. docID in former position, i.e. for position 12, record docID[11], etc.
             2. its related file points(position, payload),
             3. related numbers or uptos(position, payload).
             4. start offset.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41SkipWriter.BufferSkip(System.Int32,System.Int32,System.Int64,System.Int64,System.Int32,System.Int32)">
            <summary>
            Sets the values for the current skip data.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat">
             <summary>
             Lucene 4.1 stored fields format.
            
             <p><b>Principle</b></p>
             <p>this <seealso cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/> compresses blocks of 16KB of documents in
             order to improve the compression ratio compared to document-level
             compression. It uses the <a href="http://code.google.com/p/lz4/">LZ4</a>
             compression algorithm, which is fast to compress and very fast to decompress
             data. Although the compression method that is used focuses more on speed
             than on compression ratio, it should provide interesting compression ratios
             for redundant inputs (such as log files, HTML or plain text).</p>
             <p><b>File formats</b></p>
             <p>Stored fields are represented by two files:</p>
             <ol>
             <li><a name="field_data" id="field_data"></a>
             <p>A fields data file (extension <tt>.fdt</tt>). this file stores a compact
             representation of documents in compressed blocks of 16KB or more. When
             writing a segment, documents are appended to an in-memory <tt>byte[]</tt>
             buffer. When its size reaches 16KB or more, some metadata about the documents
             is flushed to disk, immediately followed by a compressed representation of
             the buffer using the
             <a href="http://code.google.com/p/lz4/">LZ4</a>
             <a href="http://fastcompression.blogspot.fr/2011/05/lz4-explained.html">compression format</a>.</p>
             <p>Here is a more detailed description of the field data file format:</p>
             <ul>
             <li>FieldData (.fdt) --&gt; &lt;Header&gt;, PackedIntsVersion, &lt;Chunk&gt;<sup>ChunkCount</sup></li>
             <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
             <li>PackedIntsVersion --&gt; <seealso cref="!:PackedInts#VERSION_CURRENT"/> as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
             <li>ChunkCount is not known in advance and is the number of chunks necessary to store all document of the segment</li>
             <li>Chunk --&gt; DocBase, ChunkDocs, DocFieldCounts, DocLengths, &lt;CompressedDocs&gt;</li>
             <li>DocBase --&gt; the ID of the first document of the chunk as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
             <li>ChunkDocs --&gt; the number of documents in the chunk as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
             <li>DocFieldCounts --&gt; the number of stored fields of every document in the chunk, encoded as followed:<ul>
               <li>if chunkDocs=1, the unique value is encoded as a <seealso cref="!:DataOutput#writeVInt VInt"/></li>
               <li>else read a <seealso cref="!:DataOutput#writeVInt VInt"/> (let's call it <tt>bitsRequired</tt>)<ul>
                 <li>if <tt>bitsRequired</tt> is <tt>0</tt> then all values are equal, and the common value is the following <seealso cref="!:DataOutput#writeVInt VInt"/></li>
                 <li>else <tt>bitsRequired</tt> is the number of bits required to store any value, and values are stored in a <seealso cref="!:PackedInts packed"/> array where every value is stored on exactly <tt>bitsRequired</tt> bits</li>
               </ul></li>
             </ul></li>
             <li>DocLengths --&gt; the lengths of all documents in the chunk, encoded with the same method as DocFieldCounts</li>
             <li>CompressedDocs --&gt; a compressed representation of &lt;Docs&gt; using the LZ4 compression format</li>
             <li>Docs --&gt; &lt;Doc&gt;<sup>ChunkDocs</sup></li>
             <li>Doc --&gt; &lt;FieldNumAndType, Value&gt;<sup>DocFieldCount</sup></li>
             <li>FieldNumAndType --&gt; a <seealso cref="!:DataOutput#writeVLong VLong"/>, whose 3 last bits are Type and other bits are FieldNum</li>
             <li>Type --&gt;<ul>
               <li>0: Value is String</li>
               <li>1: Value is BinaryValue</li>
               <li>2: Value is Int</li>
               <li>3: Value is Float</li>
               <li>4: Value is Long</li>
               <li>5: Value is Double</li>
               <li>6, 7: unused</li>
             </ul></li>
             <li>FieldNum --&gt; an ID of the field</li>
             <li>Value --&gt; <seealso cref="!:DataOutput#writeString(String) String"/> | BinaryValue | Int | Float | Long | Double depending on Type</li>
             <li>BinaryValue --&gt; ValueLength &lt;Byte&gt;<sup>ValueLength</sup></li>
             </ul>
             <p>Notes</p>
             <ul>
             <li>If documents are larger than 16KB then chunks will likely contain only
             one document. However, documents can never spread across several chunks (all
             fields of a single document are in the same chunk).</li>
             <li>When at least one document in a chunk is large enough so that the chunk
             is larger than 32KB, the chunk will actually be compressed in several LZ4
             blocks of 16KB. this allows <seealso cref="T:Lucene.Net.Index.StoredFieldVisitor"/>s which are only
             interested in the first fields of a document to not have to decompress 10MB
             of data if the document is 10MB, but only 16KB.</li>
             <li>Given that the original lengths are written in the metadata of the chunk,
             the decompressor can leverage this information to stop decoding as soon as
             enough data has been decompressed.</li>
             <li>In case documents are incompressible, CompressedDocs will be less than
             0.5% larger than Docs.</li>
             </ul>
             </li>
             <li><a name="field_index" id="field_index"></a>
             <p>A fields index file (extension <tt>.fdx</tt>).</p>
             <ul>
             <li>FieldsIndex (.fdx) --&gt; &lt;Header&gt;, &lt;ChunkIndex&gt;</li>
             <li>Header --&gt; <seealso cref="!:CodecUtil#writeHeader CodecHeader"/></li>
             <li>ChunkIndex: See <seealso cref="T:Lucene.Net.Codecs.Compressing.CompressingStoredFieldsIndexWriter"/></li>
             </ul>
             </li>
             </ol>
             <p><b>Known limitations</b></p>
             <p>this <seealso cref="T:Lucene.Net.Codecs.StoredFieldsFormat"/> does not support individual documents
             larger than (<tt>2<sup>31</sup> - 2<sup>14</sup></tt>) bytes. In case this
             is a problem, you should use another format, such as
             <seealso cref="T:Lucene.Net.Codecs.Lucene40.Lucene40StoredFieldsFormat"/>.</p>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene41.Lucene41StoredFieldsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42Codec.GetDocValuesFormatForField(System.String)">
             <summary>
             Returns the docvalues format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene42"
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat" -->
        <member name="F:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.MAX_BINARY_FIELD_LENGTH">
            <summary>
            Maximum length for each binary doc values field. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.#ctor">
            <summary>
            Calls {@link #Lucene42DocValuesFormat(float)
            Lucene42DocValuesFormat(PackedInts.DEFAULT)}
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat.#ctor(System.Single)">
             <summary>
             Creates a new Lucene42DocValuesFormat with the specified
             <code>acceptableOverheadRatio</code> for NumericDocValues. </summary>
             <param name="acceptableOverheadRatio"> compression parameter for numerics.
                    Currently this is only used when the number of unique values is small.
            
             @lucene.experimental </param>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer">
            <summary>
            Reader for <seealso cref="T:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesFormat"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer.NumericEntry.PackedInt32sVersion">
            <summary>
            NOTE: This was packedIntsVersion (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene42.Lucene42DocValuesProducer.BinaryEntry.PackedInt32sVersion">
            <summary>
            NOTE: This was packedIntsVersion (field) in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosFormat.EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene42.Lucene42NormsConsumer">
            <summary>
            Writer for <seealso cref="T:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat.#ctor">
            <summary>
            Calls {@link #Lucene42NormsFormat(float)
            Lucene42DocValuesFormat(PackedInts.FASTEST)}
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42NormsFormat.#ctor(System.Single)">
             <summary>
             Creates a new Lucene42DocValuesFormat with the specified
             <code>acceptableOverheadRatio</code> for NumericDocValues. </summary>
             <param name="acceptableOverheadRatio"> compression parameter for numerics.
                    Currently this is only used when the number of unique values is small.
            
             @lucene.experimental </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene42.Lucene42TermVectorsFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene42.Lucene42TermVectorsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene45.Lucene45Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45Codec.GetDocValuesFormatForField(System.String)">
             <summary>
             Returns the docvalues format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene45"
             </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer">
            <summary>
            writer for <seealso cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat"/> </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.DELTA_COMPRESSED">
            <summary>
            Compressed using packed blocks of ints. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.GCD_COMPRESSED">
            <summary>
            Compressed by computing the GCD. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.TABLE_COMPRESSED">
            <summary>
            Compressed by giving IDs to unique values. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_FIXED_UNCOMPRESSED">
            <summary>
            Uncompressed binary, written directly (fixed length). </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_VARIABLE_UNCOMPRESSED">
            <summary>
            Uncompressed binary, written directly (variable length). </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.BINARY_PREFIX_COMPRESSED">
            <summary>
            Compressed binary with shared prefixes </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.SORTED_SET_WITH_ADDRESSES">
            <summary>
            Standard storage for sorted set values with 1 level of indirection:
             docId -> address -> ord.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.SORTED_SET_SINGLE_VALUED_SORTED">
            <summary>
            Single-valued sorted set values, encoded as sorted values, so no level
             of indirection: docId -> ord.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.#ctor(Lucene.Net.Index.SegmentWriteState,System.String,System.String,System.String,System.String)">
            <summary>
            expert: Creates a new writer </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesConsumer.AddTermsDict(Lucene.Net.Index.FieldInfo,System.Collections.Generic.IEnumerable{Lucene.Net.Util.BytesRef})">
            <summary>
            expert: writes a value dictionary for a sorted/sortedset field </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat.#ctor">
            <summary>
            Sole Constructor </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer">
            <summary>
            reader for <seealso cref="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesFormat"/> </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.#ctor(Lucene.Net.Index.SegmentReadState,System.String,System.String,System.String,System.String)">
            <summary>
            expert: instantiates a new reader </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetAddressInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry)">
            <summary>
            returns an address instance for variable-length binary values.
             @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetIntervalInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry)">
            <summary>
            returns an address instance for prefix-compressed binary values.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.GetOrdIndexInstance(Lucene.Net.Store.IndexInput,Lucene.Net.Index.FieldInfo,Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry)">
            <summary>
            returns an address instance for sortedset ordinal lists
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry">
            <summary>
            metadata entry for a numeric docvalues field </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.missingOffset">
            <summary>
            offset to the bitset representing docsWithField, or -1 if no documents have missing values </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.Offset">
            <summary>
            offset to the actual numeric values </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.PackedInt32sVersion">
            <summary>
            packed ints version used to encode these numerics 
            <para/>
            NOTE: This was packedIntsVersion (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.Count">
            <summary>
            count of values written </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.NumericEntry.BlockSize">
            <summary>
            packed ints blocksize </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry">
            <summary>
            metadata entry for a binary docvalues field </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.missingOffset">
            <summary>
            offset to the bitset representing docsWithField, or -1 if no documents have missing values </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.offset">
            <summary>
            offset to the actual binary values </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.Count">
            <summary>
            count of values written </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.AddressesOffset">
            <summary>
            offset to the addressing data that maps a value to its slice of the byte[] </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.AddressInterval">
            <summary>
            interval of shared prefix chunks (when using prefix-compressed binary) </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.PackedInt32sVersion">
            <summary>
            packed ints version used to encode addressing information 
            <para/>
            NOTE: This was packedIntsVersion (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.BinaryEntry.BlockSize">
            <summary>
            packed ints blocksize </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.SortedSetEntry">
            <summary>
            metadata entry for a sorted-set docvalues field </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.Lucene45.Lucene45DocValuesProducer.Int64BinaryDocValues">
            <summary>
            NOTE: This was LongBinaryDocValues in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46Codec" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.GetPostingsFormatForField(System.String)">
             <summary>
             Returns the postings format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene41"
             </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46Codec.GetDocValuesFormatForField(System.String)">
             <summary>
             Returns the docvalues format that should be used for writing
              new segments of <code>field</code>.
            
              The default implementation always returns "Lucene45"
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosFormat.EXTENSION">
            <summary>
            Extension of field infos </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosWriter" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46FieldInfosWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoFormat.SI_EXTENSION">
            <summary>
            File extension used to store <seealso cref="T:Lucene.Net.Index.SegmentInfo"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoReader" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoReader.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter" -->
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.Lucene46.Lucene46SegmentInfoWriter.Write(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext)">
            <summary>
            Save a single segment's info. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat" -->
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.PER_FIELD_FORMAT_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             format name for each field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.PER_FIELD_SUFFIX_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             segment suffix name for each field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PerField.PerFieldDocValuesFormat.GetDocValuesFormatForField(System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat" -->
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.PER_FIELD_FORMAT_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             format name for each field.
            </summary>
        </member>
        <member name="F:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.PER_FIELD_SUFFIX_KEY">
            <summary>
            <seealso cref="T:Lucene.Net.Index.FieldInfo"/> attribute name used to store the
             segment suffix name for each field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat.GetPostingsFormatForField(System.String)" -->
        <member name="T:Lucene.Net.Codecs.CodecNameAttribute">
            <summary>
            Represents an attribute that is used to name a <see cref="T:Lucene.Net.Codecs.Codec"/>, if a name
            other than the default <see cref="T:Lucene.Net.Codecs.Codec"/> naming convention is desired.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.DefaultCodecFactory">
            <summary>
            LUCENENET specific class that implements the default functionality for the 
            <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>.
            <para/>
            The most common use cases are:
            <list type="bullet">
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.Type)"/> so an external dependency injection
                    container can be used to supply the instances (lifetime should be singleton). Note that you could 
                    alternately use the "named type" feature that many DI containers have to supply the type based on name by 
                    overriding <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.String)"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodecType(System.String)"/> so a type new type can be
                    supplied that is not in the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> to add new or override the default <see cref="T:Lucene.Net.Codecs.Codec"/> 
                    types by overriding <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/> to scan additional assemblies for <see cref="T:Lucene.Net.Codecs.Codec"/>
                    subclasses in by overriding <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/>. 
                    For performance reasons, the default behavior only loads Lucene.Net codecs.</item>
            </list>
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>, call <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.Initialize">
            <summary>
            Initializes the codec type cache with the known <see cref="T:Lucene.Net.Codecs.Codec"/> types.
            Override this method (and optionally call <c>base.Initialize()</c>) to add your
            own <see cref="T:Lucene.Net.Codecs.Codec"/> types by calling <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)"/> 
            or <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/>.
            <para/>
            If two types have the same name by using the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>, the
            last one registered wins.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Scans the given <paramref name="assemblies"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.Codec"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assemblies">A list of assemblies to scan. The assemblies will be scanned from first to last, 
            and the last match for each <see cref="T:Lucene.Net.Codecs.Codec"/> name wins.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)">
            <summary>
            Scans the given <paramref name="assembly"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.Codec"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assembly">The assembly to scan.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)">
            <summary>
            Adds a <see cref="T:Lucene.Net.Codecs.Codec"/> type to the <see cref="F:Lucene.Net.Codecs.DefaultCodecFactory.codecNameToTypeMap"/>, using 
            the name provided in the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>, if present, or the name
            of the codec class minus the "Codec" suffix as the name by default.
            <para/>
            Note that if a <see cref="T:Lucene.Net.Codecs.Codec"/> with the same name already exists in the map,
            calling this method will update it to the new type.
            </summary>
            <param name="codec">A type that subclasses <see cref="T:Lucene.Net.Codecs.Codec"/>.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.Codec"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodec(System.Type)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> instance from the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.Codec"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.GetCodecType(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> <see cref="T:System.Type"/> from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.Codec"/> <see cref="T:System.Type"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultCodecFactory.AvailableServices">
            <summary>
            Gets a list of the available <see cref="T:Lucene.Net.Codecs.Codec"/>s (by name).
            </summary>
            <returns>A <see cref="T:ICollection{string}"/> of <see cref="T:Lucene.Net.Codecs.Codec"/> names.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory">
            <summary>
            LUCENENET specific class that implements the default functionality for the 
            <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>.
            <para/>
            The most common use cases are:
            <list type="bullet">
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.Type)"/> so an external dependency injection
                    container can be used to supply the instances (lifetime should be singleton). Note that you could 
                    alternately use the "named type" feature that many DI containers have to supply the type based on name by 
                    overriding <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.String)"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormatType(System.String)"/> so a type new type can be
                    supplied that is not in the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> to add new or override the default <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> 
                    types by overriding <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/> to scan additional assemblies for <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>
                    subclasses in by overriding <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/>. 
                    For performance reasons, the default behavior only loads Lucene.Net codecs.</item>
            </list>
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.Initialize">
            <summary>
            Initializes the doc values type cache with the known <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> types.
            Override this method (and optionally call <c>base.Initialize()</c>) to add your
            own <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> types by calling <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)"/> 
            or <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/>.
            <para/>
            If two types have the same name by using the <see cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/>, the
            last one registered wins.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Scans the given <paramref name="assemblies"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assemblies">A list of assemblies to scan. The assemblies will be scanned from first to last, 
            and the last match for each <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> name wins.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)">
            <summary>
            Scans the given <paramref name="assembly"/> for subclasses of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assembly">The assembly to scan.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)">
            <summary>
            Adds a <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> type to the <see cref="F:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.docValuesFormatNameToTypeMap"/>, using 
            the name provided in the <see cref="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute"/>, if present, or the name
            of the codec class minus the "DocValuesFormat" suffix as the name by default.
            <para/>
            Note that if a <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> with the same name already exists in the map,
            calling this method will update it to the new type.
            </summary>
            <param name="docValuesFormat">A type that subclasses <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormat(System.Type)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance from the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.GetDocValuesFormatType(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> <see cref="T:System.Type"/> from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> <see cref="T:System.Type"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.AvailableServices">
            <summary>
            Gets a list of the available <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>s (by name).
            </summary>
            <returns>A <see cref="T:ICollection{string}"/> of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> names.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory">
            <summary>
            LUCENENET specific class that implements the default functionality for the 
            <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>.
            <para/>
            The most common use cases are:
            <list type="bullet">
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.Type)"/> so an external dependency injection
                    container can be used to supply the instances (lifetime should be singleton). Note that you could 
                    alternately use the "named type" feature that many DI containers have to supply the type based on name by 
                    overriding <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.String)"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> and override
                    <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormatType(System.String)"/> so a type new type can be
                    supplied that is not in the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> to add new or override the default <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> 
                    types by overriding <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)"/>.</item>
                <item>subclass <see cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/> to scan additional assemblies for <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
                    subclasses in by overriding <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize"/> and calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/>. 
                    For performance reasons, the default behavior only loads Lucene.Net codecs.</item>
            </list>
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.Initialize">
            <summary>
            Initializes the codec type cache with the known <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> types.
            Override this method (and optionally call <c>base.Initialize()</c>) to add your
            own <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> types by calling <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)"/> 
            or <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/>.
            <para/>
            If two types have the same name by using the <see cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/>, the
            last one registered wins.
            </summary>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Collections.Generic.IEnumerable{System.Reflection.Assembly})">
            <summary>
            Scans the given <paramref name="assemblies"/> for subclasses of <see cref="T:Lucene.Net.Codecs.Codec"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assemblies">A list of assemblies to scan. The assemblies will be scanned from first to last, 
            and the last match for each <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> name wins.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)">
            <summary>
            Scans the given <paramref name="assembly"/> for subclasses of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
            and adds their names to the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>. Note that names will be
            automatically overridden if the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> name appears multiple times - the last match wins.
            </summary>
            <param name="assembly">The assembly to scan.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)">
            <summary>
            Adds a <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> type to the <see cref="F:Lucene.Net.Codecs.DefaultPostingsFormatFactory.postingsFormatNameToTypeMap"/>, using 
            the name provided in the <see cref="T:Lucene.Net.Codecs.PostingsFormatNameAttribute"/>, if present, or the name
            of the codec class minus the "Codec" suffix as the name by default.
            <para/>
            Note that if a <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> with the same name already exists in the map,
            calling this method will update it to the new type.
            </summary>
            <param name="postingsFormat">A type that subclasses <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>.</param>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormat(System.Type)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance from the provided <paramref name="type"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.GetPostingsFormatType(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> <see cref="T:System.Type"/> from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> <see cref="T:System.Type"/> to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> <see cref="T:System.Type"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.AvailableServices">
            <summary>
            Gets a list of the available <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>s (by name).
            </summary>
            <returns>A <see cref="T:ICollection{string}"/> of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> names.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.DocValuesFormatNameAttribute">
            <summary>
            Represents an attribute that is used to name a <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>, if a name
            other than the default <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> naming convention is desired.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ExcludeCodecFromScanAttribute">
            <summary>
            When placed on a class that subclasses <see cref="T:Lucene.Net.Codecs.Codec"/>, adding this
            attribute will exclude the type from consideration in the 
            <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.ScanForCodecs(System.Reflection.Assembly)"/> method.
            <para/>
            However, the <see cref="T:Lucene.Net.Codecs.Codec"/> type can still be added manually using
            <see cref="M:Lucene.Net.Codecs.DefaultCodecFactory.PutCodecType(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ExcludeDocValuesFormatFromScanAttribute">
            <summary>
            When placed on a class that subclasses <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/>, adding this
            attribute will exclude the type from consideration in the 
            <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.ScanForDocValuesFormats(System.Reflection.Assembly)"/> method.
            <para/>
            However, the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> type can still be added manually using
            <see cref="M:Lucene.Net.Codecs.DefaultDocValuesFormatFactory.PutDocValuesFormatType(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ExcludePostingsFormatFromScanAttribute">
            <summary>
            When placed on a class that subclasses <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>, adding this
            attribute will exclude the type from consideration in the 
            <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.ScanForPostingsFormats(System.Reflection.Assembly)"/> method.
            <para/>
            However, the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> type can still be added manually using
            <see cref="M:Lucene.Net.Codecs.DefaultPostingsFormatFactory.PutPostingsFormatType(System.Type)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Codecs.ICodecFactory">
            <summary>
            LUCENENET specific contract for extending the functionality of <see cref="T:Lucene.Net.Codecs.Codec"/> implementations so
            they can be injected with dependencies.
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>, call <see cref="M:Lucene.Net.Codecs.Codec.SetCodecFactory(Lucene.Net.Codecs.ICodecFactory)"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultCodecFactory"/>
        </member>
        <member name="M:Lucene.Net.Codecs.ICodecFactory.GetCodec(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.Codec"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.Codec"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.Codec"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.IDocValuesFormatFactory">
            <summary>
            LUCENENET specific contract for extending the functionality of <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> implementations so
            they can be injected with dependencies.
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.DocValuesFormat.SetDocValuesFormatFactory(Lucene.Net.Codecs.IDocValuesFormatFactory)"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultDocValuesFormatFactory"/>
        </member>
        <member name="M:Lucene.Net.Codecs.IDocValuesFormatFactory.GetDocValuesFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.DocValuesFormat"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.IPostingsFormatFactory">
            <summary>
            LUCENENET specific contract for extending the functionality of <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> implementations so
            they can be injected with dependencies.
            <para/>
            To set the <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/>, call <see cref="M:Lucene.Net.Codecs.PostingsFormat.SetPostingsFormatFactory(Lucene.Net.Codecs.IPostingsFormatFactory)"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Codecs.DefaultPostingsFormatFactory"/>
        </member>
        <member name="M:Lucene.Net.Codecs.IPostingsFormatFactory.GetPostingsFormat(System.String)">
            <summary>
            Gets the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance from the provided <paramref name="name"/>.
            </summary>
            <param name="name">The name of the <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance to retrieve.</param>
            <returns>The <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> instance.</returns>
        </member>
        <member name="T:Lucene.Net.Codecs.PostingsFormatNameAttribute">
            <summary>
            Represents an attribute that is used to name a <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>, if a name
            other than the default <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> naming convention is desired.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.BinaryDocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value.
             <para/>
             The values are stored directly with no sharing, which is a good fit when
             the fields don't share (many) values, such as a title field.  If values
             may be shared and sorted it's better to use <see cref="T:Lucene.Net.Documents.SortedDocValuesField"/>.
             Here's an example usage:
            
             <code>
               document.Add(new BinaryDocValuesField(name, new BytesRef("hello")));
             </code>
             <para/>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
             <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/>
        </member>
        <member name="F:Lucene.Net.Documents.BinaryDocValuesField.fType">
            <summary>
            Type for straight bytes <see cref="T:Lucene.Net.Index.DocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.BinaryDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new binary <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="value"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="T:Lucene.Net.Documents.ByteDocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:System.Byte"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
               document.Add(new ByteDocValuesField(name, (byte) 22));
             </code>
             
             <para/>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.ByteDocValuesField.#ctor(System.String,System.Byte)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 8-bit byte value </summary>
            <param name="name"> field name </param>
            <param name="value"> 8-bit byte value </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.CompressionTools">
            <summary>
            Simple utility class providing static methods to
            compress and decompress binary data for stored fields.
            this class uses the <see cref="T:System.IO.Compression.DeflateStream"/>
            class to compress and decompress.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[],System.Int32,System.Int32,System.IO.Compression.CompressionLevel)">
            <summary>
            Compresses the specified <see cref="T:System.Byte"/> range using the
            specified <paramref name="compressionLevel"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Compresses the specified <see cref="T:System.Byte"/> range, with default <see cref="F:System.IO.Compression.CompressionLevel.Optimal"/> level 
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Compress(System.Byte[])">
            <summary>
            Compresses all <see cref="T:System.Byte"/>s in the array, with default <see cref="F:System.IO.Compression.CompressionLevel.Optimal"/> level </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)">
            <summary>
            Compresses the <see cref="T:System.String"/> value, with default <see cref="F:System.IO.Compression.CompressionLevel.Optimal"/> level </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String,System.IO.Compression.CompressionLevel)">
            <summary>
            Compresses the <see cref="T:System.String"/> value using the specified
            <paramref name="compressionLevel"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            compress (referenced by the provided <see cref="T:Lucene.Net.Util.BytesRef"/>)
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(System.Byte[])">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            compress
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.Decompress(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            compress
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(System.Byte[])">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            <see cref="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)"/> back into a <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array previously returned by
            <see cref="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)"/> back into a <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.CompressionTools.DecompressString(Lucene.Net.Util.BytesRef)">
            <summary>
            Decompress the <see cref="T:System.Byte"/> array (referenced by the provided <see cref="T:Lucene.Net.Util.BytesRef"/>)
            previously returned by <see cref="M:Lucene.Net.Documents.CompressionTools.CompressString(System.String)"/> back into a <see cref="T:System.String"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.DateTools">
             <summary>
             Provides support for converting dates to strings and vice-versa.
             The strings are structured so that lexicographic sorting orders
             them by date, which makes them suitable for use as field values
             and search terms.
            
             <para/>This class also helps you to limit the resolution of your dates. Do not
             save dates with a finer resolution than you really need, as then
             <see cref="T:Lucene.Net.Search.TermRangeQuery"/> and <see cref="T:Lucene.Net.Search.PrefixQuery"/> will require more memory and become slower.
            
             <para/>
             Another approach is <see cref="T:Lucene.Net.Util.NumericUtils"/>, which provides
             a sortable binary representation (prefix encoded) of numeric values, which
             date/time are.
             
             For indexing a <see cref="T:System.DateTime"/>, just get the <see cref="P:System.DateTime.Ticks"/> and index
             this as a numeric value with <see cref="T:Lucene.Net.Documents.Int64Field"/> and use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>
             to query it.
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Converts a <see cref="T:System.DateTime"/> to a string suitable for indexing.
            </summary>
            <param name="date"> the date to be converted </param>
            <param name="resolution"> the desired resolution, see
            <see cref="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)"/> </param>
            <returns> a string in format <c>yyyyMMddHHmmssSSS</c> or shorter,
            depending on <paramref name="resolution"/>; using GMT as timezone  </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Converts a millisecond time to a string suitable for indexing.
            </summary>
            <param name="time"> the date expressed as milliseconds since January 1, 1970, 00:00:00 GMT (also known as the "epoch") </param>
            <param name="resolution"> the desired resolution, see
            <see cref="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)"/> </param>
            <returns> a string in format <c>yyyyMMddHHmmssSSS</c> or shorter,
            depending on <paramref name="resolution"/>; using GMT as timezone </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToTime(System.String)">
            <summary>
            Converts a string produced by <see cref="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)"/> or
            <see cref="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)"/> back to a time, represented as the
            number of milliseconds since January 1, 1970, 00:00:00 GMT (also known as the "epoch").
            </summary>
            <param name="dateString"> the date string to be converted </param>
            <returns> the number of milliseconds since January 1, 1970, 00:00:00 GMT (also known as the "epoch")</returns>
            <exception cref="T:System.FormatException"> if <paramref name="dateString"/> is not in the
            expected format </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.StringToDate(System.String)">
            <summary>
            Converts a string produced by <see cref="M:Lucene.Net.Documents.DateTools.TimeToString(System.Int64,Lucene.Net.Documents.DateTools.Resolution)"/> or
            <see cref="M:Lucene.Net.Documents.DateTools.DateToString(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)"/> back to a time, represented as a
            <see cref="T:System.DateTime"/> object.
            </summary>
            <param name="dateString"> the date string to be converted </param>
            <returns> the parsed time as a <see cref="T:System.DateTime"/> object </returns>
            <exception cref="T:System.FormatException"> if <paramref name="dateString"/> is not in the
            expected format </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.DateTime,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Limit a date's resolution. For example, the date <c>2004-09-21 13:50:11</c>
            will be changed to <c>2004-09-01 00:00:00</c> when using
            <see cref="F:Lucene.Net.Documents.DateTools.Resolution.MONTH"/>.
            </summary>
            <param name="date"> the date to be rounded </param>
            <param name="resolution"> The desired resolution of the date to be returned </param>
            <returns> the date with all values more precise than <paramref name="resolution"/>
            set to 0 or 1 </returns>
        </member>
        <member name="M:Lucene.Net.Documents.DateTools.Round(System.Int64,Lucene.Net.Documents.DateTools.Resolution)">
            <summary>
            Limit a date's resolution. For example, the date <c>1095767411000</c>
            (which represents 2004-09-21 13:50:11) will be changed to
            <c>1093989600000</c> (2004-09-01 00:00:00) when using
            <see cref="F:Lucene.Net.Documents.DateTools.Resolution.MONTH"/>.
            </summary>
            <param name="time"> the time to be rounded </param>
            <param name="resolution"> The desired resolution of the date to be returned </param>
            <returns> the date with all values more precise than <paramref name="resolution"/>
            set to 0 or 1, expressed as milliseconds since January 1, 1970, 00:00:00 GMT 
            (also known as the "epoch")</returns>
        </member>
        <member name="T:Lucene.Net.Documents.DateTools.Resolution">
            <summary>
            Specifies the time granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.YEAR">
            <summary>
            Limit a date's resolution to year granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MONTH">
            <summary>
            Limit a date's resolution to month granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.DAY">
            <summary>
            Limit a date's resolution to day granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.HOUR">
            <summary>
            Limit a date's resolution to hour granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MINUTE">
            <summary>
            Limit a date's resolution to minute granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.SECOND">
            <summary>
            Limit a date's resolution to second granularity. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DateTools.Resolution.MILLISECOND">
            <summary>
            Limit a date's resolution to millisecond granularity. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.DerefBytesDocValuesField">
             <summary>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value. Here's an example usage:
            
             <code>
               document.Add(new DerefBytesDocValuesField(name, new BytesRef("hello")));
             </code>
            
             <para/>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
             <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/>
        </member>
        <member name="F:Lucene.Net.Documents.DerefBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for bytes <see cref="T:Lucene.Net.Index.DocValues"/>: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DerefBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for bytes <see cref="T:Lucene.Net.Index.DocValues"/>: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DerefBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable-length <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DerefBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length <see cref="T:Lucene.Net.Index.DocValues"/> field.
            </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is null </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Document">
            <summary>
            Documents are the unit of indexing and search.
            <para/>
            A Document is a set of fields.  Each field has a name and a textual value.
            A field may be stored (<see cref="P:Lucene.Net.Index.IIndexableFieldType.IsStored"/>) with the document, in which
            case it is returned with search hits on the document.  Thus each document
            should typically contain one or more stored fields which uniquely identify
            it.
            <para/>
            Note that fields which are <i>not</i> <see cref="P:Lucene.Net.Index.IIndexableFieldType.IsStored"/> are
            <i>not</i> available in documents retrieved from the index, e.g. with 
            <see cref="P:Lucene.Net.Search.ScoreDoc.Doc"/> or <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.#ctor">
            <summary>
            Constructs a new document with no fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Add(Lucene.Net.Index.IIndexableField)">
            <summary>
            <para>Adds a field to a document.  Several fields may be added with
            the same name.  In this case, if the fields are indexed, their text is
            treated as though appended for the purposes of search.</para>
            <para> Note that add like the <see cref="M:Lucene.Net.Documents.Document.RemoveField(System.String)"/> and <see cref="M:Lucene.Net.Documents.Document.RemoveFields(System.String)"/> methods only makes sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveField(System.String)">
            <summary>
            <para>Removes field with the specified name from the document.
            If multiple fields exist with this name, this method removes the first field that has been added.
            If there is no field with the specified name, the document remains unchanged.</para>
            <para> Note that the <see cref="M:Lucene.Net.Documents.Document.RemoveField(System.String)"/> and <see cref="M:Lucene.Net.Documents.Document.RemoveFields(System.String)"/> methods like the add method only make sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.RemoveFields(System.String)">
            <summary>
            <para>Removes all fields with the given name from the document.
            If there is no field with the specified name, the document remains unchanged.</para>
            <para> Note that the <see cref="M:Lucene.Net.Documents.Document.RemoveField(System.String)"/> and <see cref="M:Lucene.Net.Documents.Document.RemoveFields(System.String)"/> methods like the add method only make sense
            prior to adding a document to an index. These methods cannot
            be used to change the content of an existing index! In order to achieve this,
            a document has to be deleted from an index and a new changed version of that
            document has to be added.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValues(System.String)">
            <summary>
            Returns an array of byte arrays for of the fields that have the name specified
            as the method parameter. This method returns an empty
            array when there are no matching fields.  It never
            returns <c>null</c>.
            </summary>
            <param name="name"> the name of the field </param>
            <returns> a <see cref="T:BytesRef[]"/> of binary field values </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetBinaryValue(System.String)">
            <summary>
            Returns an array of bytes for the first (or only) field that has the name
            specified as the method parameter. this method will return <c>null</c>
            if no binary fields with the specified name are available.
            There may be non-binary fields with the same name.
            </summary>
            <param name="name"> the name of the field. </param>
            <returns> a <see cref="T:Lucene.Net.Util.BytesRef"/> containing the binary field value or <c>null</c> </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetField(System.String)">
            <summary>
            Returns a field with the given name if any exist in this document, or
            <c>null</c>. If multiple fields exists with this name, this method returns the
            first value added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetFields(System.String)">
            <summary>
            Returns an array of <see cref="T:Lucene.Net.Index.IIndexableField"/>s with the given name.
            this method returns an empty array when there are no
            matching fields. It never returns <c>null</c>.
            </summary>
            <param name="name"> the name of the field </param>
            <returns> a <see cref="T:IndexableField[]"/> array </returns>
        </member>
        <member name="P:Lucene.Net.Documents.Document.Fields">
            <summary>
            Returns a List of all the fields in a document.
            <para>Note that fields which are <i>not</i> stored are
            <i>not</i> available in documents retrieved from the
            index, e.g. <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or 
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.GetValues(System.String)">
            <summary>
            Returns an array of values of the field specified as the method parameter.
            This method returns an empty array when there are no
            matching fields. It never returns <c>null</c>.
            For <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/>, 
            <see cref="T:Lucene.Net.Documents.SingleField"/> and <seealso cref="T:Lucene.Net.Documents.DoubleField"/> it returns the string value of the number. If you want
            the actual numeric field instances back, use <see cref="M:Lucene.Net.Documents.Document.GetFields(System.String)"/>. </summary>
            <param name="name"> the name of the field </param>
            <returns> a <see cref="T:string[]"/> of field values </returns>
        </member>
        <member name="M:Lucene.Net.Documents.Document.Get(System.String)">
            <summary>
            Returns the string value of the field with the given name if any exist in
            this document, or <c>null</c>.  If multiple fields exist with this name, this
            method returns the first value added. If only binary fields with this name
            exist, returns <c>null</c>.
            For <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.Int64Field"/>, 
            <see cref="T:Lucene.Net.Documents.SingleField"/> and <seealso cref="T:Lucene.Net.Documents.DoubleField"/> it returns the string value of the number. If you want
            the actual numeric field instance back, use <see cref="M:Lucene.Net.Documents.Document.GetField(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Document.ToString">
            <summary>
            Prints the fields of a document for human consumption. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.DocumentStoredFieldVisitor">
             <summary>
             A <see cref="T:Lucene.Net.Index.StoredFieldVisitor"/> that creates a 
             <see cref="P:Lucene.Net.Documents.DocumentStoredFieldVisitor.Document"/> containing all stored fields, or only specific
             requested fields provided to <see cref="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.Collections.Generic.ISet{System.String})"/>.
             <para/>
             This is used by <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> to load a
             document.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.Collections.Generic.ISet{System.String})">
            <summary>
            Load only fields named in the provided <see cref="T:System.Collections.Generic.ISet`1"/>. </summary>
            <param name="fieldsToAdd"> Set of fields to load, or <c>null</c> (all fields). </param>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.String[])">
            <summary>
            Load only fields named in the provided fields. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor">
            <summary>
            Load all stored fields. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.DocumentStoredFieldVisitor.Document">
            <summary>
            Retrieve the visited document. </summary>
            <returns> Document populated with stored fields. Note that only
                    the stored information in the field instances is valid,
                    data such as boosts, indexing options, term vector options,
                    etc is not set. </returns>
        </member>
        <member name="T:Lucene.Net.Documents.DoubleDocValuesField">
            <summary>
            Syntactic sugar for encoding doubles as <see cref="T:Lucene.Net.Index.NumericDocValues"/>
            via <see cref="M:Lucene.Net.Support.Number.DoubleToRawInt64Bits(System.Double)"/>.
            <para/>
            Per-document double values can be retrieved via
            <see cref="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>.
            <para/>
            <b>NOTE</b>: In most all cases this will be rather inefficient,
            requiring eight bytes per document. Consider encoding double
            values yourself with only as much precision as you require.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleDocValuesField.#ctor(System.String,System.Double)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 64-bit double value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit double value </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.DoubleField">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Double"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
             document.Add(new DoubleField(name, 6.0, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.DoubleField"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 DoubleField field = new DoubleField(name, 0.0, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents)
                 {
                     ...
                     field.SetDoubleValue(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <seealso cref="T:Lucene.Net.Documents.Int32Field"/>, <seealso cref="T:Lucene.Net.Documents.Int64Field"/>, 
             <see cref="T:Lucene.Net.Documents.SingleField"/>.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.DoubleField"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.DoubleField"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.DOUBLE"/>. <see cref="T:Lucene.Net.Documents.DoubleField"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.DoubleField"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.DoubleField"/>.</para>
            
             <para>A <see cref="T:Lucene.Net.Documents.DoubleField"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> (<a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>)
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/> directly, when indexing numbers. This
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
            
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DoubleField.TYPE_NOT_STORED">
            <summary>
            Type for a <see cref="T:Lucene.Net.Documents.DoubleField"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.DoubleField.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.DoubleField"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleField.#ctor(System.String,System.Double,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.DoubleField"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4).
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Double"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c>.  </exception>
        </member>
        <member name="M:Lucene.Net.Documents.DoubleField.#ctor(System.String,System.Double,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit double value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.DOUBLE"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field name or type is <c>null</c>, or
                     if the field type does not have a <see cref="F:Lucene.Net.Documents.NumericType.DOUBLE"/> <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Field">
             <summary>
             Expert: directly create a field for a document.  Most
             users should use one of the sugar subclasses: <see cref="T:Lucene.Net.Documents.Int32Field"/>, 
             <see cref="T:Lucene.Net.Documents.Int64Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/>, <see cref="T:Lucene.Net.Documents.DoubleField"/>, 
             <see cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>, <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/>,
             <see cref="T:Lucene.Net.Documents.SortedDocValuesField"/>, <see cref="T:Lucene.Net.Documents.StringField"/>,
             <see cref="T:Lucene.Net.Documents.TextField"/>, <see cref="T:Lucene.Net.Documents.StoredField"/>.
            
             <para/> A field is a section of a <see cref="T:Lucene.Net.Documents.Document"/>. Each field has three
             parts: name, type and value. Values may be text
             (<see cref="T:System.String"/>, <see cref="T:System.IO.TextReader"/> or pre-analyzed <see cref="T:Lucene.Net.Analysis.TokenStream"/>), binary
             (<see cref="T:byte[]"/>), or numeric (<see cref="T:System.Int32"/>, <see cref="T:System.Int64"/>, <see cref="T:System.Single"/>, or <see cref="T:System.Double"/>). 
             Fields are optionally stored in the
             index, so that they may be returned with hits on the document.
            
             <para/>
             NOTE: the field type is an <see cref="T:Lucene.Net.Index.IIndexableFieldType"/>.  Making changes
             to the state of the <see cref="T:Lucene.Net.Index.IIndexableFieldType"/> will impact any
             Field it is used in.  It is strongly recommended that no
             changes be made after <see cref="T:Lucene.Net.Documents.Field"/> instantiation.
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_type">
            <summary>
            Field's type
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_name">
            <summary>
            Field's name
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_fieldsData">
            <summary>
            Field's value </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_tokenStream">
            <summary>
            Pre-analyzed <see cref="T:Lucene.Net.Analysis.TokenStream"/> for indexed fields; this is
            separate from <see cref="F:Lucene.Net.Documents.Field.m_fieldsData"/> because you are allowed to
            have both; eg maybe field has a <see cref="T:System.String"/> value but you
            customize how it's tokenized
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.m_boost">
            <summary>
            Field's boost </summary>
            <seealso cref="P:Lucene.Net.Documents.Field.Boost"/>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: creates a field with no initial value.
            Intended only for custom <see cref="T:Lucene.Net.Documents.Field"/> subclasses.
            </summary>
            <param name="name"> field name </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="type"/>
                    is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with <see cref="T:System.IO.TextReader"/> value. </summary>
            <param name="name"> field name </param>
            <param name="reader"> reader value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if <see cref="P:Lucene.Net.Documents.FieldType.IsStored"/> is true, or
                    if <see cref="P:Lucene.Net.Documents.FieldType.IsTokenized"/> is false. </exception>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="type"/>
                    is <c>null</c>, or if the reader is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with <see cref="T:Lucene.Net.Analysis.TokenStream"/> value. </summary>
            <param name="name"> field name </param>
            <param name="tokenStream"> TokenStream value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if <see cref="P:Lucene.Net.Documents.FieldType.IsStored"/> is true, or
                    if <see cref="P:Lucene.Net.Documents.FieldType.IsTokenized"/> is false, or if <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is false. </exception>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="type"/>
                    is <c>null</c>, or if the <paramref name="tokenStream"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],Lucene.Net.Documents.FieldType)">
             <summary>
             Create field with binary value.
            
             <para/>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
             not to change it until you're done with this field.
             </summary>
             <param name="name"> field name </param>
             <param name="value"> byte array pointing to binary content (not copied) </param>
             <param name="type"> field type </param>
             <exception cref="T:System.ArgumentException"> if the <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is true </exception>
             <exception cref="T:System.ArgumentNullException"> the field <paramref name="name"/> is <c>null</c>,
                     or if the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],System.Int32,System.Int32,Lucene.Net.Documents.FieldType)">
             <summary>
             Create field with binary value.
            
             <para/>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
             not to change it until you're done with this field.
             </summary>
             <param name="name"> field name </param>
             <param name="value"> byte array pointing to binary content (not copied) </param>
             <param name="offset"> starting position of the byte array </param>
             <param name="length"> valid length of the byte array </param>
             <param name="type"> field type </param>
             <exception cref="T:System.ArgumentException"> if the <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is true </exception>
             <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>,
                     or the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Documents.FieldType)">
             <summary>
             Create field with binary value.
            
             <para/>NOTE: the provided BytesRef is not copied so be sure
             not to change it until you're done with this field.
             </summary>
             <param name="name"> field name </param>
             <param name="bytes"> BytesRef pointing to binary content (not copied) </param>
             <param name="type"> field type </param>
             <exception cref="T:System.ArgumentException"> if the <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> is true </exception>
             <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>,
                     or the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.FieldType)">
            <summary>
            Create field with <see cref="T:System.String"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> string value </param>
            <param name="type"> field type </param>
            <exception cref="T:System.ArgumentException"> if the field's type is neither indexed() nor stored(),
                    or if indexed() is false but storeTermVectors() is true. </exception>
            <exception cref="T:System.ArgumentNullException"> if either the <paramref name="name"/> or <paramref name="value"/>
                    is <c>null</c>, or if the <paramref name="type"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetStringValue">
            <summary>
            The value of the field as a <see cref="T:System.String"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.IO.TextReader"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/>, <see cref="M:Lucene.Net.Documents.Field.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/> must be set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetReaderValue">
            <summary>
            The value of the field as a <see cref="T:System.IO.TextReader"/>, or <c>null</c>. If <c>null</c>, the <see cref="T:System.String"/> value or
            binary value is used. Exactly one of <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/>, <see cref="M:Lucene.Net.Documents.Field.GetReaderValue"/>, and
            <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/> must be set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.GetTokenStreamValue">
            <summary>
            The <see cref="T:Lucene.Net.Analysis.TokenStream"/> for this field to be used when indexing, or <c>null</c>. If <c>null</c>,
            the <see cref="T:System.IO.TextReader"/> value or <see cref="T:System.String"/> value is analyzed to produce the indexed tokens.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetStringValue(System.String)">
             <summary>
             <para>
             Expert: change the value of this field. This can be used during indexing to
             re-use a single <see cref="T:Lucene.Net.Documents.Field"/> instance to improve indexing speed by avoiding GC
             cost of new'ing and reclaiming <see cref="T:Lucene.Net.Documents.Field"/> instances. Typically a single
             <see cref="T:Lucene.Net.Documents.Document"/> instance is re-used as well. This helps most on small
             documents.
             </para>
            
             <para>
             Each <see cref="T:Lucene.Net.Documents.Field"/> instance should only be used once within a single
             <see cref="T:Lucene.Net.Documents.Document"/> instance. See <a
             href="http://wiki.apache.org/lucene-java/ImproveIndexingSpeed"
             >ImproveIndexingSpeed</a> for details.
             </para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetReaderValue(System.IO.TextReader)">
            <summary>
            Expert: change the value of this field. See 
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetBytesValue(Lucene.Net.Util.BytesRef)">
             <summary>
             Expert: change the value of this field. See
             <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            
             <para/>NOTE: the provided <see cref="T:Lucene.Net.Util.BytesRef"/> is not copied so be sure
             not to change it until you're done with this field.
             </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetBytesValue(System.Byte[])">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetByteValue(System.Byte)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetInt16Value(System.Int16)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetInt32Value(System.Int32)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetInt64Value(System.Int64)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetSingleValue(System.Single)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetDoubleValue(System.Double)">
            <summary>
            Expert: change the value of this field. See
            <see cref="M:Lucene.Net.Documents.Field.SetStringValue(System.String)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.SetTokenStream(Lucene.Net.Analysis.TokenStream)">
            <summary>
            Expert: sets the token stream to be used for indexing and causes
            <see cref="P:Lucene.Net.Documents.FieldType.IsIndexed"/> and <see cref="P:Lucene.Net.Documents.FieldType.IsTokenized"/> to return true. May be combined with stored
            values from <see cref="M:Lucene.Net.Documents.Field.GetStringValue"/> or <see cref="M:Lucene.Net.Documents.Field.GetBinaryValue"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.Name">
            <summary>
            The field's name
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.Boost">
            <summary>
            Gets or sets the boost factor on this field.
            </summary>
            <remarks>The default value is <c>1.0f</c> (no boost).</remarks>
            <exception cref="T:System.ArgumentException"> (setter only) if this field is not indexed,
                    or if it omits norms. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.ToString">
            <summary>
            Prints a <see cref="T:Lucene.Net.Documents.Field"/> for human consumption. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.Field.FieldType">
            <summary>
            Returns the <see cref="T:Lucene.Net.Documents.FieldType"/> for this field. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringTokenStream.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Analysis.TokenStream"/> that returns a <see cref="T:System.String"/> as single token.
            <para/>Warning: Does not initialize the value, you must call
            <see cref="M:Lucene.Net.Documents.Field.StringTokenStream.SetValue(System.String)"/> afterwards!
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.StringTokenStream.SetValue(System.String)">
            <summary>
            Sets the string value. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Store">
            <summary>
            Specifies whether and how a field should be stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.YES">
            <summary>
            Store the original field value in the index. this is useful for short texts
            like a document's title which should be displayed with the results. The
            value is stored in its original form, i.e. no analyzer is used before it is
            stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Store.NO">
            <summary>
            Do not store the field's value in the index. </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.Index">
            <summary>
            Specifies whether and how a field should be indexed. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NO">
            <summary>Do not index the field value. This field can thus not be searched,
            but one can still access its contents provided it is
            <see cref="T:Lucene.Net.Documents.Field.Store">stored</see>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED">
            <summary>Index the tokens produced by running the field's
            value through an <see cref="T:Lucene.Net.Analysis.Analyzer"/>.  This is useful for
            common text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED">
            <summary>Index the field's value without using an <see cref="T:Lucene.Net.Analysis.Analyzer"/>, so it can be searched.
            As no analyzer is used the value will be stored as a single term. This is
            useful for unique Ids like product numbers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED_NO_NORMS">
            <summary>Expert: Index the field's value without an Analyzer,
            and also disable the storing of norms.  Note that you
            can also separately enable/disable norms by setting
            <see cref="P:Lucene.Net.Documents.FieldType.OmitNorms" />.  No norms means that
            index-time field and document boosting and field
            length normalization are disabled.  The benefit is
            less memory usage as norms take up one byte of RAM
            per indexed field for every document in the index,
            during searching.  Note that once you index a given
            field <i>with</i> norms enabled, disabling norms will
            have no effect.  In other words, for this to have the
            above described effect on a field, all instances of
            that field must be indexed with NOT_ANALYZED_NO_NORMS
            from the beginning.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.Index.ANALYZED_NO_NORMS">
            <summary>Expert: Index the tokens produced by running the
            field's value through an Analyzer, and also
            separately disable the storing of norms.  See
            <see cref="F:Lucene.Net.Documents.Field.Index.NOT_ANALYZED_NO_NORMS" /> for what norms are
            and why you may want to disable them.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.Field.TermVector">
            <summary>
            Specifies whether and how a field should have term vectors. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.NO">
            <summary>
            Do not store term vectors. 
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.YES">
            <summary>
            Store the term vectors of each document. A term vector is a list
            of the document's terms and their number of occurrences in that document.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS">
            <summary>
            Store the term vector + token position information
            </summary>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES"/>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS">
            <summary>
            Store the term vector + Token offset information
            </summary>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES"/>
        </member>
        <member name="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS_OFFSETS">
            <summary>
            Store the term vector + Token position and offset information
            </summary>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.YES"/>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.WITH_POSITIONS"/>
            <seealso cref="F:Lucene.Net.Documents.Field.TermVector.WITH_OFFSETS"/>
        </member>
        <member name="M:Lucene.Net.Documents.Field.TranslateFieldType(Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Translates the pre-4.0 enums for specifying how a
            field should be indexed into the 4.0 <see cref="T:Lucene.Net.Documents.FieldType"/>
            approach.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index)">
            <summary>
            Create a field by specifying its <paramref name="name"/>, <paramref name="value"/> and how it will
            be saved in the index. Term vectors will not be stored in the index.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The string to process</param>
            <param name="store">Whether <paramref name="value"/> should be stored in the index</param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="value"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">if the field is neither stored nor indexed</exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store,Lucene.Net.Documents.Field.Index,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Create a field by specifying its <paramref name="name"/>, <paramref name="value"/> and how it will
            be saved in the index.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The string to process</param>
            <param name="store">Whether <paramref name="value"/> should be stored in the index</param>
            <param name="index">Whether the field should be indexed, and if so, if it should
            be tokenized before indexing</param>
            <param name="termVector">Whether term vector should be stored</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="value"/> is <c>null</c></exception>
            <exception cref="T:System.ArgumentException">in any of the following situations:
            <list type="bullet">
                <item>the field is neither stored nor indexed</item>
                <item>the field is not indexed but termVector is <see cref="F:Lucene.Net.Documents.Field.TermVector.YES"/></item>
            </list>
            </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader)">
            <summary>
            Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored.  The <see cref="T:System.IO.TextReader"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:System.IO.TextReader"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="reader">The reader with the content</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="reader"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.IO.TextReader,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  The <see cref="T:System.IO.TextReader"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:System.IO.TextReader"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="reader">The reader with the content</param>
            <param name="termVector">Whether term vector should be stored</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="reader"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Create a tokenized and indexed field that is not stored. Term vectors will
            not be stored. This is useful for pre-analyzed fields.
            The <see cref="T:Lucene.Net.Analysis.TokenStream"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:Lucene.Net.Analysis.TokenStream"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="tokenStream">The <see cref="T:Lucene.Net.Analysis.TokenStream"/> with the content</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="tokenStream"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,Lucene.Net.Analysis.TokenStream,Lucene.Net.Documents.Field.TermVector)">
            <summary>
            Create a tokenized and indexed field that is not stored, optionally with 
            storing term vectors.  This is useful for pre-analyzed fields.
            The <see cref="T:Lucene.Net.Analysis.TokenStream"/> is read only when the <see cref="T:Lucene.Net.Documents.Document"/> is added to the index,
            i.e. you may not close the <see cref="T:Lucene.Net.Analysis.TokenStream"/> until <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
            has been called.
            </summary>
            <param name="name">The name of the field</param>
            <param name="tokenStream">The <see cref="T:Lucene.Net.Analysis.TokenStream"/> with the content</param>
            <param name="termVector">Whether term vector should be stored</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="name"/> or <paramref name="tokenStream"/> is <c>null</c></exception>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[])">
            <summary>
            Create a stored field with binary value. Optionally the value may be compressed.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The binary value</param>
        </member>
        <member name="M:Lucene.Net.Documents.Field.#ctor(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a stored field with binary value. Optionally the value may be compressed.
            </summary>
            <param name="name">The name of the field</param>
            <param name="value">The binary value</param>
            <param name="offset">Starting offset in value where this <see cref="T:Lucene.Net.Documents.Field"/>'s bytes are</param>
            <param name="length">Number of bytes to use for this <see cref="T:Lucene.Net.Documents.Field"/>, starting at offset</param>
        </member>
        <member name="T:Lucene.Net.Documents.FieldExtensions">
            <summary>
            LUCENENET specific extension methods to add functionality to enumerations
            that mimic Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldExtensions.ToTermVector(System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Get the best representation of a TermVector given the flags.
            </summary>
        </member>
        <member name="T:Lucene.Net.Documents.FieldType">
            <summary>
            Describes the properties of a field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.#ctor(Lucene.Net.Documents.FieldType)">
            <summary>
            Create a new mutable <see cref="T:Lucene.Net.Documents.FieldType"/> with all of the properties from <paramref name="ref"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.#ctor">
            <summary>
            Create a new <see cref="T:Lucene.Net.Documents.FieldType"/> with default properties.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.Freeze">
            <summary>
            Prevents future changes. Note, it is recommended that this is called once
            the <see cref="T:Lucene.Net.Documents.FieldType"/>'s properties have been set, to prevent unintentional state
            changes.
            </summary>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IsIndexed">
            <summary>
            Set to <c>true</c> to index (invert) this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IsStored">
            <summary>
            Set to <c>true</c> to store this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IsTokenized">
            <summary>
            Set to <c>true</c> to tokenize this field's contents via the
            configured <see cref="T:Lucene.Net.Analysis.Analyzer"/>. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectors">
            <summary>
            Set to <c>true</c> if this field's indexed form should be also stored
            into term vectors. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectorOffsets">
            <summary>
            Set to <c>true</c> to also store token character offsets into the term
            vector for this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectorPositions">
            <summary>
            Set to <c>true</c> to also store token positions into the term
            vector for this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.StoreTermVectorPayloads">
            <summary>
            Set to <c>true</c> to also store token payloads into the term
            vector for this field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.OmitNorms">
            <summary>
            Set to <c>true</c> to omit normalization values for the field. The default is <c>false</c>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.IndexOptions">
            <summary>
            Sets the indexing options for the field. 
            <para/>
            The default is <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS"/>.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.NumericType">
            <summary>
            Specifies the field's numeric type, or set to <c>null</c> if the field has no numeric type.
            If non-null then the field's value will be indexed numerically so that 
            <see cref="T:Lucene.Net.Search.NumericRangeQuery"/> can be used at search time.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep">
            <summary>
            Sets the numeric precision step for the field.
            <para/>
            This has no effect if <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> returns <see cref="F:Lucene.Net.Documents.NumericType.NONE"/>.
            <para/>
            The default is <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/>.
            </summary>
            <exception cref="T:System.ArgumentException"> if precisionStep is less than 1. </exception>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.FieldType.ToString">
            <summary>
            Prints a <see cref="T:Lucene.Net.Documents.FieldType"/> for human consumption. </summary>
        </member>
        <member name="P:Lucene.Net.Documents.FieldType.DocValueType">
            <summary>
            Sets the field's <see cref="T:Lucene.Net.Index.DocValuesType"/>, or set to <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> if no <see cref="T:Lucene.Net.Index.DocValues"/> should be stored.
            <para/>
            The default is <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> (no <see cref="T:Lucene.Net.Index.DocValues"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this <see cref="T:Lucene.Net.Documents.FieldType"/> is frozen against
                    future modifications. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.NumericType">
            <summary>
            Data type of the numeric value
            @since 3.2
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.NONE">
            <summary>
            No numeric type will be used.
            <para/>
            NOTE: This is the same as setting to <c>null</c> in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.INT32">
            <summary>
            32-bit integer numeric type
            <para/>
            NOTE: This was INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.INT64">
            <summary>
            64-bit long numeric type
            <para/>
            NOTE: This was LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.SINGLE">
            <summary>
            32-bit float numeric type
            <para/>
            NOTE: This was FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericType.DOUBLE">
            <summary>
            64-bit double numeric type </summary>
        </member>
        <member name="T:Lucene.Net.Documents.SingleDocValuesField">
            <summary>
            Syntactic sugar for encoding floats as <see cref="T:Lucene.Net.Index.NumericDocValues"/>
            via <see cref="M:Lucene.Net.Support.Number.SingleToRawInt32Bits(System.Single)"/>.
            <para>
            Per-document floating point values can be retrieved via
            <seealso cref="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)"/>.</para>
            <para>
            <b>NOTE</b>: In most all cases this will be rather inefficient,
            requiring four bytes per document. Consider encoding floating
            point values yourself with only as much precision as you require.
            </para>
            <para>
            NOTE: This was FloatDocValuesField in Lucene
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SingleDocValuesField.#ctor(System.String,System.Single)">
            <summary>
            Creates a new DocValues field with the specified 32-bit <see cref="T:System.Single"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field name is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SingleField">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Single"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
             document.Add(new SingleField(name, 6.0F, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.SingleField"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 FloatField field = new SingleField(name, 0.0F, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents) 
                 {
                     ...
                     field.SetSingleValue(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <see cref="T:Lucene.Net.Documents.Int32Field"/>, <seealso cref="T:Lucene.Net.Documents.Int64Field"/>, 
             <see cref="T:Lucene.Net.Documents.DoubleField"/>.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.SingleField"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.SingleField"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.SINGLE"/>. <see cref="T:Lucene.Net.Documents.SingleField"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.SingleField"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.SingleField"/>.</para>
            
             <para>A <see cref="T:Lucene.Net.Documents.SingleField"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the 
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>
             or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/>
             directly, when indexing numbers. This
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
             <para>
             NOTE: This was FloatField in Lucene
             </para>
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SingleField.TYPE_NOT_STORED">
            <summary>
            Type for a <see cref="T:Lucene.Net.Documents.SingleField"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SingleField.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.SingleField"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SingleField.#ctor(System.String,System.Single,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.SingleField"/> with the provided value
            and default <c>precisionStep</c> <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/>
            (4).
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.SingleField.#ctor(System.String,System.Single,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Single"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.SINGLE"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException">if the field type does not have a <see cref="F:Lucene.Net.Documents.NumericType.SINGLE"/> <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/></exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int32DocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:System.Int32"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new Int32DocValuesField(name, 22));
             </code>
            
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance. 
             <para/>
             NOTE: This was IntDocValuesField in Lucene
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.Int32DocValuesField.#ctor(System.String,System.Int32)">
            <summary>
            Creates a new DocValues field with the specified 32-bit <see cref="T:System.Int32"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int32Field">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Int32"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
                 document.Add(new Int32Field(name, 6, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.Int32Field"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 Int32Field field = new Int32Field(name, 6, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents) 
                 {
                     ...
                     field.SetInt32Value(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <see cref="T:Lucene.Net.Documents.Int64Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/>, 
             <see cref="T:Lucene.Net.Documents.DoubleField"/>.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.Int32Field"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.Int32Field"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.INT32"/>. <see cref="T:Lucene.Net.Documents.Int32Field"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.Int32Field"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.Int32Field"/>.</para>
            
             <para>An <see cref="T:Lucene.Net.Documents.Int32Field"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the 
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/> directly, 
             when indexing numbers. this
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
             <para>
             NOTE: This was IntField in Lucene
             </para>
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int32Field.TYPE_NOT_STORED">
            <summary>
            Type for an <see cref="T:Lucene.Net.Documents.Int32Field"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int32Field.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.Int32Field"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Int32Field.#ctor(System.String,System.Int32,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.Int32Field"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Int32Field.#ctor(System.String,System.Int32,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the 
            <see cref="T:Lucene.Net.Documents.FieldType"/>.
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 32-bit <see cref="T:System.Int32"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.INT32"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException">if the field type does not have a 
                    <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> of <see cref="F:Lucene.Net.Documents.NumericType.INT32"/> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int64DocValuesField">
             <summary>
             <para>
             Field that stores a per-document <see cref="T:System.Int64"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new Int64DocValuesField(name, 22L));
             </code></para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             <para>
             NOTE: This was LongDocValuesField in Lucene
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.Int64DocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new DocValues field with the specified 64-bit <see cref="T:System.Int64"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int64Field">
             <summary>
             <para>
             Field that indexes <see cref="T:System.Int64"/> values
             for efficient range filtering and sorting. Here's an example usage:
            
             <code>
             document.Add(new Int64Field(name, 6L, Field.Store.NO));
             </code>
            
             For optimal performance, re-use the <see cref="T:Lucene.Net.Documents.Int64Field"/> and
             <see cref="T:Lucene.Net.Documents.Document"/> instance for more than one document:
            
             <code>
                 Int64Field field = new Int64Field(name, 0L, Field.Store.NO);
                 Document document = new Document();
                 document.Add(field);
            
                 for (all documents) {
                     ...
                     field.SetInt64Value(value)
                     writer.AddDocument(document);
                     ...
                 }
             </code>
            
             See also <see cref="T:Lucene.Net.Documents.Int32Field"/>, <see cref="T:Lucene.Net.Documents.SingleField"/>, 
             <see cref="T:Lucene.Net.Documents.DoubleField"/>.
             </para>
             
             <para>
             Any type that can be converted to long can also be
             indexed.  For example, date/time values represented by a
             <see cref="T:System.DateTime"/> can be translated into a long
             value using the <see cref="P:System.DateTime.Ticks"/> property.  If you
             don't need millisecond precision, you can quantize the
             value, either by dividing the result of
             <see cref="P:System.DateTime.Ticks"/> or using the separate getters
             (for year, month, etc.) to construct an <see cref="T:System.Int32"/> or
             <see cref="T:System.Int64"/> value.</para>
            
             <para>To perform range querying or filtering against a
             <see cref="T:Lucene.Net.Documents.Int64Field"/>, use <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or 
             <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.  To sort according to a
             <see cref="T:Lucene.Net.Documents.Int64Field"/>, use the normal numeric sort types, eg
             <see cref="F:Lucene.Net.Search.SortFieldType.INT64"/>. <see cref="T:Lucene.Net.Documents.Int64Field"/>
             values can also be loaded directly from <see cref="T:Lucene.Net.Search.IFieldCache"/>.</para>
            
             <para>You may add the same field name as an <see cref="T:Lucene.Net.Documents.Int64Field"/> to
             the same document more than once.  Range querying and
             filtering will be the logical OR of all values; so a range query
             will hit all documents that have at least one value in
             the range. However sort behavior is not defined.  If you need to sort,
             you should separately index a single-valued <see cref="T:Lucene.Net.Documents.Int64Field"/>.</para>
            
             <para>An <see cref="T:Lucene.Net.Documents.Int64Field"/> will consume somewhat more disk space
             in the index than an ordinary single-valued field.
             However, for a typical index that includes substantial
             textual content per document, this increase will likely
             be in the noise. </para>
            
             <para>Within Lucene, each numeric value is indexed as a
             <em>trie</em> structure, where each term is logically
             assigned to larger and larger pre-defined brackets (which
             are simply lower-precision representations of the value).
             The step size between each successive bracket is called the
             <c>precisionStep</c>, measured in bits.  Smaller
             <c>precisionStep</c> values result in larger number
             of brackets, which consumes more disk space in the index
             but may result in faster range search performance.  The
             default value, 4, was selected for a reasonable tradeoff
             of disk space consumption versus performance.  You can
             create a custom <see cref="T:Lucene.Net.Documents.FieldType"/> and invoke the 
             <see cref="P:Lucene.Net.Documents.FieldType.NumericPrecisionStep"/> setter if you'd
             like to change the value.  Note that you must also
             specify a congruent value when creating 
             <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/> or <see cref="T:Lucene.Net.Search.NumericRangeFilter`1"/>.
             For low cardinality fields larger precision steps are good.
             If the cardinality is &lt; 100, it is fair
             to use <see cref="F:System.Int32.MaxValue"/>, which produces one
             term per value.</para>
            
             <para>For more information on the internals of numeric trie
             indexing, including the <see cref="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep"/> <a
             href="../search/NumericRangeQuery.html#precisionStepDesc"><c>precisionStep</c></a>
             configuration, see <see cref="T:Lucene.Net.Search.NumericRangeQuery`1"/>. The format of
             indexed values is described in <see cref="T:Lucene.Net.Util.NumericUtils"/>.</para>
            
             <para>If you only need to sort by numeric value, and never
             run range querying/filtering, you can index using a
             <c>precisionStep</c> of <see cref="F:System.Int32.MaxValue"/>.
             this will minimize disk space consumed. </para>
            
             <para>More advanced users can instead use 
             <see cref="T:Lucene.Net.Analysis.NumericTokenStream"/> directly, 
             when indexing numbers. this
             class is a wrapper around this token stream type for
             easier, more intuitive usage.</para>
             <para>
             NOTE: This was LongField in Lucene
             </para>
             @since 2.9
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int64Field.TYPE_NOT_STORED">
            <summary>
            Type for a <see cref="T:Lucene.Net.Documents.Int64Field"/> that is not stored:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.Int64Field.TYPE_STORED">
            <summary>
            Type for a stored <see cref="T:Lucene.Net.Documents.Int64Field"/>:
            normalization factors, frequencies, and positions are omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.Int64Field.#ctor(System.String,System.Int64,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a stored or un-stored <see cref="T:Lucene.Net.Documents.Int64Field"/> with the provided value
            and default <c>precisionStep</c> 
            <see cref="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT"/> (4). 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.Int64Field.#ctor(System.String,System.Int64,Lucene.Net.Documents.FieldType)">
            <summary>
            Expert: allows you to customize the <see cref="T:Lucene.Net.Documents.FieldType"/>. 
            </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <param name="type"> customized field type: must have <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/>
                    of <see cref="F:Lucene.Net.Documents.NumericType.INT64"/>. </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="type"/> is <see cref="F:Lucene.Net.Documents.NumericType.NONE"/> </exception>
            <exception cref="T:System.ArgumentException"> if the field type does not have a 
            <see cref="P:Lucene.Net.Documents.FieldType.NumericType"/> of <see cref="F:Lucene.Net.Documents.NumericType.INT64"/> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.NumericDocValuesField">
             <summary>
             Field that stores a per-document <see cref="T:System.Int64"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new NumericDocValuesField(name, 22L));
             </code>
            
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.NumericDocValuesField.TYPE">
            <summary>
            Type for numeric <see cref="T:Lucene.Net.Index.DocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.NumericDocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 64-bit <see cref="T:System.Int64"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.PackedInt64DocValuesField">
             <summary>
             <para>
             Field that stores a per-document <see cref="T:System.Int64"/> value
             for scoring, sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new PackedInt64DocValuesField(name, 22L));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </para>
             <para>
             NOTE: This was PackedLongDocValuesField in Lucene
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.PackedInt64DocValuesField.#ctor(System.String,System.Int64)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified <see cref="T:System.Int64"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 64-bit <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.Int16DocValuesField">
             <summary>
             <para>
             Field that stores a per-document <see cref="T:System.Int16"/> value for scoring,
             sorting or value retrieval. Here's an example usage:
            
             <code>
                 document.Add(new Int16DocValuesField(name, (short) 22));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </para>
             <para>
             NOTE: This was ShortDocValuesField in Lucene
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>
        </member>
        <member name="M:Lucene.Net.Documents.Int16DocValuesField.#ctor(System.String,System.Int16)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocValues"/> field with the specified 16-bit <see cref="T:System.Int16"/> value </summary>
            <param name="name"> field name </param>
            <param name="value"> 16-bit <see cref="T:System.Int16"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SortedBytesDocValuesField">
             <summary>
             <para>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value, indexed for
             sorting.  Here's an example usage:
            
             <code>
                 document.Add(new SortedBytesDocValuesField(name, new BytesRef("hello")));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.
             </para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.SortedDocValuesField"/>
        </member>
        <member name="F:Lucene.Net.Documents.SortedBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SortedBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable-length sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.SortedBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SortedDocValuesField">
             <summary>
             <para>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value, indexed for
             sorting.  Here's an example usage:
            
             <code>
                 document.Add(new SortedDocValuesField(name, new BytesRef("hello")));
             </code></para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SortedDocValuesField.TYPE">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.SortedSetDocValuesField">
             <summary>
             <para>
             Field that stores
             a set of per-document <see cref="T:Lucene.Net.Util.BytesRef"/> values, indexed for
             faceting,grouping,joining.  Here's an example usage:
            
             <code>
                 document.Add(new SortedSetDocValuesField(name, new BytesRef("hello")));
                 document.Add(new SortedSetDocValuesField(name, new BytesRef("world")));
             </code>
             </para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Documents.SortedSetDocValuesField.TYPE">
            <summary>
            Type for sorted bytes <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.SortedSetDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new sorted <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StoredField">
            <summary>
            A field whose value is stored so that 
            <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> and <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> will
            return the field and its value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StoredField.TYPE">
            <summary>
            Type for a stored-only field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Byte[])">
            <summary>
            Create a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="name"> field name </param>
            <param name="value"> byte array pointing to binary content (not copied) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Create a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:byte[]"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Byte"/> array pointing to binary content (not copied) </param>
            <param name="offset"> starting position of the byte array </param>
            <param name="length"> valid length of the byte array </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a stored-only field with the given binary value.
            <para>NOTE: the provided <see cref="T:Lucene.Net.Util.BytesRef"/> is not copied so be sure
            not to change it until you're done with this field.</para>
            </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:Lucene.Net.Util.BytesRef"/> pointing to binary content (not copied) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.String)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.String"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Int32)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Int32"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Int32"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Single)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Single"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Single"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Int64)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Int64"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Int64"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StoredField.#ctor(System.String,System.Double)">
            <summary>
            Create a stored-only field with the given <see cref="T:System.Double"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.Double"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StraightBytesDocValuesField">
             <summary>
             <para>
             Field that stores
             a per-document <see cref="T:Lucene.Net.Util.BytesRef"/> value.  If values may be shared it's
             better to use <see cref="T:Lucene.Net.Documents.SortedDocValuesField"/>.  Here's an example usage:
            
             <code>
                 document.Add(new StraightBytesDocValuesField(name, new BytesRef("hello")));
             </code></para>
            
             <para>
             If you also need to store the value, you should add a
             separate <see cref="T:Lucene.Net.Documents.StoredField"/> instance.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>
        </member>
        <member name="F:Lucene.Net.Documents.StraightBytesDocValuesField.TYPE_FIXED_LEN">
            <summary>
            Type for direct bytes <see cref="T:Lucene.Net.Index.DocValues"/>: all with the same length
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StraightBytesDocValuesField.TYPE_VAR_LEN">
            <summary>
            Type for direct bytes <see cref="T:Lucene.Net.Index.DocValues"/>: can have variable lengths
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StraightBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Create a new fixed or variable length <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.StraightBytesDocValuesField.#ctor(System.String,Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            Create a new fixed or variable length direct <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
            <param name="name"> field name </param>
            <param name="bytes"> binary content </param>
            <param name="isFixedLength"> (ignored) </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="T:Lucene.Net.Documents.StringField">
            <summary>
            A field that is indexed but not tokenized: the entire
            <see cref="T:System.String"/> value is indexed as a single token.  For example
            this might be used for a 'country' field or an 'id'
            field, or any field that you intend to use for sorting
            or access through the field cache.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StringField.TYPE_NOT_STORED">
            <summary>
            Indexed, not tokenized, omits norms, indexes
            <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>, not stored.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.StringField.TYPE_STORED">
            <summary>
            Indexed, not tokenized, omits norms, indexes
            <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>, stored
            </summary>
        </member>
        <member name="M:Lucene.Net.Documents.StringField.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Documents.StringField"/> (a field that is indexed but not tokenized)
            </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <param name="stored"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Documents.TextField">
            <summary>
            A field that is indexed and tokenized, without term
            vectors.  For example this would be used on a 'body'
            field, that contains the bulk of a document's text.
            </summary>
        </member>
        <member name="F:Lucene.Net.Documents.TextField.TYPE_NOT_STORED">
            <summary>
            Indexed, tokenized, not stored. </summary>
        </member>
        <member name="F:Lucene.Net.Documents.TextField.TYPE_STORED">
            <summary>
            Indexed, tokenized, stored. </summary>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,System.IO.TextReader)">
            <summary>
            Creates a new un-stored <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:System.IO.TextReader"/> value. </summary>
            <param name="name"> field name </param>
            <param name="reader"> <see cref="T:System.IO.TextReader"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="reader"/> is <c>null</c> </exception>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,System.String,Lucene.Net.Documents.Field.Store)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:System.String"/> value. </summary>
            <param name="name"> field name </param>
            <param name="value"> <see cref="T:System.String"/> value </param>
            <param name="store"> <see cref="F:Lucene.Net.Documents.Field.Store.YES"/> if the content should also be stored </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="value"/> is <c>null</c>. </exception>
        </member>
        <member name="M:Lucene.Net.Documents.TextField.#ctor(System.String,Lucene.Net.Analysis.TokenStream)">
            <summary>
            Creates a new un-stored <see cref="T:Lucene.Net.Documents.TextField"/> with <see cref="T:Lucene.Net.Analysis.TokenStream"/> value. </summary>
            <param name="name"> field name </param>
            <param name="stream"> <see cref="T:Lucene.Net.Analysis.TokenStream"/> value </param>
            <exception cref="T:System.ArgumentNullException"> if the field <paramref name="name"/> or <paramref name="stream"/> is <c>null</c>. </exception>
        </member>
        <member name="T:Lucene.Net.Index.AtomicReader">
             <summary>
             <see cref="T:Lucene.Net.Index.AtomicReader"/> is an abstract class, providing an interface for accessing an
             index.  Search of an index is done entirely through this abstract interface,
             so that any subclass which implements it is searchable. <see cref="T:Lucene.Net.Index.IndexReader"/>s implemented
             by this subclass do not consist of several sub-readers,
             they are atomic. They support retrieval of stored fields, doc values, terms,
             and postings.
            
             <para/>For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/>
             <b>NOTE</b>: <see cref="T:Lucene.Net.Index.IndexReader"/>
             instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.AtomicContext">
            <summary>
            LUCENENET specific propety that allows access to
            the context as <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>,
            which prevents the need to cast.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.HasNorms(System.String)">
            <summary>
            Returns true if there are norms stored for this <paramref name="field"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.Fields">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.Fields"/> for this reader.
            this property may return <c>null</c> if the reader has no
            postings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.TotalTermFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the number of documents containing the <paramref name="term"/>. 
            This method returns 0 if the term or
            field does not exist. This method does not take into
            account deleted documents that have not yet been merged
            away.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetTerms(System.String)">
            <summary>
            This may return <c>null</c> if the field does not exist. </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetTermDocsEnum(Lucene.Net.Index.Term)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsEnum"/> for the specified term.
            This will return <c>null</c> if either the field or
            term does not exist.
            </summary>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)"/>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetTermPositionsEnum(Lucene.Net.Index.Term)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the specified
            term. This will return <c>null</c> if the
            field or term does not exist or positions weren't indexed. </summary>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum)"/>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetNumericDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.NumericDocValues"/> for this field, or
            null if no <see cref="T:Lucene.Net.Index.NumericDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetBinaryDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.BinaryDocValues"/> for this field, or
            <c>null</c> if no <see cref="T:Lucene.Net.Index.BinaryDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetSortedDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.SortedDocValues"/> for this field, or
            <c>null</c> if no <see cref="T:Lucene.Net.Index.SortedDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetSortedSetDocValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> for this field, or
            <c>null</c> if no <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> were indexed for
            this field. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetDocsWithField(System.String)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> at the size of <c>reader.MaxDoc</c>,
            with turned on bits for each docid that does have a value for this field,
            or <c>null</c> if no <see cref="T:Lucene.Net.Index.DocValues"/> were indexed for this field. The
            returned instance should only be used by a single thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.GetNormValues(System.String)">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.NumericDocValues"/> representing norms
            for this field, or <c>null</c> if no <see cref="T:Lucene.Net.Index.NumericDocValues"/>
            were indexed. The returned instance should only be
            used by a single thread.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.FieldInfos">
            <summary>
            Get the <see cref="T:Lucene.Net.Index.FieldInfos"/> describing all fields in
            this reader.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReader.LiveDocs">
            <summary>
            Returns the <see cref="T:Lucene.Net.Util.IBits"/> representing live (not
            deleted) docs.  A set bit indicates the doc ID has not
            been deleted.  If this method returns <c>null</c> it means
            there are no deleted documents (all documents are
            live).
            <para/>
            The returned instance has been safely published for
            use by multiple threads without additional
            synchronization.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReader.CheckIntegrity">
            <summary>
            Checks consistency of this reader.
            <para/>
            Note that this may be costly in terms of I/O, e.g.
            may involve computing a checksum value against large data files.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.AtomicReaderContext">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexReaderContext"/> for <see cref="T:Lucene.Net.Index.AtomicReader"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReaderContext.Ord">
            <summary>
            The readers ord in the top-level's leaves array </summary>
        </member>
        <member name="P:Lucene.Net.Index.AtomicReaderContext.DocBase">
            <summary>
            The readers absolute doc base </summary>
        </member>
        <member name="M:Lucene.Net.Index.AtomicReaderContext.#ctor(Lucene.Net.Index.CompositeReaderContext,Lucene.Net.Index.AtomicReader,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.AutomatonTermsEnum">
            <summary>
            A <see cref="T:Lucene.Net.Index.FilteredTermsEnum"/> that enumerates terms based upon what is accepted by a
            DFA.
            <para/>
            The algorithm is such:
            <list type="number">
                <item>As long as matches are successful, keep reading sequentially.</item>
                <item>When a match fails, skip to the next string in lexicographic order that
                    does not enter a reject state.</item>
            </list>
            <para>
            The algorithm does not attempt to actually skip to the next string that is
            completely accepted. this is not possible when the language accepted by the
            FSM is not finite (i.e. * operator).
            </para>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.Automaton.CompiledAutomaton)">
            <summary>
            Construct an enumerator based upon an automaton, enumerating the specified
            field, working on a supplied <see cref="T:Lucene.Net.Index.TermsEnum"/>
            <para/>
            @lucene.experimental
            </summary>
            <param name="tenum"> TermsEnum </param>
            <param name="compiled"> CompiledAutomaton </param>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <c>true</c> if the term matches the automaton. Also stashes away the term
            to assist with smart enumeration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.SetLinear(System.Int32)">
            <summary>
            Sets the enum to operate in linear fashion, as we have found
            a looping transition at position: we set an upper bound and
            act like a <see cref="T:Lucene.Net.Search.TermRangeQuery"/> for this portion of the term space.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.NextString">
            <summary>
            Increments the byte buffer to the next string in binary order after s that will not put
            the machine into a reject state. If such a string does not exist, returns
            <c>false</c>.
            <para/>
            The correctness of this method depends upon the automaton being deterministic,
            and having no transitions to dead states.
            </summary>
            <returns> <c>true</c> if more possible solutions exist for the DFA </returns>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.NextString(System.Int32,System.Int32)">
            <summary>
            Returns the next string in lexicographic order that will not put
            the machine into a reject state.
            <para/>
            This method traverses the DFA from the given position in the string,
            starting at the given state.
            <para/>
            If this cannot satisfy the machine, returns <c>false</c>. This method will
            walk the minimal path, in lexicographic order, as long as possible.
            <para/>
            If this method returns <c>false</c>, then there might still be more solutions,
            it is necessary to backtrack to find out.
            </summary>
            <param name="state"> current non-reject state </param>
            <param name="position"> useful portion of the string </param>
            <returns> <c>true</c> if more possible solutions exist for the DFA from this
                    position </returns>
        </member>
        <member name="M:Lucene.Net.Index.AutomatonTermsEnum.Backtrack(System.Int32)">
            <summary>
            Attempts to backtrack thru the string after encountering a dead end
            at some given position. Returns <c>false</c> if no more possible strings
            can match.
            </summary>
            <param name="position"> current position in the input string </param>
            <returns> position &gt;=0 if more possible solutions exist for the DFA </returns>
        </member>
        <member name="T:Lucene.Net.Index.BaseCompositeReader`1">
             <summary>
             Base class for implementing <see cref="T:Lucene.Net.Index.CompositeReader"/>s based on an array
             of sub-readers. The implementing class has to add code for
             correctly refcounting and closing the sub-readers.
            
             <para/>User code will most likely use <see cref="T:Lucene.Net.Index.MultiReader"/> to build a
             composite reader on a set of sub-readers (like several
             <see cref="T:Lucene.Net.Index.DirectoryReader"/>s).
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/><b>NOTE</b>: 
             <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             <para/>
             @lucene.internal
             </summary>
             <seealso cref="T:Lucene.Net.Index.MultiReader"/>
        </member>
        <member name="F:Lucene.Net.Index.BaseCompositeReader`1.subReadersList">
            <summary>
            List view solely for <see cref="M:Lucene.Net.Index.BaseCompositeReader`1.GetSequentialSubReaders"/>,
            for effectiveness the array is used internally.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.#ctor(`0[])">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Index.BaseCompositeReader`1"/> on the given <paramref name="subReaders"/>. </summary>
            <param name="subReaders"> the wrapped sub-readers. This array is returned by
            <see cref="M:Lucene.Net.Index.BaseCompositeReader`1.GetSequentialSubReaders"/> and used to resolve the correct
            subreader for docID-based methods. <b>Please note:</b> this array is <b>not</b>
            cloned and not protected for modification, the subclass is responsible
            to do this. </param>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.ReaderIndex(System.Int32)">
            <summary>
            Helper method for subclasses to get the corresponding reader for a doc ID </summary>
        </member>
        <member name="M:Lucene.Net.Index.BaseCompositeReader`1.ReaderBase(System.Int32)">
            <summary>
            Helper method for subclasses to get the docBase of the given sub-reader index. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValues">
            <summary>
            A per-document <see cref="T:byte[]"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BinaryDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BinaryDocValues.Get(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Lookup the value for document. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValuesFieldUpdates">
            <summary>
            A <see cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/> which holds updates of documents, of a single
            <see cref="T:Lucene.Net.Documents.BinaryDocValuesField"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.BinaryDocValuesWriter">
            <summary>
            Buffers up pending <see cref="T:byte[]"/> per doc, then flushes when
            segment flushes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.BinaryDocValuesWriter.MAX_LENGTH">
            <summary>
            Maximum length for a binary field. </summary>
        </member>
        <member name="T:Lucene.Net.Index.BitsSlice">
            <summary>
            Exposes a slice of an existing <see cref="T:Lucene.Net.Util.IBits"/> as a new <see cref="T:Lucene.Net.Util.IBits"/>.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.BufferedUpdates">
            <summary>
            Holds buffered deletes and updates, by docID, term or query for a
            single segment. this is used to hold buffered pending
            deletes and updates against the to-be-flushed segment.  Once the
            deletes and updates are pushed (on flush in <see cref="T:Lucene.Net.Index.DocumentsWriter"/>), they
            are converted to a FrozenDeletes instance.
            <para/>
            NOTE: instances of this class are accessed either via a private
            instance on <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>, or via sync'd code by
            <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.BufferedUpdates.MAX_INT32">
            <summary>
            NOTE: This was MAX_INT in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.BufferedUpdatesStream">
            <summary>
            Tracks the stream of BufferedDeletes.
            When <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> flushes, its buffered
            deletes and updates are appended to this stream.  We later
            apply them (resolve them to the actual
            docIDs, per segment) when a merge is started
            (only to the to-be-merged segments).  We
            also apply to all segments when NRT reader is pulled,
            commit/close is called, or when too many deletes or  updates are
            buffered and must be flushed (by RAM usage or by count).
            <para/>
            Each packet is assigned a generation, and each flushed or
            merged segment is also assigned a generation, so we can
            track which BufferedDeletes packets to apply to any given
            segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BufferedUpdatesStream.Push(Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Appends a new packet of buffered deletes to the stream,
            setting its generation:
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BufferedUpdatesStream.ApplyDeletesAndUpdates(Lucene.Net.Index.IndexWriter.ReaderPool,System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Resolves the buffered deleted Term/Query/docIDs, into
            actual deleted docIDs in the liveDocs <see cref="T:Lucene.Net.Util.IMutableBits"/> for
            each <see cref="T:Lucene.Net.Index.SegmentReader"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.BufferedUpdatesStream.Prune(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Removes any BufferedDeletes that we no longer need to
            store because all segments in the index have had the
            deletes applied.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ByteSliceReader">
            <summary>
            <see cref="T:Lucene.Net.Store.IndexInput"/> that knows how to read the byte slices written
            by Posting and PostingVector. We read the bytes in
            each slice until we hit the end of that slice at which
            point we read the forwarding address of the next slice
            and then jump to it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ByteSliceWriter">
            <summary>
            Class to write byte streams into slices of shared
            <see cref="T:byte[]"/>.  This is used by <see cref="T:Lucene.Net.Index.DocumentsWriter"/> to hold the
            posting list for many terms in RAM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ByteSliceWriter.Init(System.Int32)">
            <summary>
            Set up the writer to write at address.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ByteSliceWriter.WriteByte(System.Byte)">
            <summary>
            Write byte into byte slice stream </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex">
             <summary>
             Basic tool and API to check the health of an index and
             write a new segments file that removes reference to
             problematic segments.
            
             <para/>As this tool checks every byte in the index, on a large
             index it can take quite a long time to run.
            
             <para/>
             Please make a complete backup of your
             index before using this to fix your index!
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status">
            <summary>
            Returned from <see cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex"/> detailing the health and status of the index.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.Clean">
            <summary>
            True if no problems were found with the index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.MissingSegments">
            <summary>
            True if we were unable to locate and load the segments_N file. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.CantOpenSegments">
            <summary>
            True if we were unable to open the segments_N file. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.MissingSegmentVersion">
            <summary>
            True if we were unable to read the version number from segments_N file. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentsFileName">
            <summary>
            Name of latest segments_N file in the index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.NumSegments">
            <summary>
            Number of segments in the index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentsChecked">
            <summary>
            Empty unless you passed specific segments list to check as optional 3rd argument. </summary>
            <seealso cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex(System.Collections.Generic.IList{System.String})"/>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.ToolOutOfDate">
            <summary>
            True if the index was created with a newer version of Lucene than the <see cref="T:Lucene.Net.Index.CheckIndex"/> tool. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfos">
            <summary>
            List of <see cref="T:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus"/> instances, detailing status of each segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.Dir">
            <summary>
            <see cref="T:Lucene.Net.Store.Directory"/> index is in. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.NewSegments">
            <summary>
            <see cref="T:Lucene.Net.Index.SegmentInfos"/> instance containing only segments that
            had no problems (this is used with the <see cref="M:Lucene.Net.Index.CheckIndex.FixIndex(Lucene.Net.Index.CheckIndex.Status)"/>
            method to repair the index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TotLoseDocCount">
            <summary>
            How many documents will be lost to bad segments. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.NumBadSegments">
            <summary>
            How many bad segments were found. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.Partial">
            <summary>
            True if we checked only specific segments 
            (<see cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex(System.Collections.Generic.IList{System.String})"/> was called with non-null
            argument).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.MaxSegmentName">
            <summary>
            The greatest segment name. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.ValidCounter">
            <summary>
            Whether the <see cref="P:Lucene.Net.Index.SegmentInfos.Counter"/> is greater than any of the segments' names. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.UserData">
            <summary>
            Holds the userData of the last commit in the index </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus">
            <summary>
            Holds the status of each segment in the index.
            See <see cref="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfos"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Name">
            <summary>
            Name of the segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Codec">
            <summary>
            Codec used to read this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocCount">
            <summary>
            Document count (does not take deletions into account). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Compound">
            <summary>
            True if segment is compound file format. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumFiles">
            <summary>
            Number of files referenced by this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.SizeMB">
            <summary>
            Net size (MB) of the files referenced by this
            segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreOffset">
            <summary>
            Doc store offset, if this segment shares the doc
            store files (stored fields and term vectors) with
            other segments.  This is -1 if it does not share.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreSegment">
            <summary>
            String of the shared doc store segment, or <c>null</c> if
            this segment does not share the doc store files.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocStoreCompoundFile">
            <summary>
            True if the shared doc store files are compound file
            format.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.HasDeletions">
            <summary>
            True if this segment has pending deletions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DeletionsGen">
            <summary>
            Current deletions generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumDeleted">
            <summary>
            Number of deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.OpenReaderPassed">
            <summary>
            True if we were able to open an <see cref="T:Lucene.Net.Index.AtomicReader"/> on this
            segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.NumFields">
            <summary>
            Number of fields in this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.Diagnostics">
            <summary>
            Map that includes certain
            debugging details that <see cref="T:Lucene.Net.Index.IndexWriter"/> records into
            each segment it creates
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.FieldNormStatus">
            <summary>
            Status for testing of field norms (<c>null</c> if field norms could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.TermIndexStatus">
            <summary>
            Status for testing of indexed terms (<c>null</c> if indexed terms could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.StoredFieldStatus">
            <summary>
            Status for testing of stored fields (<c>null</c> if stored fields could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.TermVectorStatus">
            <summary>
            Status for testing of term vectors (<c>null</c> if term vectors could not be tested). </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.SegmentInfoStatus.DocValuesStatus">
            <summary>
            Status for testing of <see cref="T:Lucene.Net.Index.DocValues"/> (<c>null</c> if <see cref="T:Lucene.Net.Index.DocValues"/> could not be tested). </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus">
            <summary>
            Status from testing field norms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus.TotFields">
            <summary>
            Number of fields successfully tested </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.FieldNormStatus.Error">
            <summary>
            Exception thrown during term index test (<c>null</c> on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus">
            <summary>
            Status from testing term index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TermCount">
            <summary>
            Number of terms with at least one live doc. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.DelTermCount">
            <summary>
            Number of terms with zero live docs docs. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TotFreq">
            <summary>
            Total frequency across all terms. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.TotPos">
            <summary>
            Total number of positions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.Error">
            <summary>
            Exception thrown during term index test (<c>null</c> on success) </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermIndexStatus.BlockTreeStats">
            <summary>
            Holds details of block allocations in the block
            tree terms dictionary (this is only set if the
            <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> for this segment uses block
            tree.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus">
            <summary>
            Status from testing stored fields.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.DocCount">
            <summary>
            Number of documents tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.TotFields">
            <summary>
            Total number of stored fields tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.StoredFieldStatus.Error">
            <summary>
            Exception thrown during stored fields test (<c>null</c> on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus">
            <summary>
            Status from testing stored fields.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.DocCount">
            <summary>
            Number of documents tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.TotVectors">
            <summary>
            Total number of term vectors tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.TermVectorStatus.Error">
            <summary>
            Exception thrown during term vector test (<c>null</c> on success) </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus">
            <summary>
            Status from testing <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalValueFields">
            <summary>
            Total number of docValues tested. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalNumericFields">
            <summary>
            Total number of numeric fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalBinaryFields">
            <summary>
            Total number of binary fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalSortedFields">
            <summary>
            Total number of sorted fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.TotalSortedSetFields">
            <summary>
            Total number of sortedset fields </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.Status.DocValuesStatus.Error">
            <summary>
            Exception thrown during doc values test (<c>null</c> on success) </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.CheckIndex"/> on the directory. </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.CrossCheckTermVectors">
            <summary>
            If <c>true</c>, term vectors are compared against postings to
            make sure they are the same.  This will likely
            drastically increase time it takes to run <see cref="T:Lucene.Net.Index.CheckIndex"/>!
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.InfoStream">
            <summary>
            Gets or Sets infoStream where messages should go.  If null, no
            messages are printed.  If <see cref="P:Lucene.Net.Index.CheckIndex.InfoStreamIsVerbose"/> is <c>true</c> then more
            details are printed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.CheckIndex.InfoStreamIsVerbose">
            <summary>
            If <c>true</c>, prints more details to the <see cref="P:Lucene.Net.Index.CheckIndex.InfoStream"/>, if set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.DoCheckIndex">
             <summary>
             Returns a <see cref="T:Lucene.Net.Index.CheckIndex.Status"/> instance detailing
             the state of the index.
            
             <para/>As this method checks every byte in the index, on a large
             index it can take quite a long time to run.
            
             <para/><b>WARNING</b>: make sure
             you only call this when the index is not opened by any
             writer.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.DoCheckIndex(System.Collections.Generic.IList{System.String})">
             <summary>
             Returns a <see cref="T:Lucene.Net.Index.CheckIndex.Status"/> instance detailing
             the state of the index.
             </summary>
             <param name="onlySegments"> list of specific segment names to check
            
             <para/>As this method checks every byte in the specified
             segments, on a large index it can take quite a long
             time to run.
            
             <para/><b>WARNING</b>: make sure
             you only call this when the index is not opened by any
             writer.  </param>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestFieldNorms(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test field norms.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.CheckFields(Lucene.Net.Index.Fields,Lucene.Net.Util.IBits,System.Int32,Lucene.Net.Index.FieldInfos,System.Boolean,System.Boolean,System.IO.TextWriter,System.Boolean)">
            <summary>
            Checks <see cref="T:Lucene.Net.Index.Fields"/> api is consistent with itself.
            Searcher is optional, to verify with queries. Can be <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestPostings(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test the term index.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestPostings(Lucene.Net.Index.AtomicReader,System.IO.TextWriter,System.Boolean)">
            <summary>
            Test the term index.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestStoredFields(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test stored fields.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestDocValues(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test docvalues.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestTermVectors(Lucene.Net.Index.AtomicReader,System.IO.TextWriter)">
            <summary>
            Test term vectors.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.TestTermVectors(Lucene.Net.Index.AtomicReader,System.IO.TextWriter,System.Boolean,System.Boolean)">
            <summary>
            Test term vectors.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckIndex.FixIndex(Lucene.Net.Index.CheckIndex.Status)">
             <summary>
             Repairs the index using previously returned result
             from <see cref="M:Lucene.Net.Index.CheckIndex.DoCheckIndex"/>.  Note that this does not
             remove any of the unreferenced files after it's done;
             you must separately open an <see cref="T:Lucene.Net.Index.IndexWriter"/>, which
             deletes unreferenced files when it's created.
            
             <para/><b>WARNING</b>: this writes a
             new segments file into the index, effectively removing
             all documents in broken segments from the index.
             BE CAREFUL.
            
             <para/><b>WARNING</b>: Make sure you only call this when the
             index is not opened by any writer.
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.CompositeReader">
             <summary>
             Instances of this reader type can only
             be used to get stored fields from the underlying <see cref="T:Lucene.Net.Index.AtomicReader"/>s,
             but it is not possible to directly retrieve postings. To do that, get
             the <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> for all sub-readers via <see cref="P:Lucene.Net.Index.AtomicReaderContext.Leaves"/>.
             Alternatively, you can mimic an <see cref="T:Lucene.Net.Index.AtomicReader"/> (with a serious slowdown),
             by wrapping composite readers with <see cref="T:Lucene.Net.Index.SlowCompositeReaderWrapper"/>.
            
             <para/><see cref="T:Lucene.Net.Index.IndexReader"/> instances for indexes on disk are usually constructed
             with a call to one of the static <c>DirectoryReader.Open()</c> methods,
             e.g. <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>. <see cref="T:Lucene.Net.Index.DirectoryReader"/> implements
             the <see cref="T:Lucene.Net.Index.CompositeReader"/> interface, it is not possible to directly get postings.
             <para/> Concrete subclasses of <see cref="T:Lucene.Net.Index.IndexReader"/> are usually constructed with a call to
             one of the static <c>Open()</c> methods, e.g. <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>.
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/>
             <b>NOTE</b>: 
             <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReader.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReader.GetSequentialSubReaders">
             <summary>
             Expert: returns the sequential sub readers that this
             reader is logically composed of. This method may not
             return <c>null</c>.
            
             <para/><b>NOTE:</b> In contrast to previous Lucene versions this method
             is no longer public, code that wants to get all <see cref="T:Lucene.Net.Index.AtomicReader"/>s
             this composite is composed of should use <see cref="P:Lucene.Net.Index.IndexReader.Leaves"/>. </summary>
             <seealso cref="P:Lucene.Net.Index.IndexReader.Leaves"/>
        </member>
        <member name="T:Lucene.Net.Index.CompositeReaderContext">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexReaderContext"/> for <see cref="T:Lucene.Net.Index.CompositeReader"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReaderContext.#ctor(Lucene.Net.Index.CompositeReaderContext,Lucene.Net.Index.CompositeReader,System.Int32,System.Int32,System.Collections.Generic.IList{Lucene.Net.Index.IndexReaderContext})">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.CompositeReaderContext"/> for intermediate readers that aren't
            not top-level readers in the current context
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CompositeReaderContext.#ctor(Lucene.Net.Index.CompositeReader,System.Collections.Generic.IList{Lucene.Net.Index.IndexReaderContext},System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Creates a <see cref="T:Lucene.Net.Index.CompositeReaderContext"/> for top-level readers with parent set to <c>null</c>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler">
             <summary>
             A <see cref="T:Lucene.Net.Index.MergeScheduler"/> that runs each merge using a
             separate thread.
            
             <para>Specify the max number of threads that may run at
             once, and the maximum number of simultaneous merges
             with <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)"/>.</para>
            
             <para>If the number of merges exceeds the max number of threads
             then the largest merges are paused until one of the smaller
             merges completes.</para>
            
             <para>If more than <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxMergeCount"/> merges are
             requested then this class will forcefully throttle the
             incoming threads by pausing until one more more merges
             complete.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_mergeThreads">
            <summary>
            List of currently active <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.DEFAULT_MAX_THREAD_COUNT">
            <summary>
            Default <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxThreadCount"/>.
            We default to 1: tests on spinning-magnet drives showed slower
            indexing performance if more than one merge thread runs at
            once (though on an SSD it was faster)
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.DEFAULT_MAX_MERGE_COUNT">
            <summary>
            Default <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxMergeCount"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_dir">
            <summary>
            <see cref="T:Lucene.Net.Store.Directory"/> that holds the index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_writer">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexWriter"/> that owns this instance. </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_mergeThreadCount">
            <summary>
            How many <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s have kicked off (this is use
            to name them).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.#ctor">
            <summary>
            Sole constructor, with all settings set to default
            values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)">
            <summary>
            Sets the maximum number of merge threads and simultaneous merges allowed.
            </summary>
            <param name="maxMergeCount"> the max # simultaneous merges that are allowed.
                  If a merge is necessary yet we already have this many
                  threads running, the incoming thread (that is calling
                  add/updateDocument) will block until a merge thread
                  has completed.  Note that we will only run the
                  smallest <paramref name="maxThreadCount"/> merges at a time. </param>
            <param name="maxThreadCount"> The max # simultaneous merge threads that should
                  be running at once.  This must be &lt;= <paramref name="maxMergeCount"/> </param>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxThreadCount">
            <summary>
            Returns <see cref="F:Lucene.Net.Index.ConcurrentMergeScheduler.maxThreadCount"/>.
            </summary>
            <seealso cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)"/>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MaxMergeCount">
            <summary>
            See <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreadPriority">
            <summary>
            Return the priority that merge threads run at.  By
            default the priority is 1 plus the priority of (ie,
            slightly higher priority than) the first thread that
            calls merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetMergeThreadPriority(System.Int32)">
            <summary>
            Set the base priority that merge threads run at.
            Note that CMS may increase priority of some merge
            threads beyond this base priority.  It's best not to
            set this any higher than
            <see cref="F:System.Threading.ThreadPriority.Highest"/>(4)-maxThreadCount, so that CMS has
            room to set relative priority among threads.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.ConcurrentMergeScheduler.compareByMergeDocCount">
            <summary>
            Sorts <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/>s; larger merges come first. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.UpdateMergeThreads">
            <summary>
            Called whenever the running merges have changed, to pause &amp; unpause
            threads. This method sorts the merge threads by their merge size in
            descending order and then pauses/unpauses threads from first to last --
            that way, smaller merges are guaranteed to run before larger ones.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.IsVerbose">
             <summary>
             Returns <c>true</c> if verbosing is enabled. This method is usually used in
             conjunction with <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.Message(System.String)"/>, like that:
            
             <code>
             if (IsVerbose) 
             {
                 Message(&quot;your message&quot;);
             }
             </code>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.Message(System.String)">
            <summary>
            Outputs the given message - this method assumes <see cref="P:Lucene.Net.Index.ConcurrentMergeScheduler.IsVerbose"/> was
            called and returned <c>true</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.Sync">
            <summary>
            Wait for any running merge threads to finish. This call is not interruptible as used by <see cref="M:Lucene.Net.Index.ConcurrentMergeScheduler.Dispose(System.Boolean)"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThreadCount">
            <summary>
            Returns the number of merge threads that are alive. Note that this number
            is &lt;= <see cref="F:Lucene.Net.Index.ConcurrentMergeScheduler.m_mergeThreads"/> size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.DoMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the actual merge, by calling <see cref="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.GetMergeThread(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Create and return a new <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread">
            <summary>
            Runs a merge thread, which may run one or more merges
            in sequence.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.#ctor(Lucene.Net.Index.ConcurrentMergeScheduler,Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.RunningMerge">
            <summary>
            Record the currently running merge. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.CurrentMerge">
            <summary>
            Return the current merge, or <c>null</c> if this 
            <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread"/> is done.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.MergeThread.SetThreadPriority(System.Threading.ThreadPriority)">
            <summary>
            Set the priority of this thread. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.HandleMergeException(System.Exception)">
            <summary>
            Called when an exception is hit in a background merge
            thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.SetSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.ConcurrentMergeScheduler.ClearSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="T:Lucene.Net.Index.CorruptIndexException">
            <summary>
            This exception is thrown when Lucene detects
            an inconsistency in the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CorruptIndexException.#ctor(System.String)">
            <summary>
            Constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CorruptIndexException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CorruptIndexException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.DirectoryReader" -->
        <member name="F:Lucene.Net.Index.DirectoryReader.DEFAULT_TERMS_INDEX_DIVISOR">
            <summary>
            Default termInfosIndexDivisor. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DirectoryReader.m_directory">
            <summary>
            The index directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> </summary>
            <param name="directory"> the index directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Expert: Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> with the given termInfosIndexDivisor. </summary>
            <param name="directory"> the index directory </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
            terms are loaded into RAM. this has the same effect as setting
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> (on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value &gt; 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.  Set this
            to -1 to skip loading the terms index entirely.
            <b>NOTE:</b> divisor settings &gt; 1 do not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
            implementations, including the default one in this release. It only makes
            sense for terms indexes that can efficiently re-sample terms at load time. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Open a near real time <see cref="T:Lucene.Net.Index.IndexReader"/> from the <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            <para/>
            @lucene.experimental 
            </summary>
            <param name="writer"> The <see cref="T:Lucene.Net.Index.IndexWriter"/> to open from </param>
            <param name="applyAllDeletes"> If <c>true</c>, all buffered deletes will
            be applied (made visible) in the returned reader.  If
            <c>false</c>, the deletes are not applied but remain buffered
            (in IndexWriter) so that they will be applied in the
            future.  Applying deletes can be costly, so if your app
            can tolerate deleted documents being returned you might
            gain some performance by passing <c>false</c>. </param>
            <returns> The new <see cref="T:Lucene.Net.Index.IndexReader"/> </returns>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error
            </exception>
            <seealso cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit)">
            <summary>
            Expert: returns an <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            Expert: returns an <see cref="!:"/>IndexReader reading the index in the given
             <seealso cref="P:Lucene.Net.Index.DirectoryReader.IndexCommit"/> and <paramref name="termInfosIndexDivisor"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
            terms are loaded into RAM. this has the same effect as setting
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> (on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
            must be done at indexing time while this setting can be
            set per reader.  When set to N, then one in every
            N*termIndexInterval terms in the index is loaded into
            memory.  By setting this to a value &gt; 1 you can reduce
            memory usage, at the expense of higher latency when
            loading a TermInfo.  The default value is 1.  Set this
            to -1 to skip loading the terms index entirely.
            <b>NOTE:</b> divisor settings &gt; 1 do not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
            implementations, including the default one in this release. It only makes
            sense for terms indexes that can efficiently re-sample terms at load time. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)">
             <summary>
             If the index has changed since the provided reader was
             opened, open and return a new reader; else, return
             <c>null</c>.  The new reader, if not <c>null</c>, will be the same
             type of reader as the previous one, ie a near-real-time (NRT) reader
             will open a new NRT reader, a <see cref="T:Lucene.Net.Index.MultiReader"/> will open a
             new <see cref="T:Lucene.Net.Index.MultiReader"/>,  etc.
            
             <para/>This method is typically far less costly than opening a
             fully new <see cref="T:Lucene.Net.Index.DirectoryReader"/> as it shares
             resources (for example sub-readers) with the provided
             <see cref="T:Lucene.Net.Index.DirectoryReader"/>, when possible.
            
             <para/>The provided reader is not disposed (you are responsible
             for doing so); if a new reader is returned you also
             must eventually dispose it.  Be sure to never dispose a
             reader while other threads are still using it; see
             <see cref="T:Lucene.Net.Search.SearcherManager"/> to simplify managing this.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
             <returns> <c>null</c> if there are no changes; else, a new
             <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance which you must eventually dispose </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexCommit)">
            <summary>
            If the <see cref="T:Lucene.Net.Index.IndexCommit"/> differs from what the
            provided reader is searching, open and return a new
            reader; else, return <c>null</c>.
            </summary>
            <seealso cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)">
             <summary>
             Expert: If there changes (committed or not) in the
             <see cref="T:Lucene.Net.Index.IndexWriter"/> versus what the provided reader is
             searching, then open and return a new
             <see cref="T:Lucene.Net.Index.IndexReader"/> searching both committed and uncommitted
             changes from the writer; else, return <c>null</c> (though, the
             current implementation never returns <c>null</c>).
            
             <para/>This provides "near real-time" searching, in that
             changes made during an <see cref="T:Lucene.Net.Index.IndexWriter"/> session can be
             quickly made available for searching without closing
             the writer nor calling <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            
             <para>It's <i>near</i> real-time because there is no hard
             guarantee on how quickly you can get a new reader after
             making changes with <see cref="T:Lucene.Net.Index.IndexWriter"/>.  You'll have to
             experiment in your situation to determine if it's
             fast enough.  As this is a new and experimental
             feature, please report back on your findings so we can
             learn, improve and iterate.</para>
            
             <para>The very first time this method is called, this
             writer instance will make every effort to pool the
             readers that it opens for doing merges, applying
             deletes, etc.  This means additional resources (RAM,
             file descriptors, CPU time) will be consumed.</para>
            
             <para>For lower latency on reopening a reader, you should
             call <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/> (on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) to
             pre-warm a newly merged segment before it's committed
             to the index.  This is important for minimizing
             index-to-search delay after a large merge.  </para>
            
             <para>If an AddIndexes* call is running in another thread,
             then this reader will only search those segments from
             the foreign index that have been successfully copied
             over, so far.</para>
            
             <para><b>NOTE</b>: Once the writer is disposed, any
             outstanding readers may continue to be used.  However,
             if you attempt to reopen any of those readers, you'll
             hit an <see cref="T:System.ObjectDisposedException"/>.</para>
             
             @lucene.experimental
             </summary>
             <returns> <see cref="T:Lucene.Net.Index.DirectoryReader"/> that covers entire index plus all
             changes made so far by this <see cref="T:Lucene.Net.Index.IndexWriter"/> instance, or
             <c>null</c> if there are no new changes
             </returns>
             <param name="writer"> The <see cref="T:Lucene.Net.Index.IndexWriter"/> to open from
             </param>
             <param name="applyAllDeletes"> If <c>true</c>, all buffered deletes will
             be applied (made visible) in the returned reader.  If
             <c>false</c>, the deletes are not applied but remain buffered
             (in <see cref="T:Lucene.Net.Index.IndexWriter"/>) so that they will be applied in the
             future.  Applying deletes can be costly, so if your app
             can tolerate deleted documents being returned you might
             gain some performance by passing <c>false</c>.
             </param>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.ListCommits(Lucene.Net.Store.Directory)">
            <summary>
            Returns all commit points that exist in the <see cref="T:Lucene.Net.Store.Directory"/>.
            Normally, because the default is 
            <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>, there would be only
            one commit point.  But if you're using a custom
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> then there could be many commits.
            Once you have a given commit, you can open a reader on
            it by calling <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexCommit)"/>
            There must be at least one commit in
            the <see cref="T:Lucene.Net.Store.Directory"/>, else this method throws 
            <see cref="T:Lucene.Net.Index.IndexNotFoundException"/>.  Note that if a commit is in
            progress while this method is running, that commit
            may or may not be returned.
            </summary>
            <returns> a sorted list of <see cref="T:Lucene.Net.Index.IndexCommit"/>s, from oldest
            to latest. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.IndexExists(Lucene.Net.Store.Directory)">
            <summary>
            Returns <c>true</c> if an index likely exists at
            the specified directory.  Note that if a corrupt index
            exists, or if an index in the process of committing </summary>
            <param name="directory"> the directory to check for an index </param>
            <returns> <c>true</c> if an index exists; <c>false</c> otherwise </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.AtomicReader[])">
            <summary>
            Expert: Constructs a <see cref="T:Lucene.Net.Index.DirectoryReader"/> on the given <paramref name="segmentReaders"/>. </summary>
            <param name="segmentReaders"> the wrapped atomic index segment readers. This array is
            returned by <see cref="M:Lucene.Net.Index.CompositeReader.GetSequentialSubReaders"/> and used to resolve the correct
            subreader for docID-based methods. <b>Please note:</b> this array is <b>not</b>
            cloned and not protected for modification outside of this reader.
            Subclasses of <see cref="T:Lucene.Net.Index.DirectoryReader"/> should take care to not allow
            modification of this internal array, e.g. <see cref="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged"/>. </param>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.Directory">
            <summary>
            Returns the directory this index resides in. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged">
            <summary>
            Implement this method to support <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>.
            If this reader does not support reopen, return <c>null</c>, so
            client code is happy. This should be consistent with <see cref="M:Lucene.Net.Index.DirectoryReader.IsCurrent"/>
            (should always return <c>true</c>) if reopen is not supported. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> <c>null</c> if there are no changes; else, a new
            <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged(Lucene.Net.Index.IndexCommit)">
            <summary>
            Implement this method to support <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexCommit)"/>.
            If this reader does not support reopen from a specific <see cref="T:Lucene.Net.Index.IndexCommit"/>,
            throw <see cref="T:System.NotSupportedException"/>. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> <c>null</c> if there are no changes; else, a new
            <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Implement this method to support <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>.
            If this reader does not support reopen from <see cref="T:Lucene.Net.Index.IndexWriter"/>,
            throw <see cref="T:System.NotSupportedException"/>. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <returns> <c>null</c> if there are no changes; else, a new
            <see cref="T:Lucene.Net.Index.DirectoryReader"/> instance. </returns>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.Version">
             <summary>
             Version number when this <see cref="T:Lucene.Net.Index.IndexReader"/> was opened.
            
             <para>This method
             returns the version recorded in the commit that the
             reader opened.  This version is advanced every time
             a change is made with <see cref="T:Lucene.Net.Index.IndexWriter"/>.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.DirectoryReader.IsCurrent">
             <summary>
             Check whether any new changes have occurred to the
             index since this reader was opened.
            
             <para>If this reader was created by calling <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>,
             then this method checks if any further commits
             (see <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>) have occurred in the
             directory.</para>
            
             <para>If instead this reader is a near real-time reader
             (ie, obtained by a call to 
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>, or by calling <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/>
             on a near real-time reader), then this method checks if
             either a new commit has occurred, or any new
             uncommitted changes have taken place via the writer.
             Note that even if the writer has only performed
             merging, this method will still return <c>false</c>.</para>
            
             <para>In any event, if this returns <c>false</c>, you should call
             <see cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader)"/> to get a new reader that sees the
             changes.</para>
             </summary>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="P:Lucene.Net.Index.DirectoryReader.IndexCommit">
            <summary>
            Expert: return the <see cref="T:Lucene.Net.Index.IndexCommit"/> that this reader has opened.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.Flush(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Index.DocFieldConsumerPerField},Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Called when <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> decides to create a new
            segment
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumer.Abort">
            <summary>
            Called when an aborting exception is hit </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocFieldConsumerPerField.ProcessFields(Lucene.Net.Index.IIndexableField[],System.Int32)">
            <summary>
            Processes all occurrences of a single field </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessor">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.DocConsumer"/> that gathers all fields under the
            same name, and calls per-field consumers to process field
            by field.  This class doesn't doesn't do any "real" work
            of its own: it just forwards the fields to a
            <see cref="T:Lucene.Net.Index.DocFieldConsumer"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocFieldProcessorPerField">
            <summary>
            Holds all per thread, per field state.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverter">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.DocFieldConsumer"/> that inverts each field,
            separately, from a <see cref="T:Lucene.Net.Documents.Document"/>, and accepts a
            <see cref="T:Lucene.Net.Index.InvertedDocConsumer"/> to process those terms.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocInverterPerField">
            <summary>
            Holds state for inverting all occurrences of a single
            field in the document.  This class doesn't do anything
            itself; instead, it forwards the tokens produced by
            analysis to its own consumer
            (<see cref="T:Lucene.Net.Index.InvertedDocConsumerPerField"/>).  It also interacts with an
            endConsumer (<see cref="T:Lucene.Net.Index.InvertedDocEndConsumerPerField"/>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsFlags.NONE">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/> 
            if you require that no offsets and payloads will be returned.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsFlags.OFFSETS">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/>
            if you require offsets in the returned enum.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsAndPositionsFlags.PAYLOADS">
            <summary>
            Flag to pass to  <see cref="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)"/>
            if you require payloads in the returned enum.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocsAndPositionsEnum">
            <summary>
            Also iterates through positions. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.NextPosition">
            <summary>
            Returns the next position.  You should only call this
            up to <see cref="P:Lucene.Net.Index.DocsEnum.Freq"/> times else
            the behavior is not defined.  If positions were not
            indexed this will return -1; this only happens if
            offsets were indexed and you passed needsOffset=true
            when pulling the enum.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsAndPositionsEnum.StartOffset">
            <summary>
            Returns start offset for the current position, or -1
            if offsets were not indexed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsAndPositionsEnum.EndOffset">
            <summary>
            Returns end offset for the current position, or -1 if
            offsets were not indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsAndPositionsEnum.GetPayload">
            <summary>
            Returns the payload at this position, or <c>null</c> if no
            payload was indexed. You should not modify anything
            (neither members of the returned <see cref="T:Lucene.Net.Util.BytesRef"/> nor bytes
            in the <see cref="T:byte[]"/>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsFlags.NONE">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)"/> if you don't
            require term frequencies in the returned enum.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocsFlags.FREQS">
            <summary>
            Flag to pass to <see cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)"/>
            if you require term frequencies in the returned enum.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocsEnum">
            <summary>
            Iterates through the documents and term freqs.
            NOTE: you must first call <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> before using
            any of the per-doc methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsEnum.Freq">
             <summary>
             Returns term frequency in the current document, or 1 if the field was
             indexed with <see cref="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY"/>. Do not call this before
             <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> is first called, nor after <see cref="M:Lucene.Net.Search.DocIdSetIterator.NextDoc"/> returns
             <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/>.
            
             <para/>
             <b>NOTE:</b> if the <see cref="T:Lucene.Net.Index.DocsEnum"/> was obtain with <see cref="F:Lucene.Net.Index.DocsFlags.NONE"/>,
             the result of this method is undefined.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocsEnum.Attributes">
            <summary>
            Returns the related attributes. </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocTermOrds">
            <summary>
            This class enables fast access to multiple term ords for
            a specified field across all docIDs.
            <para/>
            Like <see cref="T:Lucene.Net.Search.IFieldCache"/>, it uninverts the index and holds a
            packed data structure in RAM to enable fast access.
            Unlike <see cref="T:Lucene.Net.Search.IFieldCache"/>, it can handle multi-valued fields,
            and, it does not hold the term bytes in RAM.  Rather, you
            must obtain a <see cref="T:Lucene.Net.Index.TermsEnum"/> from the <see cref="M:Lucene.Net.Index.DocTermOrds.GetOrdTermsEnum(Lucene.Net.Index.AtomicReader)"/>
            method, and then seek-by-ord to get the term's bytes.
            <para/>
            While normally term ords are type <see cref="T:System.Int64"/>, in this API they are
            <see cref="T:System.Int32"/> as the internal representation here cannot address
            more than <see cref="F:Lucene.Net.Index.BufferedUpdates.MAX_INT32"/> unique terms.  Also, typically this
            class is used on fields with relatively few unique terms
            vs the number of documents.  In addition, there is an
            internal limit (16 MB) on how many bytes each chunk of
            documents may consume.  If you trip this limit you'll hit
            an <see cref="T:System.InvalidOperationException"/>.
            <para/>
            Deleted documents are skipped during uninversion, and if
            you look them up you'll get 0 ords.
            <para/>
            The returned per-document ords do not retain their
            original order in the document.  Instead they are returned
            in sorted (by ord, ie term's <see cref="T:Lucene.Net.Util.BytesRef"/> comparer) order.  They
            are also de-dup'd (ie if doc has same term more than once
            in this field, you'll only get that ord back once).
            <para/>
            This class tests whether the provided reader is able to
            retrieve terms by ord (ie, it's single segment, and it
            uses an ord-capable terms index).  If not, this class
            will create its own term index internally, allowing to
            create a wrapped <see cref="T:Lucene.Net.Index.TermsEnum"/> that can handle ord.  The
            <see cref="M:Lucene.Net.Index.DocTermOrds.GetOrdTermsEnum(Lucene.Net.Index.AtomicReader)"/> method then provides this
            wrapped enum, if necessary.
            <para/>
            The RAM consumption of this class can be high!
            <para/>
            @lucene.experimental
            </summary>
            <remarks>
            Final form of the un-inverted field:
            <list type="bullet">
                <item>Each document points to a list of term numbers that are contained in that document.</item>
                <item>
                    Term numbers are in sorted order, and are encoded as variable-length deltas from the
                    previous term number.  Real term numbers start at 2 since 0 and 1 are reserved.  A
                    term number of 0 signals the end of the termNumber list.
                </item>
                <item>
                    There is a single int[maxDoc()] which either contains a pointer into a byte[] for
                    the termNumber lists, or directly contains the termNumber list if it fits in the 4
                    bytes of an integer.  If the first byte in the integer is 1, the next 3 bytes
                    are a pointer into a byte[] where the termNumber list starts.
                </item>
                <item>
                    There are actually 256 byte arrays, to compensate for the fact that the pointers
                    into the byte arrays are only 3 bytes long.  The correct byte array for a document
                    is a function of it's id.
                </item>
                <item>
                    To save space and speed up faceting, any term that matches enough documents will
                    not be un-inverted... it will be skipped while building the un-inverted field structure,
                    and will use a set intersection method during faceting.
                </item>
                <item>
                    To further save memory, the terms (the actual string values) are not all stored in
                    memory, but a TermIndex is used to convert term numbers to term values only
                    for the terms needed after faceting has completed.  Only every 128th term value
                    is stored, along with it's corresponding term number, and this is used as an
                    index to find the closest term and iterate until the desired number is hit (very
                    much like Lucene's own internal term index).
                </item>
            </list>
            </remarks>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.TNUM_OFFSET">
            <summary>
            Term ords are shifted by this, internally, to reserve
            values 0 (end term) and 1 (index is a pointer into byte array)
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.DEFAULT_INDEX_INTERVAL_BITS">
            <summary>
            Every 128th term is indexed, by default. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_maxTermDocFreq">
            <summary>
            Don't uninvert terms that exceed this count. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_field">
            <summary>
            Field we are uninverting. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_numTermsInField">
            <summary>
            Number of terms in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_termInstances">
            <summary>
            Total number of references to term numbers. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_total_time">
            <summary>
            Total time to uninvert the field. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_phase1_time">
            <summary>
            Time for phase1 of the uninvert process. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_index">
            <summary>
            Holds the per-document ords or a pointer to the ords. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_tnums">
            <summary>
            Holds term ords for documents. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_sizeOfIndexedStrings">
            <summary>
            Total bytes (sum of term lengths) for all indexed terms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_indexedTermsArray">
            <summary>
            Holds the indexed (by default every 128th) terms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_prefix">
            <summary>
            If non-null, only terms matching this prefix were
            indexed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_ordBase">
            <summary>
            Ordinal of the first term in the field, or 0 if the
            <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> does not implement 
            <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocTermOrds.m_docsEnum">
            <summary>
            Used while uninverting. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.RamUsedInBytes">
            <summary>
            Returns total bytes used. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String)">
            <summary>
            Inverts all terms </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Inverts only terms starting w/ prefix </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Inverts only terms starting w/ prefix, and only terms
            whose docFreq (not taking deletions into account) is
            &lt;= <paramref name="maxTermDocFreq"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,System.Int32,System.Int32)">
            <summary>
            Inverts only terms starting w/ prefix, and only terms
            whose docFreq (not taking deletions into account) is
            &lt;=  <paramref name="maxTermDocFreq"/>, with a custom indexing interval
            (default is every 128nd term).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Subclass inits w/ this, but be sure you then call
            uninvert, only once
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.GetOrdTermsEnum(Lucene.Net.Index.AtomicReader)">
             <summary>
             Returns a <see cref="T:Lucene.Net.Index.TermsEnum"/> that implements <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>.  If the
             provided <paramref name="reader"/> supports <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>, we just return its
             <see cref="T:Lucene.Net.Index.TermsEnum"/>; if it does not, we build a "private" terms
             index internally (WARNING: consumes RAM) and use that
             index to implement <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>.  This also enables <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/> on top
             of a composite reader.  The returned <see cref="T:Lucene.Net.Index.TermsEnum"/> is
             unpositioned.  This returns <c>null</c> if there are no terms.
            
             <para/><b>NOTE</b>: you must pass the same reader that was
             used when creating this class
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocTermOrds.NumTerms">
            <summary>
            Returns the number of terms in this field
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocTermOrds.IsEmpty">
            <summary>
            Returns <c>true</c> if no terms were indexed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.VisitTerm(Lucene.Net.Index.TermsEnum,System.Int32)">
            <summary>
            Subclass can override this </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.SetActualDocFreq(System.Int32,System.Int32)">
            <summary>
            Invoked during <see cref="M:Lucene.Net.Index.DocTermOrds.Uninvert(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,Lucene.Net.Util.BytesRef)"/>
            to record the document frequency for each uninverted
            term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.Uninvert(Lucene.Net.Index.AtomicReader,Lucene.Net.Util.IBits,Lucene.Net.Util.BytesRef)">
            <summary>
            Call this only once (if you subclass!) </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.VInt32Size(System.Int32)">
            <summary>
            Number of bytes to represent an unsigned int as a vint. 
            <para/>
            NOTE: This was vIntSize() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.WriteInt32(System.Int32,System.SByte[],System.Int32)">
            <summary>
            NOTE: This was writeInt() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocTermOrds.OrdWrappedTermsEnum">
            <summary>
            Only used if original <see cref="T:Lucene.Net.Index.IndexReader"/> doesn't implement
            <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>; in this case we "wrap" our own terms index
            around it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.LookupTerm(Lucene.Net.Index.TermsEnum,System.Int32)">
            <summary>
            Returns the term (<see cref="T:Lucene.Net.Util.BytesRef"/>) corresponding to
            the provided ordinal.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.GetIterator(Lucene.Net.Index.AtomicReader)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.SortedSetDocValues"/> view of this instance </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocTermOrds.Iterator.Read(System.Int32[])">
            <summary>
            Buffer must be at least 5 <see cref="T:System.Int32"/>s long.  Returns number
            of term ords placed into buffer; if this count is
            less than buffer.Length then that is the end.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriter">
             <summary>
             This class accepts multiple added documents and directly
             writes segment files.
             <para/>
             Each added document is passed to the <see cref="T:Lucene.Net.Index.DocConsumer"/>,
             which in turn processes the document and interacts with
             other consumers in the indexing chain.  Certain
             consumers, like <see cref="T:Lucene.Net.Index.StoredFieldsConsumer"/> and 
             <see cref="T:Lucene.Net.Index.TermVectorsConsumer"/>, digest a document and
             immediately write bytes to the "doc store" files (ie,
             they do not consume RAM per document, except while they
             are processing the document).
             <para/>
             Other consumers, eg <see cref="T:Lucene.Net.Index.FreqProxTermsWriter"/> and
             <see cref="T:Lucene.Net.Index.NormsConsumer"/>, buffer bytes in RAM and flush only
             when a new segment is produced.
             <para/>
             Once we have used our allowed RAM buffer, or the number
             of added docs is large enough (in the case we are
             flushing by doc count instead of RAM usage), we create a
             real segment and flush it to the Directory.
             <para/>
             Threads:
             <para/>
             Multiple threads are allowed into AddDocument at once.
             There is an initial synchronized call to <see cref="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.GetThreadState(System.Int32)"/>
             which allocates a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> for this thread.  The same
             thread will get the same <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> over time (thread
             affinity) so that if there are consistent patterns (for
             example each thread is indexing a different content
             source) then we make better use of RAM.  Then
             ProcessDocument is called on that <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> without
             synchronization (most of the "heavy lifting" is in this
             call).  Finally the synchronized "finishDocument" is
             called to flush changes to the directory.
             <para/>
             When flush is called by <see cref="T:Lucene.Net.Index.IndexWriter"/> we forcefully idle
             all threads and flush only once they are all idle.  this
             means you can call flush with a given thread even while
             other threads are actively adding/deleting documents.
             <para/>
            
             Exceptions:
             <para/>
             Because this class directly updates in-memory posting
             lists, and flushes stored fields and term vectors
             directly to files in the directory, there are certain
             limited times when an exception can corrupt this state.
             For example, a disk full while flushing stored fields
             leaves this file in a corrupt state.  Or, an OOM
             exception while appending to the in-memory posting lists
             can corrupt that posting list.  We call such exceptions
             "aborting exceptions".  In these cases we must call
             <see cref="M:Lucene.Net.Index.DocumentsWriter.Abort(Lucene.Net.Index.IndexWriter)"/> to discard all docs added since the last flush.
             <para/>
             All other exceptions ("non-aborting exceptions") can
             still partially update the index structures.  These
             updates are consistent, but, they represent only a part
             of the document seen up until the exception was hit.
             When this happens, we immediately mark the document as
             deleted so that the document is always atomically ("all
             or none") added to the index.
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriter.pendingChangesInCurrentFullFlush">
            <summary>
            we preserve changes during a full flush since IW might not checkout before
            we release all changes. NRT Readers otherwise suddenly return true from
            IsCurrent() while there are actually changes currently committed. See also
            <see cref="M:Lucene.Net.Index.DocumentsWriter.AnyChanges"/> &amp; <see cref="M:Lucene.Net.Index.DocumentsWriter.FlushAllThreads(Lucene.Net.Index.IndexWriter)"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriter.NumDocs">
            <summary>
            Returns how many docs are currently buffered in RAM. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriter.Abort(Lucene.Net.Index.IndexWriter)">
            <summary>
            Called if we hit an exception at a bad time (when
             updating the index files) and must discard all
             currently buffered docs.  this resets our state,
             discarding any docs added since last flush.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterDeleteQueue">
             <summary>
             <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue"/> is a non-blocking linked pending deletes
             queue. In contrast to other queue implementation we only maintain the
             tail of the queue. A delete queue is always used in a context of a set of
             DWPTs and a global delete pool. Each of the DWPT and the global pool need to
             maintain their 'own' head of the queue (as a <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> instance per DWPT).
             The difference between the DWPT and the global pool is that the DWPT starts
             maintaining a head once it has added its first document since for its segments
             private deletes only the deletes after that document are relevant. The global
             pool instead starts maintaining the head once this instance is created by
             taking the sentinel instance as its initial head.
             <para/>
             Since each <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> maintains its own head and the list is only
             single linked the garbage collector takes care of pruning the list for us.
             All nodes in the list that are still relevant should be either directly or
             indirectly referenced by one of the DWPT's private <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> or by
             the global <see cref="T:Lucene.Net.Index.BufferedUpdates"/> slice.
             <para/>
             Each DWPT as well as the global delete pool maintain their private
             DeleteSlice instance. In the DWPT case updating a slice is equivalent to
             atomically finishing the document. The slice update guarantees a "happens
             before" relationship to all other updates in the same indexing session. When a
             DWPT updates a document it:
            
             <list type="number">
                 <item>consumes a document and finishes its processing</item>
                 <item>updates its private <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> either by calling
                 <see cref="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.UpdateSlice(Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice)"/> or <see cref="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.Add(Lucene.Net.Index.Term,Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice)"/> (if the
                     document has a delTerm)</item>
                 <item>applies all deletes in the slice to its private <see cref="T:Lucene.Net.Index.BufferedUpdates"/>
                     and resets it</item>
                 <item>increments its internal document id</item>
             </list>
            
             The DWPT also doesn't apply its current documents delete term until it has
             updated its delete slice which ensures the consistency of the update. If the
             update fails before the <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice"/> could have been updated the deleteTerm
             will also not be added to its private deletes neither to the global deletes.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.Add(Lucene.Net.Index.Term,Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice)">
            <summary>
            invariant for document update
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterDeleteQueue.DeleteSlice.IsTailItem(System.Object)">
            <summary>
            Returns <code>true</code> iff the given item is identical to the item
            hold by the slices tail, otherwise <code>false</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterFlushControl">
            <summary>
            This class controls <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> flushing during
            indexing. It tracks the memory consumption per
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> and uses a configured <see cref="F:Lucene.Net.Index.DocumentsWriterFlushControl.flushPolicy"/> to
            decide if a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> must flush.
            <para/>
            In addition to the <see cref="F:Lucene.Net.Index.DocumentsWriterFlushControl.flushPolicy"/> the flush control might set certain
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> as flush pending iff a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> exceeds the
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/> to prevent address
            space exhaustion.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.SetFlushPending(Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Sets flush pending state on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. The
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> must have indexed at least on <see cref="T:Lucene.Net.Documents.Document"/> and must not be
            already pending.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.AllActiveThreadStates">
            <summary>
            Returns an iterator that provides access to all currently active <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.NumGlobalTermDeletes">
            <summary>
            Returns the number of delete terms in the global pool
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.PruneBlockedQueue(Lucene.Net.Index.DocumentsWriterDeleteQueue)">
            <summary>
            Prunes the blockedQueue by removing all DWPT that are associated with the given flush queue.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.IsFullFlush">
            <summary>
            Returns <c>true</c> if a full flush is currently running
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.NumQueuedFlushes">
            <summary>
            Returns the number of flushes that are already checked out but not yet
            actively flushing
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.NumBlockedFlushes">
            <summary>
            Returns the number of flushes that are checked out but not yet available
            for flushing. This only applies during a full flush if a DWPT needs
            flushing but must not be flushed until the full flush has finished.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.WaitIfStalled">
            <summary>
            This method will block if too many DWPT are currently flushing and no
            checked out DWPT are available
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushControl.AnyStalledThreads">
            <summary>
            Returns <c>true</c> iff stalled
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterFlushControl.InfoStream">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.IndexWriter"/> <see cref="T:Lucene.Net.Util.InfoStream"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterFlushQueue">
            <summary>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterFlushQueue.FlushTicket.PublishFlushedSegment(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.DocumentsWriterPerThread.FlushedSegment,Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Publishes the flushed segment, segment private deletes (if any) and its
            associated global delete (if present) to <see cref="T:Lucene.Net.Index.IndexWriter"/>.  The actual
            publishing operation is synced on IW -> BDS so that the <see cref="T:Lucene.Net.Index.SegmentInfo"/>'s
            delete generation is always <see cref="P:Lucene.Net.Index.FrozenBufferedUpdates.DelGen"/> (<paramref name="globalPacket"/>) + 1
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain">
            <summary>
            The <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain"/> must define the <see cref="M:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain.GetChain(Lucene.Net.Index.DocumentsWriterPerThread)"/> method
            which returns the <see cref="T:Lucene.Net.Index.DocConsumer"/> that the <see cref="T:Lucene.Net.Index.DocumentsWriter"/> calls to process the
            documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Abort(System.Collections.Generic.ISet{System.String})">
            <summary>
            Called if we hit an exception at a bad time (when
            updating the index files) and must discard all
            currently buffered docs.  this resets our state,
            discarding any docs added since last flush.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.NumDeleteTerms">
            <summary>
            Returns the number of delete terms in this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.NumDocsInRAM">
            <summary>
            Returns the number of RAM resident documents in this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.PrepareFlush">
            <summary>
            Prepares this DWPT for flushing. this method will freeze and return the
            <see cref="T:Lucene.Net.Index.DocumentsWriterDeleteQueue"/>s global buffer and apply all pending
            deletes to this DWPT.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Flush">
            <summary>
            Flush all pending docs to a new segment </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.SealFlushedSegment(Lucene.Net.Index.DocumentsWriterPerThread.FlushedSegment)">
            <summary>
            Seals the <see cref="T:Lucene.Net.Index.SegmentInfo"/> for the new flushed segment and persists
            the deleted documents <see cref="T:Lucene.Net.Util.IMutableBits"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThread.SegmentInfo">
            <summary>
            Get current segment info we are writing. </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriterPerThread.BYTE_BLOCK_NOT_MASK">
            <summary>
            Initial chunks size of the shared byte[] blocks used to
            store postings data
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocumentsWriterPerThread.MAX_TERM_LENGTH_UTF8">
            <summary>
            if you increase this, you must fix field cache impl for
            getTerms/getTermsIndex requires &lt;= 32768
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThread.Int32BlockAllocator">
            <summary>
            NOTE: This was IntBlockAllocator in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThread.Int32BlockAllocator.GetInt32Block">
            <summary>
            Allocate another int[] from the shared pool
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThreadPool">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> controls <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances
            and their thread assignments during indexing. Each <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> holds
            a reference to a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> that is once a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is obtained from the pool exclusively used for indexing a
            single document by the obtaining thread. Each indexing thread must obtain
            such a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> to make progress. Depending on the
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> implementation <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            assignments might differ from document to document.
            <para/>
            Once a <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is selected for flush the thread pool
            is reusing the flushing <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>s <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> with a
            new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> references and guards a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> instance that is used during indexing to
            build a in-memory index segment. <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> also holds all flush
            related per-thread data controlled by <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/>.
            <para/>
            A <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>, its methods and members should only accessed by one
            thread a time. Users must acquire the lock via <see cref="M:Lucene.Net.Support.Threading.ReentrantLock.Lock"/>
            and release the lock in a finally block via <see cref="M:Lucene.Net.Support.Threading.ReentrantLock.Unlock"/>
            (on the <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instance) before accessing the state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.Deactivate">
            <summary>
            Resets the internal <see cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/> with the given one.
            if the given DWPT is <c>null</c> this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is marked as inactive and should not be used
            for indexing anymore. </summary>
            <seealso cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.IsActive"/>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.IsActive">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is still open. This will
            only return <c>false</c> iff the DW has been disposed and this
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is already checked out for flush.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.BytesUsedPerThread">
            <summary>
            Returns the number of currently active bytes in this ThreadState's
            <see cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread">
            <summary>
            Returns this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s <see cref="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.DocumentsWriterPerThread"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState.IsFlushPending">
            <summary>
            Returns <c>true</c> iff this <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is marked as flush
            pending otherwise <c>false</c>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> with a given maximum of <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.MaxThreadStates">
            <summary>
            Returns the max number of <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances available in this
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocumentsWriterPerThreadPool.NumThreadStatesActive">
            <summary>
            Returns the active number of <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.NewThreadState">
            <summary>
            Returns a new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> iff any new state is available otherwise
            <c>null</c>.
            <para/>
            NOTE: the returned <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is already locked iff non-<c>null</c>.
            </summary>
            <returns> a new <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> iff any new state is available otherwise
                    <c>null</c> </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.DeactivateUnreleasedStates">
            <summary>
            Deactivate all unreleased threadstates
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.GetThreadState(System.Int32)">
            <summary>
            Returns the <i>i</i>th active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> where <i>i</i> is the
            given ord.
            </summary>
            <param name="ord">
                     the ordinal of the <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> </param>
            <returns> the <i>i</i>th active <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> where <i>i</i> is the
                    given ord. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.MinContendedThreadState">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> with the minimum estimated number of threads
            waiting to acquire its lock or <c>null</c> if no <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            is yet visible to the calling thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.NumDeactivatedThreadStates">
            <summary>
            Returns the number of currently deactivated <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances.
            A deactivated <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> should not be used for indexing anymore.
            </summary>
            <returns> the number of currently deactivated <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> instances. </returns>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterPerThreadPool.DeactivateThreadState(Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Deactivates an active <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. Inactive <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> can
            not be used for indexing anymore once they are deactivated. This method should only be used
            if the parent <see cref="T:Lucene.Net.Index.DocumentsWriter"/> is closed or aborted.
            </summary>
            <param name="threadState"> the state to deactivate </param>
        </member>
        <member name="T:Lucene.Net.Index.DocumentsWriterStallControl">
            <summary>
            Controls the health status of a <see cref="T:Lucene.Net.Index.DocumentsWriter"/> sessions. This class
            used to block incoming indexing threads if flushing significantly slower than
            indexing to ensure the <see cref="T:Lucene.Net.Index.DocumentsWriter"/>s healthiness. If flushing is
            significantly slower than indexing the net memory used within an
            <see cref="T:Lucene.Net.Index.IndexWriter"/> session can increase very quickly and easily exceed the
            runtime's available memory.
            <para/>
            To prevent OOM Errors and ensure <see cref="T:Lucene.Net.Index.IndexWriter"/>'s stability this class blocks
            incoming threads from indexing once 2 x number of available
            <see cref="T:System.Diagnostics.ThreadState"/>s in <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> is exceeded.
            Once flushing catches up and the number of flushing DWPT is equal or lower
            than the number of active <see cref="T:System.Diagnostics.ThreadState"/>s threads are released and can
            continue indexing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterStallControl.UpdateStalled(System.Boolean)">
            <summary>
            Update the stalled flag status. this method will set the stalled flag to
            <c>true</c> iff the number of flushing
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is greater than the number of active
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>. Otherwise it will reset the
            <see cref="T:Lucene.Net.Index.DocumentsWriterStallControl"/> to healthy and release all threads
            waiting on <see cref="M:Lucene.Net.Index.DocumentsWriterStallControl.WaitIfStalled"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocumentsWriterStallControl.WaitIfStalled">
             <summary>
             Blocks if documents writing is currently in a stalled state.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValues">
            <summary>
            This class contains utility methods and constants for <see cref="T:Lucene.Net.Index.DocValues"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_BINARY">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.BinaryDocValues"/> which returns <see cref="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES"/> for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_NUMERIC">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.NumericDocValues"/> which returns zero for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_SORTED">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.SortedDocValues"/> which returns <see cref="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES"/> for every document
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValues.EMPTY_SORTED_SET">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.SortedDocValues"/> which returns <see cref="F:Lucene.Net.Index.SortedSetDocValues.NO_MORE_ORDS"/> for every document
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.Singleton(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Returns a multi-valued view over the provided <see cref="T:Lucene.Net.Index.SortedDocValues"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.UnwrapSingleton(Lucene.Net.Index.SortedSetDocValues)">
            <summary>
            Returns a single-valued view of the <see cref="T:Lucene.Net.Index.SortedSetDocValues"/>, if it was previously
            wrapped with <see cref="M:Lucene.Net.Index.DocValues.Singleton(Lucene.Net.Index.SortedDocValues)"/>, or <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.DocsWithValue(Lucene.Net.Index.SortedDocValues,System.Int32)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> representing all documents from <paramref name="dv"/> that have a value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValues.DocsWithValue(Lucene.Net.Index.SortedSetDocValues,System.Int32)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.IBits"/> representing all documents from <paramref name="dv"/> that have a value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesFieldUpdates">
            <summary>
            Holds updates of a single <see cref="T:Lucene.Net.Index.DocValues"/> field, for a set of documents.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesFieldUpdates.Iterator">
            <summary>
            An iterator over documents and their updated values. Only documents with
            updates are returned by this iterator, and the documents are returned in
            increasing order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.NextDoc">
            <summary>
            Returns the next document which has an update, or
            <see cref="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS"/> if there are no more documents to
            return.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Doc">
            <summary>
            Returns the current document this iterator is on. </summary>
        </member>
        <member name="P:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Value">
            <summary>
            Returns the value of the document returned from <see cref="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.NextDoc"/>. A
            <c>null</c> value means that it was unset for this document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.Reset">
            <summary>
            Reset the iterator's state. Should be called before <see cref="M:Lucene.Net.Index.DocValuesFieldUpdates.Iterator.NextDoc"/>
            and <seealso cref="!:#value()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Add(System.Int32,System.Object)">
            <summary>
            Add an update to a document. For unsetting a value you should pass
            <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.GetIterator">
            <summary>
            Returns an <see cref="T:Lucene.Net.Index.DocValuesFieldUpdates.Iterator"/> over the updated documents and their
            values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Merge(Lucene.Net.Index.DocValuesFieldUpdates)">
            <summary>
            Merge with another <see cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/>. this is called for a
            segment which received updates while it was being merged. The given updates
            should override whatever updates are in that instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesFieldUpdates.Any">
            <summary>
            Returns true if this instance contains any updates. </summary>
            <returns> TODO </returns>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate">
            <summary>
            An in-place update to a <see cref="T:Lucene.Net.Index.DocValues"/> field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.DocValuesUpdate.#ctor(Lucene.Net.Index.DocValuesFieldUpdatesType,Lucene.Net.Index.Term,System.String,System.Object)">
            <summary>
            Constructor.
            </summary>
            <param name="type"> the <see cref="T:Lucene.Net.Index.DocValuesFieldUpdatesType"/> </param>
            <param name="term"> the <see cref="T:Lucene.Net.Index.Term"/> which determines the documents that will be updated </param>
            <param name="field"> the <see cref="T:Lucene.Net.Documents.NumericDocValuesField"/> to update </param>
            <param name="value"> the updated value </param>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate.BinaryDocValuesUpdate">
            <summary>
            An in-place update to a binary <see cref="T:Lucene.Net.Index.DocValues"/> field </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesUpdate.NumericDocValuesUpdate">
            <summary>
            An in-place update to a numeric <see cref="T:Lucene.Net.Index.DocValues"/> field </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfo">
            <summary>
             Access to the Field Info file that describes document fields and whether or
             not they are indexed. Each segment has a separate Field Info file. Objects
             of this class are thread-safe for multiple readers, but only one thread can
             be adding documents at a time, with no other reader or writer threads
             accessing this object.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.Name">
            <summary>
            Field's name </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.Number">
            <summary>
            Internal field number </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.#ctor(System.String,System.Boolean,System.Int32,System.Boolean,System.Boolean,System.Boolean,Lucene.Net.Index.IndexOptions,Lucene.Net.Index.DocValuesType,Lucene.Net.Index.DocValuesType,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sole Constructor.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.IndexOptions">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.IndexOptions"/> for the field, or <c>null</c> if the field is not indexed </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasDocValues">
            <summary>
            Returns <c>true</c> if this field has any docValues.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.DocValuesGen">
            <summary>
            Gets or Sets the docValues generation of this field, or -1 if no docValues. </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.NormType">
            <summary>
            Returns <see cref="T:Lucene.Net.Index.DocValuesType"/> of the norm. This may be <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> if the field has no norms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.OmitsNorms">
            <summary>
            Returns <c>true</c> if norms are explicitly omitted for this field
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasNorms">
            <summary>
            Returns <c>true</c> if this field actually has any norms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.IsIndexed">
            <summary>
            Returns <c>true</c> if this field is indexed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasPayloads">
            <summary>
            Returns <c>true</c> if any payloads exist for this field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.HasVectors">
            <summary>
            Returns <c>true</c> if any term vectors exist for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)">
            <summary>
            Get a codec attribute value, or <c>null</c> if it does not exist
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfo.PutAttribute(System.String,System.String)">
            <summary>
            Puts a codec attribute value.
            <para/>
            this is a key-value mapping for the field that the codec can use
            to store additional metadata, and will be available to the codec
            when reading the segment via <see cref="M:Lucene.Net.Index.FieldInfo.GetAttribute(System.String)"/>
            <para/>
            If a value already exists for the field, it will be replaced with
            the new value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfo.Attributes">
            <summary>
            Returns internal codec attributes map. May be <c>null</c> if no mappings exist.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexOptions">
            <summary>
            Controls how much information is stored in the postings lists.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.NONE">
            <summary>
            No index options will be used.
            <para/>
            NOTE: This is the same as setting to <c>null</c> in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_ONLY">
            <summary>
            Only documents are indexed: term frequencies and positions are omitted.
            Phrase and other positional queries on the field will throw an exception, and scoring
            will behave as if any term in the document appears only once.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS">
            <summary>
            Only documents and term frequencies are indexed: positions are omitted.
            this enables normal scoring, except Phrase and other positional queries
            will throw an exception.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS">
            <summary>
            Indexes documents, frequencies and positions.
            this is a typical default for full-text search: full scoring is enabled
            and positional queries are supported.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS">
            <summary>
            Indexes documents, frequencies, positions and offsets.
            Character offsets are encoded alongside the positions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.DocValuesType">
            <summary>
            DocValues types.
            Note that DocValues is strongly typed, so a field cannot have different types
            across different documents.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.NONE">
            <summary>
            No doc values type will be used.
            <para/>
            NOTE: This is the same as setting to <c>null</c> in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.NUMERIC">
            <summary>
            A per-document numeric type
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.BINARY">
            <summary>
            A per-document <see cref="T:byte[]"/>.  Values may be larger than
            32766 bytes, but different codecs may enforce their own limits.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.SORTED">
            <summary>
            A pre-sorted <see cref="T:byte[]"/>. Fields with this type only store distinct byte values
            and store an additional offset pointer per document to dereference the shared
            byte[]. The stored byte[] is presorted and allows access via document id,
            ordinal and by-value.  Values must be &lt;= 32766 bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.DocValuesType.SORTED_SET">
            <summary>
            A pre-sorted ISet&lt;byte[]&gt;. Fields with this type only store distinct byte values
            and store additional offset pointers per document to dereference the shared
            <see cref="T:byte[]"/>s. The stored <see cref="T:byte[]"/> is presorted and allows access via document id,
            ordinal and by-value.  Values must be &lt;= 32766 bytes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInfos">
            <summary>
            Collection of <see cref="T:Lucene.Net.Index.FieldInfo"/>s (accessible by number or by name).
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.#ctor(Lucene.Net.Index.FieldInfo[])">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Index.FieldInfos"/> from an array of <see cref="T:Lucene.Net.Index.FieldInfo"/> objects
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasFreq">
            <summary>
            Returns <c>true</c> if any fields have freqs </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasProx">
            <summary>
            Returns <c>true</c> if any fields have positions </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasPayloads">
            <summary>
            Returns <c>true</c> if any fields have payloads </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasOffsets">
            <summary>
            Returns <c>true</c> if any fields have offsets </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasVectors">
            <summary>
            Returns <c>true</c> if any fields have vectors </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasNorms">
            <summary>
            Returns <c>true</c> if any fields have norms </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.HasDocValues">
            <summary>
            Returns <c>true</c> if any fields have <see cref="T:Lucene.Net.Index.DocValues"/> </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInfos.Count">
            <summary>
            Returns the number of fields.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.GetEnumerator">
            <summary>
            Returns an iterator over all the fieldinfo objects present,
            ordered by ascending field number
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.String)">
            <summary>
            Return the <see cref="T:Lucene.Net.Index.FieldInfo"/> object referenced by the <paramref name="fieldName"/> </summary>
            <returns> the <see cref="T:Lucene.Net.Index.FieldInfo"/> object or <c>null</c> when the given <paramref name="fieldName"/>
            doesn't exist. </returns>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldInfo(System.Int32)">
            <summary>
            Return the <see cref="T:Lucene.Net.Index.FieldInfo"/> object referenced by the <paramref name="fieldNumber"/>. </summary>
            <param name="fieldNumber"> field's number. </param>
            <returns> the <see cref="T:Lucene.Net.Index.FieldInfo"/> object or null when the given <paramref name="fieldNumber"/>
            doesn't exist. </returns>
            <exception cref="T:System.ArgumentException"> if <paramref name="fieldNumber"/> is negative </exception>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldNumbers.AddOrGet(System.String,System.Int32,Lucene.Net.Index.DocValuesType)">
            <summary>
            Returns the global field number for the given field name. If the name
            does not exist yet it tries to add it with the given preferred field
            number assigned if possible otherwise the first unassigned field number
            is used as the field number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.FieldNumbers.Contains(System.String,Lucene.Net.Index.DocValuesType)">
            <summary>
            Returns <c>true</c> if the <paramref name="fieldName"/> exists in the map and is of the
            same <paramref name="dvType"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Builder.#ctor(Lucene.Net.Index.FieldInfos.FieldNumbers)">
            <summary>
            Creates a new instance with the given <see cref="T:Lucene.Net.Index.FieldInfos.FieldNumbers"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInfos.Builder.AddOrUpdate(System.String,Lucene.Net.Index.IIndexableFieldType)">
            <summary>
            NOTE: this method does not carry over termVector
            booleans nor docValuesType; the indexer chain
            (TermVectorsConsumerPerField, DocFieldProcessor) must
            set these fields when they succeed in consuming
            the document
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FieldInvertState">
            <summary>
            This class tracks the number and position / offset parameters of terms
            being added to the index. The information collected in this class is
            also used to calculate the normalization factor for a field.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.#ctor(System.String)">
            <summary>
            Creates <see cref="T:Lucene.Net.Index.FieldInvertState"/> for the specified
            field name.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.#ctor(System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
            Creates <see cref="T:Lucene.Net.Index.FieldInvertState"/> for the specified
            field name and values for all fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FieldInvertState.Reset">
            <summary>
            Re-initialize the state
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Position">
            <summary>
            Gets the last processed term position. </summary>
            <returns> the position </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Length">
            <summary>
            Gets or Sets total number of terms in this field. </summary>
            <returns> the length </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.NumOverlap">
            <summary>
            Gets or Sets the number of terms with <c>positionIncrement == 0</c>. </summary>
            <returns> the numOverlap </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Offset">
            <summary>
            Gets end offset of the last processed term. </summary>
            <returns> the offset </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Boost">
            <summary>
            Gets or Sets boost value. This is the cumulative product of
            document boost and field boost for all field instances
            sharing the same field name. </summary>
            <returns> the boost </returns>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.MaxTermFrequency">
            <summary>
            Get the maximum term-frequency encountered for any term in the field.  A
            field containing "the quick brown fox jumps over the lazy dog" would have
            a value of 2, because "the" appears twice.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.UniqueTermCount">
            <summary>
            Gets the number of unique terms encountered in this field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.AttributeSource">
            <summary>
            Gets the <see cref="T:Lucene.Net.Util.AttributeSource"/> from the
            <see cref="T:Lucene.Net.Analysis.TokenStream"/> that provided the indexed tokens for this
            field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FieldInvertState.Name">
            <summary>
            Gets the field's name
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Fields">
            <summary>
            Flex API for access to fields and terms
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.GetEnumerator">
            <summary>
            Returns an enumerator that will step through all field
            names.  This will not return <c>null</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Fields.GetTerms(System.String)">
            <summary>
            Get the <see cref="T:Lucene.Net.Index.Terms"/> for this field.  This will return
            <c>null</c> if the field does not exist.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Fields.Count">
            <summary>
            Gets the number of fields or -1 if the number of
            distinct field names is unknown. If &gt;= 0,
            <see cref="M:Lucene.Net.Index.Fields.GetEnumerator"/> will return as many field names.
            <para/>
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Fields.UniqueTermCount">
            <summary>
            Returns the number of terms for all fields, or -1 if this
            measure isn't stored by the codec. Note that, just like
            other term measures, this measure does not take deleted
            documents into account. 
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.Count"></seealso>
        </member>
        <member name="F:Lucene.Net.Index.Fields.EMPTY_ARRAY">
            <summary>
            Zero-length <see cref="T:Lucene.Net.Index.Fields"/> array.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader">
            <summary>
            A <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> contains another <see cref="T:Lucene.Net.Index.AtomicReader"/>, which it
            uses as its basic source of data, possibly transforming the data along the
            way or providing additional functionality. The class
            <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> itself simply implements all abstract methods
            of <see cref="T:Lucene.Net.Index.IndexReader"/> with versions that pass all requests to the
            contained index reader. Subclasses of <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> may
            further override some of these methods and may also provide additional
            methods and fields.
            <para/><b>NOTE</b>: If you override <see cref="P:Lucene.Net.Index.FilterAtomicReader.LiveDocs"/>, you will likely need
            to override <see cref="P:Lucene.Net.Index.FilterAtomicReader.NumDocs"/> as well and vice-versa.
            <para/><b>NOTE</b>: If this <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> does not change the
            content the contained reader, you could consider overriding
            <see cref="P:Lucene.Net.Index.IndexReader.CoreCacheKey"/> so that <see cref="T:Lucene.Net.Search.IFieldCache"/> and
            <see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> share the same entries for this atomic reader
            and the wrapped one. <see cref="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey"/> could be
            overridden as well if the <see cref="P:Lucene.Net.Index.FilterAtomicReader.LiveDocs"/> are not changed
            either.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.Unwrap(Lucene.Net.Index.AtomicReader)">
            <summary>
            Get the wrapped instance by <paramref name="reader"/> as long as this reader is
            an intance of <see cref="T:Lucene.Net.Index.FilterAtomicReader"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterFields">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.Fields"/>
            implementations.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterFields.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.Fields"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterFields.#ctor(Lucene.Net.Index.Fields)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterFields"/>. </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.Fields"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterTerms">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.Terms"/> implementations.
            <para/><b>NOTE</b>: If the order of terms and documents is not changed, and if
            these terms are going to be intersected with automata, you could consider
            overriding <see cref="M:Lucene.Net.Index.Terms.Intersect(Lucene.Net.Util.Automaton.CompiledAutomaton,Lucene.Net.Util.BytesRef)"/> for better performance.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterTerms.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.Terms"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterTerms.#ctor(Lucene.Net.Index.Terms)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterTerms"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.Terms"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.TermsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.TermsEnum"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum.#ctor(Lucene.Net.Index.TermsEnum)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterTermsEnum"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.TermsEnum"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.DocsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.DocsEnum"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum.#ctor(Lucene.Net.Index.DocsEnum)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsEnum"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.DocsEnum"/> instance. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum">
            <summary>
            Base class for filtering <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> implementations. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum.#ctor(Lucene.Net.Index.DocsAndPositionsEnum)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterAtomicReader.FilterDocsAndPositionsEnum"/> </summary>
            <param name="input"> the underlying <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> instance. </param>
        </member>
        <member name="F:Lucene.Net.Index.FilterAtomicReader.m_input">
            <summary>
            The underlying <see cref="T:Lucene.Net.Index.AtomicReader"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterAtomicReader.#ctor(Lucene.Net.Index.AtomicReader)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> based on the specified base reader.
            <para/>
            Note that base reader is closed if this <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> is closed.
            </summary>
            <param name="input"> specified base reader. </param>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader">
            <summary>
            A <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> wraps another <see cref="T:Lucene.Net.Index.DirectoryReader"/>, allowing implementations
            to transform or extend it.
            <para/>
            Subclasses should implement <see cref="M:Lucene.Net.Index.FilterDirectoryReader.DoWrapDirectoryReader(Lucene.Net.Index.DirectoryReader)"/> to return an instance of the
            subclass.
            <para/>
            If the subclass wants to wrap the <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s subreaders, it should also
            implement a <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> subclass, and pass an instance to its base
            constructor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper">
            <summary>
            Factory class passed to <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> constructor that allows
            subclasses to wrap the filtered <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s subreaders.  You
            can use this to, e.g., wrap the subreaders with specialized
            <see cref="T:Lucene.Net.Index.FilterAtomicReader"/> implementations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper.#ctor">
            <summary>
            Constructor </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper.Wrap(Lucene.Net.Index.AtomicReader)">
            <summary>
            Wrap one of the parent <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s subreaders </summary>
            <param name="reader"> the subreader to wrap </param>
            <returns> a wrapped/filtered <see cref="T:Lucene.Net.Index.AtomicReader"/> </returns>
        </member>
        <member name="T:Lucene.Net.Index.FilterDirectoryReader.StandardReaderWrapper">
            <summary>
            A no-op <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> that simply returns the parent
            <see cref="T:Lucene.Net.Index.DirectoryReader"/>'s original subreaders.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.StandardReaderWrapper.#ctor">
            <summary>
            Constructor </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilterDirectoryReader.m_input">
            <summary>
            The filtered <see cref="T:Lucene.Net.Index.DirectoryReader"/> </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.#ctor(Lucene.Net.Index.DirectoryReader)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> that filters a passed in <see cref="T:Lucene.Net.Index.DirectoryReader"/>. </summary>
            <param name="input"> the <see cref="T:Lucene.Net.Index.DirectoryReader"/> to filter </param>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.#ctor(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Index.FilterDirectoryReader"/> that filters a passed in <see cref="T:Lucene.Net.Index.DirectoryReader"/>,
            using the supplied <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> to wrap its subreader. </summary>
            <param name="input"> the <see cref="T:Lucene.Net.Index.DirectoryReader"/> to filter </param>
            <param name="wrapper"> the <see cref="T:Lucene.Net.Index.FilterDirectoryReader.SubReaderWrapper"/> to use to wrap subreaders </param>
        </member>
        <member name="M:Lucene.Net.Index.FilterDirectoryReader.DoWrapDirectoryReader(Lucene.Net.Index.DirectoryReader)">
            <summary>
            Called by the <see cref="M:Lucene.Net.Index.FilterDirectoryReader.DoOpenIfChanged"/> methods to return a new wrapped <see cref="T:Lucene.Net.Index.DirectoryReader"/>.
            <para/>
            Implementations should just return an instance of themselves, wrapping the
            passed in <see cref="T:Lucene.Net.Index.DirectoryReader"/>.
            </summary>
            <param name="input"> the <see cref="T:Lucene.Net.Index.DirectoryReader"/> to wrap </param>
            <returns> the wrapped <see cref="T:Lucene.Net.Index.DirectoryReader"/> </returns>
        </member>
        <member name="T:Lucene.Net.Index.FilteredTermsEnum">
            <summary>
            Abstract class for enumerating a subset of all terms.
            <para/>
            Term enumerations are always ordered by
            <see cref="P:Lucene.Net.Index.FilteredTermsEnum.Comparer"/>.  Each term in the enumeration is
            greater than all that precede it.
            <para/><c>Please note:</c> Consumers of this enumeration cannot
            call <c>Seek()</c>, it is forward only; it throws
            <see cref="T:System.NotSupportedException"/> when a seeking method
            is called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus">
            <summary>
            Return value, if term should be accepted or the iteration should
            <see cref="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.END"/>. The <c>*_SEEK</c> values denote, that after handling the current term
            the enum should call <see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/> and step forward. </summary>
            <seealso cref="M:Lucene.Net.Index.FilteredTermsEnum.Accept(Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES">
            <summary>
            Accept the term and position the enum at the next term. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES_AND_SEEK">
            <summary>
            Accept the term and advance (<see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>)
            to the next term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO">
            <summary>
            Reject the term and position the enum at the next term. </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO_AND_SEEK">
            <summary>
            Reject the term and advance (<see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>)
            to the next term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.END">
            <summary>
            Reject the term and stop enumerating. </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            Return if term is accepted, not accepted or the iteration should ended
            (and possibly seek).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.#ctor(Lucene.Net.Index.TermsEnum)">
            <summary>
            Creates a filtered <see cref="T:Lucene.Net.Index.TermsEnum"/> on a terms enum. </summary>
            <param name="tenum"> the terms enumeration to filter. </param>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,System.Boolean)">
            <summary>
            Creates a filtered <see cref="T:Lucene.Net.Index.TermsEnum"/> on a terms enum. </summary>
            <param name="tenum"> the terms enumeration to filter. </param>
            <param name="startWithSeek"> start with seek </param>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SetInitialSeekTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            Use this method to set the initial <see cref="T:Lucene.Net.Util.BytesRef"/>
            to seek before iterating. This is a convenience method for
            subclasses that do not override <see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>.
            If the initial seek term is <c>null</c> (default),
            the enum is empty.
            <para/>You can only use this method, if you keep the default
            implementation of <see cref="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.NextSeekTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            On the first call to <see cref="M:Lucene.Net.Index.FilteredTermsEnum.Next"/> or if <see cref="M:Lucene.Net.Index.FilteredTermsEnum.Accept(Lucene.Net.Util.BytesRef)"/> returns
            <see cref="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.YES_AND_SEEK"/> or <see cref="F:Lucene.Net.Index.FilteredTermsEnum.AcceptStatus.NO_AND_SEEK"/>,
            this method will be called to eventually seek the underlying <see cref="T:Lucene.Net.Index.TermsEnum"/>
            to a new position.
            On the first call, <paramref name="currentTerm"/> will be <c>null</c>, later
            calls will provide the term the underlying enum is positioned at.
            This method returns per default only one time the initial seek term
            and then <c>null</c>, so no repositioning is ever done.
            <para/>
            Override this method, if you want a more sophisticated <see cref="T:Lucene.Net.Index.TermsEnum"/>,
            that repositions the iterator during enumeration.
            If this method always returns <c>null</c> the enum is empty.
            <para/><c>Please note:</c> this method should always provide a greater term
            than the last enumerated term, else the behavior of this enum
            violates the contract for <see cref="T:Lucene.Net.Index.TermsEnum"/>s.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FilteredTermsEnum.Attributes">
            <summary>
            Returns the related attributes, the returned <see cref="T:Lucene.Net.Util.AttributeSource"/>
            is shared with the delegate <see cref="T:Lucene.Net.Index.TermsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(System.Int64)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)">
            <summary>
            this enum does not support seeking! </summary>
            <exception cref="T:System.NotSupportedException"> In general, subclasses do not
                    support seeking. </exception>
        </member>
        <member name="M:Lucene.Net.Index.FilteredTermsEnum.GetTermState">
            <summary>
            Returns the filtered enums term state
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FlushByRamOrCountsPolicy">
             <summary>
             Default <see cref="T:Lucene.Net.Index.FlushPolicy"/> implementation that flushes new segments based on
             RAM used and document count depending on the <see cref="T:Lucene.Net.Index.IndexWriter"/>'s
             <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>. It also applies pending deletes based on the
             number of buffered delete terms.
            
             <list type="bullet">
                 <item>
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnDelete(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     - applies pending delete operations based on the global number of buffered
                     delete terms iff <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/> is
                     enabled
                 </item>
                 <item>
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnInsert(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     - flushes either on the number of documents per
                     <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> (
                     <see cref="P:Lucene.Net.Index.DocumentsWriterPerThread.NumDocsInRAM"/>) or on the global active
                     memory consumption in the current indexing session iff
                     <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/> or
                     <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> is enabled respectively
                 </item>
                 <item>
                     <see cref="M:Lucene.Net.Index.FlushPolicy.OnUpdate(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     - calls
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnInsert(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     and
                     <see cref="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.OnDelete(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>
                     in order
                 </item>
             </list>
             All <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> settings are used to mark
             <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> as flush pending during indexing with
             respect to their live updates.
             <para/>
             If <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> (setter) is enabled, the
             largest ram consuming <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> will be marked as
             pending iff the global active RAM consumption is &gt;= the configured max RAM
             buffer.
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushByRamOrCountsPolicy.MarkLargestWriterPending(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState,System.Int64)">
            <summary>
            Marks the most ram consuming active <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> flush
            pending
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnDocCount">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnDeleteTerms">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.FlushByRamOrCountsPolicy.FlushOnRAM">
            <summary>
            Returns <c>true</c> if this <see cref="T:Lucene.Net.Index.FlushPolicy"/> flushes on
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>, otherwise
            <c>false</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FlushPolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.FlushPolicy"/> controls when segments are flushed from a RAM resident
            internal data-structure to the <see cref="T:Lucene.Net.Index.IndexWriter"/>s <see cref="T:Lucene.Net.Store.Directory"/>.
            <para/>
            Segments are traditionally flushed by:
            <list type="bullet">
                <item>RAM consumption - configured via
                    <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/></item>
                <item>Number of RAM resident documents - configured via
                    <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/></item>
            </list>
            The policy also applies pending delete operations (by term and/or query),
            given the threshold set in
            <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>.
            <para/>
            <see cref="T:Lucene.Net.Index.IndexWriter"/> consults the provided <seea cref="T:Lucene.Net.Index.FlushPolicy"/> to control the
            flushing process. The policy is informed for each added or updated document
            as well as for each delete term. Based on the <see cref="T:Lucene.Net.Index.FlushPolicy"/>, the
            information provided via <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> and
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/>, the <see cref="T:Lucene.Net.Index.FlushPolicy"/> decides if a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> needs flushing and mark it as flush-pending
            via <see cref="M:Lucene.Net.Index.DocumentsWriterFlushControl.SetFlushPending(Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)"/>, or if deletes need
            to be applied.
            </summary>
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/>
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy"/>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.OnDelete(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Called for each delete term. If this is a delete triggered due to an update
            the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is non-null.
            <para/>
            Note: this method is called synchronized on the given
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/> and it is guaranteed that the calling
            thread holds the lock on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.OnUpdate(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Called for each document update on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>'s
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>.
            <para/>
            Note: this method is called  synchronized on the given
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/> and it is guaranteed that the calling
            thread holds the lock on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.OnInsert(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Called for each document addition on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>.
            <para/>
            Note: this method is synchronized by the given
            <see cref="T:Lucene.Net.Index.DocumentsWriterFlushControl"/> and it is guaranteed that the calling
            thread holds the lock on the given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.Init(Lucene.Net.Index.LiveIndexWriterConfig)">
            <summary>
            Called by <see cref="T:Lucene.Net.Index.DocumentsWriter"/> to initialize the <see cref="T:Lucene.Net.Index.FlushPolicy"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FlushPolicy.FindLargestNonPendingWriter(Lucene.Net.Index.DocumentsWriterFlushControl,Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState)">
            <summary>
            Returns the current most RAM consuming non-pending <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> with
            at least one indexed document.
            <para/>
            This method will never return <c>null</c>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.FreqProxTermsWriterPerField.Flush(System.String,Lucene.Net.Codecs.FieldsConsumer,Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Walk through all unique text tokens (Posting
            instances) found in this field and serialize them
            into a single RAM segment.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.FrozenBufferedUpdates">
            <summary>
            Holds buffered deletes and updates by term or query, once pushed. Pushed
            deletes/updates are write-once, so we shift to more memory efficient data
            structure to hold them. We don't hold docIDs because these are applied on
            flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.BYTES_PER_DEL_QUERY">
            <summary>Query we often undercount (say 24 bytes), plus int.</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.terms">
            <summary>Terms, in sorted order:</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.queries">
            <summary>Parallel array of deleted query, and the docIDUpto for each</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.numericDVUpdates">
            <summary>numeric DV update term and their updates</summary>
        </member>
        <member name="F:Lucene.Net.Index.FrozenBufferedUpdates.binaryDVUpdates">
            <summary>binary DV update term and their updates</summary>
        </member>
        <member name="T:Lucene.Net.Index.IIndexableField">
            <summary>
            Represents a single field for indexing. <see cref="T:Lucene.Net.Index.IndexWriter"/>
            consumes IEnumerable&lt;IndexableField&gt; as a document.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableField.Name">
            <summary>
            Field name </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableField.FieldType">
            <summary>
            <see cref="T:Lucene.Net.Index.IIndexableFieldType"/> describing the properties
            of this field.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableField.Boost">
            <summary>
            Returns the field's index-time boost.
            <para/>
            Only fields can have an index-time boost, if you want to simulate
            a "document boost", then you must pre-multiply it across all the
            relevant fields yourself.
            <para/>
            The boost is used to compute the norm factor for the field.  By
            default, in the <see cref="M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/> method,
            the boost value is multiplied by the length normalization factor and then
            rounded by <see cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)"/> before it is stored in the
            index.  One should attempt to ensure that this product does not overflow
            the range of that encoding.
            <para/>
            It is illegal to return a boost other than 1.0f for a field that is not
            indexed (<see cref="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed"/> is false) or omits normalization values
            (<see cref="P:Lucene.Net.Index.IIndexableFieldType.OmitNorms"/> returns true).
            </summary>
            <seealso cref="M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)"/>
            <seealso cref="M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetBinaryValue">
            <summary>
            Non-null if this field has a binary value </summary>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetStringValue">
            <summary>
            Non-null if this field has a string value </summary>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetReaderValue">
            <summary>
            Non-null if this field has a <see cref="T:System.IO.TextReader"/> value </summary>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetNumericValue">
            <summary>
            Non-null if this field has a numeric value </summary>
        </member>
        <member name="M:Lucene.Net.Index.IIndexableField.GetTokenStream(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates the <see cref="T:Lucene.Net.Analysis.TokenStream"/> used for indexing this field.  If appropriate,
            implementations should use the given <see cref="T:Lucene.Net.Analysis.Analyzer"/> to create the <see cref="T:Lucene.Net.Analysis.TokenStream"/>s.
            </summary>
            <param name="analyzer"> <see cref="T:Lucene.Net.Analysis.Analyzer"/> that should be used to create the <see cref="T:Lucene.Net.Analysis.TokenStream"/>s from </param>
            <returns> <see cref="T:Lucene.Net.Analysis.TokenStream"/> value for indexing the document.  Should always return
                    a non-null value if the field is to be indexed </returns>
            <exception cref="T:System.IO.IOException"> Can be thrown while creating the <see cref="T:Lucene.Net.Analysis.TokenStream"/> </exception>
        </member>
        <member name="T:Lucene.Net.Index.IIndexableFieldType">
            <summary>
            Describes the properties of a field.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed">
            <summary>
            <c>true</c> if this field should be indexed (inverted) </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IsStored">
            <summary>
            <c>true</c> if the field's value should be stored </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IsTokenized">
            <summary>
            <c>true</c> if this field's value should be analyzed by the
            <see cref="T:Lucene.Net.Analysis.Analyzer"/>.
            <para/>
            This has no effect if <see cref="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed"/> returns <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors">
            <summary>
            <c>true</c> if this field's indexed form should be also stored
            into term vectors.
            <para/>
            this builds a miniature inverted-index for this field which
            can be accessed in a document-oriented way from
            <see cref="M:Lucene.Net.Index.IndexReader.GetTermVector(System.Int32,System.String)"/>.
            <para/>
            This option is illegal if <see cref="P:Lucene.Net.Index.IIndexableFieldType.IsIndexed"/> returns <c>false</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectorOffsets">
            <summary>
            <c>true</c> if this field's token character offsets should also
            be stored into term vectors.
            <para/>
            This option is illegal if term vectors are not enabled for the field
            (<see cref="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors"/> is <c>false</c>)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectorPositions">
            <summary>
            <c>true</c> if this field's token positions should also be stored
            into the term vectors.
            <para/>
            This option is illegal if term vectors are not enabled for the field
            (<see cref="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors"/> is <c>false</c>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectorPayloads">
            <summary>
            <c>true</c> if this field's token payloads should also be stored
            into the term vectors.
            <para/>
            This option is illegal if term vector positions are not enabled
            for the field (<see cref="P:Lucene.Net.Index.IIndexableFieldType.StoreTermVectors"/> is <c>false</c>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.OmitNorms">
            <summary>
            <c>true</c> if normalization values should be omitted for the field.
            <para/>
            This saves memory, but at the expense of scoring quality (length normalization
            will be disabled), and if you omit norms, you cannot use index-time boosts.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.IndexOptions">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexOptions"/>, describing what should be
            recorded into the inverted index
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IIndexableFieldType.DocValueType">
            <summary>
            DocValues <see cref="T:Lucene.Net.Index.DocValuesType"/>: if not <see cref="F:Lucene.Net.Index.DocValuesType.NONE"/> then the field's value
            will be indexed into docValues.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexCommit">
             <summary>
             <para>Expert: represents a single commit into an index as seen by the
             <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> or <see cref="T:Lucene.Net.Index.IndexReader"/>.</para>
            
             <para> Changes to the content of an index are made visible
             only after the writer who made that change commits by
             writing a new segments file
             (<c>segments_N</c>). This point in time, when the
             action of writing of a new segments file to the directory
             is completed, is an index commit.</para>
            
             <para>Each index commit point has a unique segments file
             associated with it. The segments file associated with a
             later index commit point would have a larger N.</para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.SegmentsFileName">
            <summary>
            Get the segments file (<c>segments_N</c>) associated
            with this commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.FileNames">
            <summary>
            Returns all index files referenced by this commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.Directory">
            <summary>
            Returns the <see cref="T:Lucene.Net.Store.Directory"/> for the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.Delete">
            <summary>
            Delete this commit point.  This only applies when using
            the commit point in the context of <see cref="T:Lucene.Net.Index.IndexWriter"/>'s
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>.
            <para/>
            Upon calling this, the writer is notified that this commit
            point should be deleted.
            <para/>
            Decision that a commit-point should be deleted is taken by the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> in effect
            and therefore this should only be called by its <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})"/> or
            <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})"/> methods.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.IsDeleted">
            <summary>
            Returns <c>true</c> if this commit should be deleted; this is
            only used by <see cref="T:Lucene.Net.Index.IndexWriter"/> after invoking the
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.SegmentCount">
            <summary>
            Returns number of segments referenced by this commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexCommit.Equals(System.Object)">
            <summary>
            Two IndexCommits are equal if both their <see cref="T:Lucene.Net.Store.Directory"/> and versions are equal. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.Generation">
            <summary>
            Returns the generation (the _N in segments_N) for this
            <see cref="T:Lucene.Net.Index.IndexCommit"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexCommit.UserData">
            <summary>
            Returns userData, previously passed to 
            <see cref="M:Lucene.Net.Index.IndexWriter.SetCommitData(System.Collections.Generic.IDictionary{System.String,System.String})"/>} for this commit.  
            The dictionary is <see cref="T:System.String"/> -> <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexDeletionPolicy">
             <summary>
             <para>Expert: policy for deletion of stale <see cref="T:Lucene.Net.Index.IndexCommit"/>s.</para>
            
             <para>Implement this interface, and pass it to one
             of the <see cref="T:Lucene.Net.Index.IndexWriter"/> or <see cref="T:Lucene.Net.Index.IndexReader"/>
             constructors, to customize when older
             point-in-time commits (<see cref="T:Lucene.Net.Index.IndexCommit"/>)
             are deleted from the index directory.  The default deletion policy
             is <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>, which always
             removes old commits as soon as a new commit is done (this
             matches the behavior before 2.2).</para>
            
             <para>One expected use case for this (and the reason why it
             was first created) is to work around problems with an
             index directory accessed via filesystems like NFS because
             NFS does not provide the "delete on last close" semantics
             that Lucene's "point in time" search normally relies on.
             By implementing a custom deletion policy, such as "a
             commit is only removed once it has been stale for more
             than X minutes", you can give your readers time to
             refresh to the new commit before <see cref="T:Lucene.Net.Index.IndexWriter"/>
             removes the old commits.  Note that doing so will
             increase the storage requirements of the index.  See <a
             target="top"
             href="http://issues.apache.org/jira/browse/LUCENE-710">LUCENE-710</a>
             for details.</para>
            
             <para>Implementers of sub-classes should make sure that <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.Clone"/>
             returns an independent instance able to work with any other <see cref="T:Lucene.Net.Index.IndexWriter"/>
             or <see cref="T:Lucene.Net.Store.Directory"/> instance.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexDeletionPolicy.#ctor">
            <summary>
            Sole constructor, typically called by sub-classes constructors. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})">
             <summary>
             <para>this is called once when a writer is first
             instantiated to give the policy a chance to remove old
             commit points.</para>
            
             <para>The writer locates all index commits present in the
             index directory and calls this method.  The policy may
             choose to delete some of the commit points, doing so by
             calling method <seealso cref="!:IndexCommit#delete delete()"/>
             of <seealso cref="T:Lucene.Net.Index.IndexCommit"/>.</para>
            
             <para><u>Note:</u> the last CommitPoint is the most recent one,
             i.e. the "front index state". Be careful not to delete it,
             unless you know for sure what you are doing, and unless
             you can afford to lose the index content while doing that.</para>
             </summary>
             <param name="commits"> List of current point-in-time commits
             (<see cref="T:Lucene.Net.Index.IndexCommit"/>),
             sorted by age (the 0th one is the oldest commit).
             Note that for a new index this method is invoked with
             an empty list. </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})">
             <summary>
             <para>this is called each time the writer completed a commit.
             this gives the policy a chance to remove old commit points
             with each commit.</para>
            
             <para>The policy may now choose to delete old commit points
             by calling method <see cref="M:Lucene.Net.Index.IndexCommit.Delete"/>
             of <see cref="T:Lucene.Net.Index.IndexCommit"/>.</para>
            
             <para>This method is only called when
             <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>} or <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> is
             called, or possibly not at all if the 
             <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>} method is called.</para>
            
             <para><u>Note:</u> the last CommitPoint is the most recent one,
             i.e. the "front index state". Be careful not to delete it,
             unless you know for sure what you are doing, and unless
             you can afford to lose the index content while doing that.</para>
             </summary>
             <param name="commits"> List of <see cref="T:Lucene.Net.Index.IndexCommit"/>s,
             sorted by age (the 0th one is the oldest commit). </param>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter">
            <summary>
            This class keeps track of each SegmentInfos instance that
            is still "live", either because it corresponds to a
            segments_N file in the <see cref="T:Lucene.Net.Store.Directory"/> (a "commit", i.e. a
            committed <see cref="T:Lucene.Net.Index.SegmentInfos"/>) or because it's an in-memory
            <see cref="T:Lucene.Net.Index.SegmentInfos"/> that a writer is actively updating but has
            not yet committed.  This class uses simple reference
            counting to map the live <see cref="T:Lucene.Net.Index.SegmentInfos"/> instances to
            individual files in the <see cref="T:Lucene.Net.Store.Directory"/>.
            <para/>
            The same directory file may be referenced by more than
            one <see cref="T:Lucene.Net.Index.IndexCommit"/>, i.e. more than one <see cref="T:Lucene.Net.Index.SegmentInfos"/>.
            Therefore we count how many commits reference each file.
            When all the commits referencing a certain file have been
            deleted, the refcount for that file becomes zero, and the
            file is deleted.
            <para/>
            A separate deletion policy interface
            (<see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/>) is consulted on creation (OnInit)
            and once per commit (OnCommit), to decide when a commit
            should be removed.
            <para/>
            It is the business of the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to choose
            when to delete commit points.  The actual mechanics of
            file deletion, retrying, etc, derived from the deletion
            of commit points is the business of the <see cref="T:Lucene.Net.Index.IndexFileDeleter"/>.
            <para/>
            The current default deletion policy is
            <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>, which removes all
            prior commits when a new commit has completed.  This
            matches the behavior before 2.2.
            <para/>
            Note that you must hold the <c>write.lock</c> before
            instantiating this class.  It opens segments_N file(s)
            directly with no retry logic.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.deletable">
            <summary>
            Files that we tried to delete but failed (likely
            because they are open and we are running on Windows),
            so we will retry them again later:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.refCounts">
            <summary>
            Reference count for all files in the index.
            Counts how many existing commits reference a file.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.commits">
            <summary>
            Holds all commits (segments_N) currently in the index.
            this will have just 1 commit if you are using the
            default delete policy (KeepOnlyLastCommitDeletionPolicy).
            Other policies may leave commit points live for longer
            in which case this list would be longer than 1:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.lastFiles">
            <summary>
            Holds files we had incref'd from the previous
            non-commit checkpoint:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.commitsToDelete">
            <summary>
            Commits that the IndexDeletionPolicy have decided to delete:
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileDeleter.VERBOSE_REF_COUNTS">
            <summary>
            Change to true to see details of reference counts when
            infoStream is enabled
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Index.SegmentInfos,Lucene.Net.Util.InfoStream,Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Initialize the deleter: find all previous commits in
            the <see cref="T:Lucene.Net.Store.Directory"/>, incref the files they reference, call
            the policy to let it delete commits.  this will remove
            any files not referenced by any of the commits. </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteCommits">
            <summary>
            Remove the CommitPoints in the commitsToDelete List by
            DecRef'ing all files from each SegmentInfos.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Refresh(System.String)">
            <summary>
            Writer calls this when it has hit an error and had to
            roll back, to tell us that there may now be
            unreferenced files in the filesystem.  So we re-list
            the filesystem and delete such files.  If <paramref name="segmentName"/>
            is non-null, we will only delete files corresponding to
            that segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.RevisitPolicy">
            <summary>
            Revisits the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> by calling its
            <see cref="M:Lucene.Net.Index.IndexDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})"/> again with the known commits.
            this is useful in cases where a deletion policy which holds onto index
            commits is used. The application may know that some commits are not held by
            the deletion policy anymore and call
            <see cref="M:Lucene.Net.Index.IndexWriter.DeleteUnusedFiles"/>, which will attempt to delete the
            unused commits again.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.Checkpoint(Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary>
            For definition of "check point" see <see cref="T:Lucene.Net.Index.IndexWriter"/> comments:
            "Clarification: Check Points (and commits)".
            <para/>
            Writer calls this when it has made a "consistent
            change" to the index, meaning new files are written to
            the index and the in-memory <see cref="T:Lucene.Net.Index.SegmentInfos"/> have been
            modified to point to those files.
            <para/>
            This may or may not be a commit (segments_N may or may
            not have been written).
            <para/>
            We simply incref the files referenced by the new
            <see cref="T:Lucene.Net.Index.SegmentInfos"/> and decref the files we had previously
            seen (if any).
            <para/>
            If this is a commit, we also call the policy to give it
            a chance to remove other commits.  If any commits are
            removed, we decref their files as well.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Deletes the specified files, but only if they are new
            (have not yet been incref'd).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.RefCount">
            <summary>
            Tracks the reference count for a single index file:
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileDeleter.CommitPoint">
            <summary>
            Holds details for each commit point.  This class is
            also passed to the deletion policy.  Note: this class
            has a natural ordering that is inconsistent with
            equals.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileDeleter.CommitPoint.Delete">
            <summary>
            Called only by the deletion policy, to remove this
            commit point from the index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFileNames">
             <summary>
             This class contains useful constants representing filenames and extensions
             used by lucene, as well as convenience methods for querying whether a file
             name matches an extension (<see cref="M:Lucene.Net.Index.IndexFileNames.MatchesExtension(System.String,System.String)"/>), 
             as well as generating file names from a segment name,
             generation and extension 
             (<see cref="M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)"/>,
             <see cref="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)"/>).
            
             <para/><b>NOTE</b>: extensions used by codecs are not
             listed here.  You must interact with the <see cref="T:Lucene.Net.Codecs.Codec"/>
             directly.
             <para/>
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.#ctor">
            <summary>
            No instance </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS">
            <summary>
            Name of the index segment file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.GEN_EXTENSION">
            <summary>
            Extension of gen file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.SEGMENTS_GEN">
            <summary>
            Name of the generation reference file name </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_EXTENSION">
            <summary>
            Extension of compound file </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.COMPOUND_FILE_ENTRIES_EXTENSION">
            <summary>
            Extension of compound file entries </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.INDEX_EXTENSIONS">
            <summary>
            This array contains all filename extensions used by
            Lucene's index files, with one exception, namely the
            extension made up from  <c>.s</c> + a number.
            Also note that Lucene's <c>segments_N</c> files
            do not have any filename extension.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)">
            <summary>
            Computes the full file name from base, extension and generation. If the
            generation is -1, the file name is <c>null</c>. If it's 0, the file name is
            &lt;base&gt;.&lt;ext&gt;. If it's > 0, the file name is
            &lt;base&gt;_&lt;gen&gt;.&lt;ext&gt;.
            <para/>
            <b>NOTE:</b> .&lt;ext&gt; is added to the name only if <c>ext</c> is
            not an empty string.
            </summary>
            <param name="base"> main part of the file name </param>
            <param name="ext"> extension of the filename </param>
            <param name="gen"> generation </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)">
            <summary>
            Returns a file name that includes the given segment name, your own custom
            name and extension. The format of the filename is:
            &lt;segmentName&gt;(_&lt;name&gt;)(.&lt;ext&gt;).
            <para/>
            <b>NOTE:</b> .&lt;ext&gt; is added to the result file name only if
            <code>ext</code> is not empty.
            <para/>
            <b>NOTE:</b> _&lt;segmentSuffix&gt; is added to the result file name only if
            it's not the empty string
            <para/>
            <b>NOTE:</b> all custom files should be named using this method, or
            otherwise some structures may fail to handle them properly (such as if they
            are added to compound files).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.MatchesExtension(System.String,System.String)">
            <summary>
            Returns <c>true</c> if the given filename ends with the given extension. One
            should provide a <i>pure</i> extension, without '.'.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.IndexOfSegmentName(System.String)">
            <summary>
            Locates the boundary of the segment name, or -1 </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.StripSegmentName(System.String)">
            <summary>
            Strips the segment name out of the given file name. If you used
            <see cref="M:Lucene.Net.Index.IndexFileNames.SegmentFileName(System.String,System.String,System.String)"/> or <see cref="M:Lucene.Net.Index.IndexFileNames.FileNameFromGeneration(System.String,System.String,System.Int64)"/> to create your
            files, then this method simply removes whatever comes before the first '.',
            or the second '_' (excluding both).
            </summary>
            <returns> the filename with the segment name removed, or the given filename
                    if it does not contain a '.' and '_'. </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.ParseSegmentName(System.String)">
            <summary>
            Parses the segment name out of the given file name.
            </summary>
            <returns> the segment name only, or filename
                    if it does not contain a '.' and '_'. </returns>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.StripExtension(System.String)">
            <summary>
            Removes the extension (anything after the first '.'),
            otherwise returns the original filename.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFileNames.GetExtension(System.String)">
            <summary>
            Return the extension (anything after the first '.'),
            or null if there is no '.' in the file name.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexFileNames.CODEC_FILE_PATTERN">
            <summary>
            All files created by codecs much match this pattern (checked in
            <see cref="T:Lucene.Net.Index.SegmentInfo"/>).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexFormatTooNewException">
            <summary>
            This exception is thrown when Lucene detects
            an index that is newer than this Lucene version.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooNewException"/>
            <para/>
            @lucene.internal
            </summary>
            <param name="resourceDesc"> describes the file that was too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooNewException"/>
            <para/>
            @lucene.internal
            </summary>
            <param name="input"> the open file that's too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooNewException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.IndexFormatTooOldException">
            <summary>
            This exception is thrown when Lucene detects
            an index that is too old for this Lucene version
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.String,System.String)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="resourceDesc"> describes the file that was too old </param>
            <param name="version"> the version of the file that was too old </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(Lucene.Net.Store.DataInput,System.String)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="input"> the open file that's too old </param>
            <param name="version"> the version of the file that was too old </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="resourceDesc"> describes the file that was too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Index.IndexFormatTooOldException"/>.
            <para/>
            @lucene.internal
            </summary>
            <param name="input"> the open file that's too old </param>
            <param name="version"> the version of the file that was too old </param>
            <param name="minVersion"> the minimum version accepted </param>
            <param name="maxVersion"> the maxium version accepted </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexFormatTooOldException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.IndexNotFoundException">
            <summary>
            Signals that no index was found in the <see cref="T:System.IO.Directory"/>. Possibly because the
            directory is empty, however can also indicate an index corruption.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexNotFoundException.#ctor(System.String)">
            <summary>
            Creates <see cref="T:Lucene.Net.Index.IndexNotFoundException"/> with the
            description message.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexNotFoundException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.IndexReader">
             <summary>
             <see cref="T:Lucene.Net.Index.IndexReader"/> is an abstract class, providing an interface for accessing an
             index.  Search of an index is done entirely through this abstract interface,
             so that any subclass which implements it is searchable.
            
             <para/>There are two different types of <see cref="T:Lucene.Net.Index.IndexReader"/>s:
             <list type="bullet">
                 <item><see cref="T:Lucene.Net.Index.AtomicReader"/>: These indexes do not consist of several sub-readers,
                     they are atomic. They support retrieval of stored fields, doc values, terms,
                     and postings.</item>
                 <item><see cref="T:Lucene.Net.Index.CompositeReader"/>: Instances (like <see cref="T:Lucene.Net.Index.DirectoryReader"/>)
                     of this reader can only
                     be used to get stored fields from the underlying <see cref="T:Lucene.Net.Index.AtomicReader"/>s,
                     but it is not possible to directly retrieve postings. To do that, get
                     the sub-readers via <see cref="M:Lucene.Net.Index.CompositeReader.GetSequentialSubReaders"/>.
                     Alternatively, you can mimic an <see cref="T:Lucene.Net.Index.AtomicReader"/> (with a serious slowdown),
                     by wrapping composite readers with <see cref="T:Lucene.Net.Index.SlowCompositeReaderWrapper"/>.</item>
             </list>
            
             <para/><see cref="T:Lucene.Net.Index.IndexReader"/> instances for indexes on disk are usually constructed
             with a call to one of the static <c>DirectoryReader.Open()</c> methods,
             e.g. <seealso cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory)"/>. <see cref="T:Lucene.Net.Index.DirectoryReader"/> inherits
             the <see cref="T:Lucene.Net.Index.CompositeReader"/> abstract class, it is not possible to directly get postings.
            
             <para/> For efficiency, in this API documents are often referred to via
             <i>document numbers</i>, non-negative integers which each name a unique
             document in the index.  These document numbers are ephemeral -- they may change
             as documents are added to and deleted from an index.  Clients should thus not
             rely on a given document having the same number between sessions.
            
             <para/>
             <b>NOTE</b>: <see cref="T:Lucene.Net.Index.IndexReader"/> instances are completely thread
             safe, meaning multiple threads can call any of its methods,
             concurrently.  If your application requires external
             synchronization, you should <b>not</b> synchronize on the
             <see cref="T:Lucene.Net.Index.IndexReader"/> instance; use your own
             (non-Lucene) objects instead.
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexReader.IReaderClosedListener">
            <summary>
            A custom listener that's invoked when the <see cref="T:Lucene.Net.Index.IndexReader"/>
            is closed.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IReaderClosedListener.OnClose(Lucene.Net.Index.IndexReader)">
            <summary>
            Invoked when the <see cref="T:Lucene.Net.Index.IndexReader"/> is closed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.AddReaderClosedListener(Lucene.Net.Index.IndexReader.IReaderClosedListener)">
            <summary>
            Expert: adds a <see cref="T:Lucene.Net.Index.IndexReader.IReaderClosedListener"/>.  The
            provided listener will be invoked when this reader is closed.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.RemoveReaderClosedListener(Lucene.Net.Index.IndexReader.IReaderClosedListener)">
            <summary>
            Expert: remove a previously added <see cref="T:Lucene.Net.Index.IndexReader.IReaderClosedListener"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.RegisterParentReader(Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: this method is called by <see cref="T:Lucene.Net.Index.IndexReader"/>s which wrap other readers
            (e.g. <see cref="T:Lucene.Net.Index.CompositeReader"/> or <see cref="T:Lucene.Net.Index.FilterAtomicReader"/>) to register the parent
            at the child (this reader) on construction of the parent. When this reader is disposed,
            it will mark all registered parents as disposed, too. The references to parent readers
            are weak only, so they can be GCed once they are no longer in use.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.RefCount">
            <summary>
            Expert: returns the current refCount for this reader </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.IncRef">
            <summary>
            Expert: increments the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> of this <see cref="T:Lucene.Net.Index.IndexReader"/>
            instance.  <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/>s are used to determine when a
            reader can be disposed safely, i.e. as soon as there are
            no more references.  Be sure to always call a
            corresponding <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, in a finally clause;
            otherwise the reader may never be disposed.  Note that
            <see cref="M:Lucene.Net.Index.IndexReader.Dispose(System.Boolean)"/> simply calls <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, which means that
            the <see cref="T:Lucene.Net.Index.IndexReader"/> will not really be disposed until
            <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/> has been called for all outstanding
            references.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DecRef"/>
            <seealso cref="M:Lucene.Net.Index.IndexReader.TryIncRef"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.TryIncRef">
            <summary>
            Expert: increments the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> of this <see cref="T:Lucene.Net.Index.IndexReader"/>
            instance only if the <see cref="T:Lucene.Net.Index.IndexReader"/> has not been disposed yet
            and returns <c>true</c> iff the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> was
            successfully incremented, otherwise <c>false</c>.
            If this method returns <c>false</c> the reader is either
            already disposed or is currently being disposed. Either way this
            reader instance shouldn't be used by an application unless
            <c>true</c> is returned.
            <para/>
            <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/>s are used to determine when a
            reader can be disposed safely, i.e. as soon as there are
            no more references.  Be sure to always call a
            corresponding <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, in a finally clause;
            otherwise the reader may never be disposed.  Note that
            <see cref="M:Lucene.Net.Index.IndexReader.Dispose(System.Boolean)"/> simply calls <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/>, which means that
            the <see cref="T:Lucene.Net.Index.IndexReader"/> will not really be disposed until
            <see cref="M:Lucene.Net.Index.IndexReader.DecRef"/> has been called for all outstanding
            references.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexReader.DecRef"/>
            <seealso cref="M:Lucene.Net.Index.IndexReader.IncRef"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DecRef">
            <summary>
            Expert: decreases the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> of this <see cref="T:Lucene.Net.Index.IndexReader"/>
            instance.  If the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/> drops to 0, then this
            reader is disposed.  If an exception is hit, the <see cref="P:Lucene.Net.Index.IndexReader.RefCount"/>
            is unchanged.
            </summary>
            <exception cref="T:System.IO.IOException"> in case an <see cref="T:System.IO.IOException"/> occurs in <see cref="M:Lucene.Net.Index.IndexReader.DoClose"/>
            </exception>
            <seealso cref="M:Lucene.Net.Index.IndexReader.IncRef"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.EnsureOpen">
            <summary>
            Throws <see cref="T:System.ObjectDisposedException"/> if this <see cref="T:Lucene.Net.Index.IndexReader"/> or any
            of its child readers is disposed, otherwise returns.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Equals(System.Object)">
            <summary>
            Determines whether two object instances are equal.
            <para/>For caching purposes, <see cref="T:Lucene.Net.Index.IndexReader"/> subclasses are not allowed
            to implement Equals/GetHashCode, so methods are declared sealed.
            To lookup instances from caches use <see cref="P:Lucene.Net.Index.IndexReader.CoreCacheKey"/> and
            <see cref="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetHashCode">
            <summary>
            Serves as the default hash function.
            <para/>For caching purposes, <see cref="T:Lucene.Net.Index.IndexReader"/> subclasses are not allowed
            to implement Equals/GetHashCode, so methods are declared sealed.
            To lookup instances from caches use <see cref="P:Lucene.Net.Index.IndexReader.CoreCacheKey"/> and
            <see cref="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> </summary>
            <param name="directory"> the index directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Expert: Returns a <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Store.Directory"/> with the given <paramref name="termInfosIndexDivisor"/>. </summary>
            <param name="directory"> the index directory </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as
             <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> 
             (which can be set on <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to <c>N</c>, then one in every
             <c>N*termIndexInterval</c> terms in the index is loaded into
             memory.  By setting this to a value <c>&gt; 1</c> you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)">
             <summary>
             Open a near real time <see cref="T:Lucene.Net.Index.IndexReader"/> from the <see cref="T:Lucene.Net.Index.IndexWriter"/>.
             </summary>
             <param name="writer"> The <see cref="T:Lucene.Net.Index.IndexWriter"/> to open from </param>
             <param name="applyAllDeletes"> If true, all buffered deletes will
             be applied (made visible) in the returned reader.  If
             false, the deletes are not applied but remain buffered
             (in <see cref="T:Lucene.Net.Index.IndexWriter"/>) so that they will be applied in the
             future.  Applying deletes can be costly, so if your app
             can tolerate deleted documents being returned you might
             gain some performance by passing false. </param>
             <returns> The new <see cref="T:Lucene.Net.Index.IndexReader"/> </returns>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error
             </exception>
             <seealso cref="M:Lucene.Net.Index.DirectoryReader.OpenIfChanged(Lucene.Net.Index.DirectoryReader,Lucene.Net.Index.IndexWriter,System.Boolean)"/>
            
             @lucene.experimental
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit)">
            <summary>
            Expert: returns an <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Index.IndexCommit"/>. 
            </summary>
            <param name="commit"> the commit point to open </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Open(Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            Expert: returns an <see cref="T:Lucene.Net.Index.IndexReader"/> reading the index in the given
            <see cref="T:Lucene.Net.Index.IndexCommit"/> and <paramref name="termInfosIndexDivisor"/>. </summary>
            <param name="commit"> the commit point to open </param>
            <param name="termInfosIndexDivisor"> Subsamples which indexed
             terms are loaded into RAM. this has the same effect as
             <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> 
             (which can be set in <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>) except that setting
             must be done at indexing time while this setting can be
             set per reader.  When set to <c>N</c>, then one in every
             <c>N*termIndexInterval</c> terms in the index is loaded into
             memory.  By setting this to a value <c>&gt; 1</c> you can reduce
             memory usage, at the expense of higher latency when
             loading a TermInfo.  The default value is 1.  Set this
             to -1 to skip loading the terms index entirely. </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermVectors(System.Int32)">
            <summary>
            Retrieve term vectors for this document, or <c>null</c> if
            term vectors were not indexed. The returned <see cref="T:Lucene.Net.Index.Fields"/>
            instance acts like a single-document inverted index
            (the docID will be 0).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetTermVector(System.Int32,System.String)">
            <summary>
            Retrieve term vector for this document and field, or
            <c>null</c> if term vectors were not indexed. The returned
            <see cref="T:Lucene.Net.Index.Fields"/> instance acts like a single-document inverted
            index (the docID will be 0).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.NumDocs">
            <summary>
            Returns the number of documents in this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.MaxDoc">
            <summary>
            Returns one greater than the largest possible document number.
            this may be used to, e.g., determine how big to allocate an array which
            will have an element for every document number in an index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.NumDeletedDocs">
            <summary>
            Returns the number of deleted documents. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,Lucene.Net.Index.StoredFieldVisitor)">
            <summary>
            Expert: visits the fields of a stored document, for
            custom processing/loading of each field. If you
            simply want to load all fields, use
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/>. If you want to load a subset, use
            <see cref="T:Lucene.Net.Documents.DocumentStoredFieldVisitor"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32)">
            <summary>
            Returns the stored fields of the <c>n</c><sup>th</sup>
            <see cref="T:Lucene.Net.Documents.Document"/> in this index.  This is just
            sugar for using <see cref="T:Lucene.Net.Documents.DocumentStoredFieldVisitor"/>.
            <para/>
            <b>NOTE:</b> for performance reasons, this method does not check if the
            requested document is deleted, and therefore asking for a deleted document
            may yield unspecified results. Usually this is not required, however you
            can test if the doc is deleted by checking the 
            <see cref="T:Lucene.Net.Util.IBits"/> returned from <see cref="M:Lucene.Net.Index.MultiFields.GetLiveDocs(Lucene.Net.Index.IndexReader)"/>.
            <para/>
            <b>NOTE:</b> only the content of a field is returned,
            if that field was stored during indexing.  Metadata
            like boost, omitNorm, IndexOptions, tokenized, etc.,
            are not preserved.
            </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Document(System.Int32,System.Collections.Generic.ISet{System.String})">
            <summary>
            Like <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> but only loads the specified
            fields.  Note that this is simply sugar for
            <see cref="M:Lucene.Net.Documents.DocumentStoredFieldVisitor.#ctor(System.Collections.Generic.ISet{System.String})"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.HasDeletions">
            <summary>
            Returns <c>true</c> if any documents have been deleted. Implementers should
            consider overriding this property if <see cref="P:Lucene.Net.Index.IndexReader.MaxDoc"/> or <see cref="P:Lucene.Net.Index.IndexReader.NumDocs"/>
            are not constant-time operations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Dispose">
            <summary> Closes files associated with this index.
            Also saves any new deletions to disk.
            No other methods should be called after this has been called.
            </summary>
            <exception cref="T:System.IO.IOException">If there is a low-level IO error</exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.Dispose(System.Boolean)">
            <summary>
            Closes files associated with this index.
            This method implements the disposable pattern. 
            It may be overridden to dispose any managed or unmanaged resources,
            but be sure to call <c>base.Dispose(disposing)</c> to close files associated with the
            underlying <see cref="T:Lucene.Net.Index.IndexReader"/>.
            </summary>
            <param name="disposing"><c>true</c> indicates to dispose all managed 
            and unmanaged resources, <c>false</c> indicates dispose unmanaged 
            resources only</param>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DoClose">
            <summary>
            Implements close. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.Context">
            <summary>
            Expert: Returns the root <see cref="T:Lucene.Net.Index.IndexReaderContext"/> for this
            <see cref="T:Lucene.Net.Index.IndexReader"/>'s sub-reader tree.
            <para/>
            Iff this reader is composed of sub
            readers, i.e. this reader being a composite reader, this method returns a
            <see cref="T:Lucene.Net.Index.CompositeReaderContext"/> holding the reader's direct children as well as a
            view of the reader tree's atomic leaf contexts. All sub-
            <see cref="T:Lucene.Net.Index.IndexReaderContext"/> instances referenced from this readers top-level
            context are private to this reader and are not shared with another context
            tree. For example, <see cref="T:Lucene.Net.Search.IndexSearcher"/> uses this API to drive searching by one
            atomic leaf reader at a time. If this reader is not composed of child
            readers, this method returns an <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>.
            <para/>
            Note: Any of the sub-<see cref="T:Lucene.Net.Index.CompositeReaderContext"/> instances referenced
            from this top-level context do not support <see cref="P:Lucene.Net.Index.CompositeReaderContext.Leaves"/>.
            Only the top-level context maintains the convenience leaf-view
            for performance reasons.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.Leaves">
            <summary>
            Returns the reader's leaves, or itself if this reader is atomic.
            This is a convenience method calling <c>this.Context.Leaves</c>.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexReaderContext.Leaves"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.CoreCacheKey">
            <summary>
            Expert: Returns a key for this <see cref="T:Lucene.Net.Index.IndexReader"/>, so 
            <see cref="T:Lucene.Net.Search.IFieldCache"/>/<see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> can find
            it again.
            This key must not have Equals()/GetHashCode() methods, 
            so &quot;equals&quot; means &quot;identical&quot;.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReader.CombinedCoreAndDeletesKey">
            <summary>
            Expert: Returns a key for this <see cref="T:Lucene.Net.Index.IndexReader"/> that also includes deletions,
            so <see cref="T:Lucene.Net.Search.IFieldCache"/>/<see cref="T:Lucene.Net.Search.CachingWrapperFilter"/> can find it again.
            This key must not have Equals()/GetHashCode() methods, 
            so &quot;equals&quot; means &quot;identical&quot;.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.DocFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the number of documents containing the
            <paramref name="term"/>.  This method returns 0 if the term or
            field does not exist.  This method does not take into
            account deleted documents that have not yet been merged
            away. </summary>
            <seealso cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.TotalTermFreq(Lucene.Net.Index.Term)">
            <summary>
            Returns the total number of occurrences of <paramref name="term"/> across all
            documents (the sum of the Freq for each doc that has this term). This
            will be -1 if the codec doesn't support this measure. Note that, like other
            term measures, this measure does not take deleted documents into account.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetSumDocFreq(System.String)">
            <summary>
            Returns the sum of <see cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/> for all terms in this field,
            or -1 if this measure isn't stored by the codec. Note that, just like other
            term measures, this measure does not take deleted documents into account.
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.SumDocFreq"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetDocCount(System.String)">
            <summary>
            Returns the number of documents that have at least one term for this field,
            or -1 if this measure isn't stored by the codec. Note that, just like other
            term measures, this measure does not take deleted documents into account.
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.DocCount"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexReader.GetSumTotalTermFreq(System.String)">
            <summary>
            Returns the sum of <see cref="P:Lucene.Net.Index.TermsEnum.TotalTermFreq"/> for all terms in this
            field, or -1 if this measure isn't stored by the codec (or if this fields
            omits term freq and positions). Note that, just like other term measures,
            this measure does not take deleted documents into account.
            </summary>
            <seealso cref="P:Lucene.Net.Index.Terms.SumTotalTermFreq"/>
        </member>
        <member name="T:Lucene.Net.Index.IndexReaderContext">
            <summary>
            A struct like class that represents a hierarchical relationship between
            <see cref="T:Lucene.Net.Index.IndexReader"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Parent">
            <summary>
            The reader context for this reader's immediate parent, or null if none </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.IsTopLevel">
            <summary>
            <c>true</c> if this context struct represents the top level reader within the hierarchical context </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.DocBaseInParent">
            <summary>
            the doc base for this reader in the parent, <c>0</c> if parent is <c>null</c> </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.OrdInParent">
            <summary>
            the ord for this reader in the parent, <c>0</c> if parent is <c>null</c> </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Reader">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.IndexReader"/>, this context represents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Leaves">
            <summary>
            Returns the context's leaves if this context is a top-level context.
            For convenience, if this is an <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> this
            returns itself as the only leaf.
            <para/>Note: this is convenience method since leaves can always be obtained by
            walking the context tree using <see cref="P:Lucene.Net.Index.IndexReaderContext.Children"/>. </summary>
            <exception cref="T:System.InvalidOperationException"> if this is not a top-level context. </exception>
            <seealso cref="P:Lucene.Net.Index.IndexReaderContext.Children"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexReaderContext.Children">
            <summary>
            Returns the context's children iff this context is a composite context
            otherwise <c>null</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexUpgrader">
            <summary>
            This is an easy-to-use tool that upgrades all segments of an index from previous Lucene versions
            to the current segment file format. It can be used from command line:
            <code>
             java -cp lucene-core.jar Lucene.Net.Index.IndexUpgrader [-delete-prior-commits] [-verbose] indexDir
            </code>
            Alternatively this class can be instantiated and <see cref="M:Lucene.Net.Index.IndexUpgrader.Upgrade"/> invoked. It uses <see cref="T:Lucene.Net.Index.UpgradeIndexMergePolicy"/>
            and triggers the upgrade via an <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> request to <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            <para/>
            This tool keeps only the last commit in an index; for this
            reason, if the incoming index has more than one commit, the tool
            refuses to run by default. Specify <c>-delete-prior-commits</c>
            to override this, allowing the tool to delete all but the last commit.
            From .NET code this can be enabled by passing <c>true</c> to
            <see cref="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion,System.IO.TextWriter,System.Boolean)"/>.
            <para/>
            <b>Warning:</b> this tool may reorder documents if the index was partially
            upgraded before execution (e.g., documents were added). If your application relies
            on &quot;monotonicity&quot; of doc IDs (which means that the order in which the documents
            were added to the index is preserved), do a full ForceMerge instead.
            The <see cref="T:Lucene.Net.Index.MergePolicy"/> set by <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> may also reorder
            documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.Main(System.String[])">
            <summary>
            Main method to run <see cref="T:Lucene.Net.Index.IndexUpgrader"/> from the
            command-line.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion)">
            <summary>
            Creates index upgrader on the given directory, using an <see cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            <paramref name="matchVersion"/>. The tool refuses to upgrade indexes with multiple commit points.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Util.LuceneVersion,System.IO.TextWriter,System.Boolean)">
            <summary>
            Creates index upgrader on the given directory, using an <see cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            <paramref name="matchVersion"/>. You have the possibility to upgrade indexes with multiple commit points by removing
            all older ones. If <paramref name="infoStream"/> is not <c>null</c>, all logging output will be sent to this stream.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Creates index upgrader on the given directory, using an <see cref="T:Lucene.Net.Index.IndexWriter"/> using the given
            config. You have the possibility to upgrade indexes with multiple commit points by removing
            all older ones.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexUpgrader.Upgrade">
            <summary>
            Perform the upgrade. </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter">
             <summary>
             An <see cref="T:Lucene.Net.Index.IndexWriter"/> creates and maintains an index.
            
             <para>The <see cref="T:Lucene.Net.Index.OpenMode"/> option on
             <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/> determines
             whether a new index is created, or whether an existing index is
             opened. Note that you can open an index with <see cref="F:Lucene.Net.Index.OpenMode.CREATE"/>
             even while readers are using the index. The old readers will
             continue to search the "point in time" snapshot they had opened,
             and won't see the newly created index until they re-open. If
             <see cref="F:Lucene.Net.Index.OpenMode.CREATE_OR_APPEND"/> is used <see cref="T:Lucene.Net.Index.IndexWriter"/> will create a
             new index if there is not already an index at the provided path
             and otherwise open the existing index.</para>
            
             <para>In either case, documents are added with <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>
             and removed with <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)"/> or
             <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)"/>. A document can be updated with
             <see cref="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/> (which just deletes
             and then adds the entire document). When finished adding, deleting
             and updating documents, <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> should be called.</para>
            
             <a name="flush"></a>
             <para>These changes are buffered in memory and periodically
             flushed to the <see cref="T:Lucene.Net.Store.Directory"/> (during the above method
             calls). A flush is triggered when there are enough added documents
             since the last flush. Flushing is triggered either by RAM usage of the
             documents (see <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>) or the
             number of added documents (see <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>).
             The default is to flush when RAM usage hits
             <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB"/> MB. For
             best indexing speed you should flush by RAM usage with a
             large RAM buffer. Additionally, if <see cref="T:Lucene.Net.Index.IndexWriter"/> reaches the configured number of
             buffered deletes (see <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>)
             the deleted terms and queries are flushed and applied to existing segments.
             In contrast to the other flush options <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> and
             <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>, deleted terms
             won't trigger a segment flush. Note that flushing just moves the
             internal buffered state in <see cref="T:Lucene.Net.Index.IndexWriter"/> into the index, but
             these changes are not visible to <see cref="T:Lucene.Net.Index.IndexReader"/> until either
             <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> or <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> is called.  A flush may
             also trigger one or more segment merges which by default
             run with a background thread so as not to block the
             addDocument calls (see <a href="#mergePolicy">below</a>
             for changing the <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/>).</para>
            
             <para>Opening an <see cref="T:Lucene.Net.Index.IndexWriter"/> creates a lock file for the directory in use. Trying to open
             another <see cref="T:Lucene.Net.Index.IndexWriter"/> on the same directory will lead to a
             <see cref="T:Lucene.Net.Store.LockObtainFailedException"/>. The <see cref="T:Lucene.Net.Store.LockObtainFailedException"/>
             is also thrown if an <see cref="T:Lucene.Net.Index.IndexReader"/> on the same directory is used to delete documents
             from the index.</para>
            
             <a name="deletionPolicy"></a>
             <para>Expert: <see cref="T:Lucene.Net.Index.IndexWriter"/> allows an optional
             <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation to be
             specified.  You can use this to control when prior commits
             are deleted from the index.  The default policy is
             <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/> which removes all prior
             commits as soon as a new commit is done (this matches
             behavior before 2.2).  Creating your own policy can allow
             you to explicitly keep previous "point in time" commits
             alive in the index for some time, to allow readers to
             refresh to the new commit without having the old commit
             deleted out from under them.  This is necessary on
             filesystems like NFS that do not support "delete on last
             close" semantics, which Lucene's "point in time" search
             normally relies on. </para>
            
             <a name="mergePolicy"></a> <para>Expert:
             <see cref="T:Lucene.Net.Index.IndexWriter"/> allows you to separately change
             the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> and the <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/>.
             The <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> is invoked whenever there are
             changes to the segments in the index.  Its role is to
             select which merges to do, if any, and return a 
             <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> describing the merges.
             The default is <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>.  Then, the 
             <see cref="T:Lucene.Net.Index.MergeScheduler"/> is invoked with the requested merges and
             it decides when and how to run the merges.  The default is
             <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>. </para>
            
             <a name="OOME"></a><para><b>NOTE</b>: if you hit an
             <see cref="T:System.OutOfMemoryException"/> then <see cref="T:Lucene.Net.Index.IndexWriter"/> will quietly record this
             fact and block all future segment commits.  This is a
             defensive measure in case any internal state (buffered
             documents and deletions) were corrupted.  Any subsequent
             calls to <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> will throw an
             <see cref="T:System.InvalidOperationException"/>.  The only course of action is to
             call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/>, which internally will call
             <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>, to undo any changes to the index since the
             last commit.  You can also just call <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>
             directly.</para>
            
             <a name="thread-safety"></a><para><b>NOTE</b>: 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> instances are completely thread
             safe, meaning multiple threads can call any of its
             methods, concurrently.  If your application requires
             external synchronization, you should <b>not</b>
             synchronize on the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance as
             this may cause deadlock; use your own (non-Lucene) objects
             instead. </para>
            
             <para><b>NOTE</b>: If you call
             <see cref="M:System.Threading.Thread.Interrupt"/> on a thread that's within
             <see cref="T:Lucene.Net.Index.IndexWriter"/>, <see cref="T:Lucene.Net.Index.IndexWriter"/> will try to catch this (eg, if
             it's in a Wait() or <see cref="!:Thread.Sleep()"/>), and will then throw
             the unchecked exception <see cref="T:System.Threading.ThreadInterruptedException"/>
             and <b>clear</b> the interrupt status on the thread.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.WRITE_LOCK_NAME">
            <summary>
            Name of the write lock in the index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE">
            <summary>
            Key for the source of a segment in the <see cref="P:Lucene.Net.Index.SegmentInfo.Diagnostics"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_MERGE">
            <summary>
            Source of a segment which results from a merge of other segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_FLUSH">
            <summary>
            Source of a segment which results from a flush. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.SOURCE_ADDINDEXES_READERS">
            <summary>
            Source of a segment which results from a call to <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH">
            <summary>
            Absolute hard maximum length for a term, in bytes once
            encoded as UTF8.  If a term arrives from the analyzer
            longer than this length, an
            <see cref="T:System.ArgumentException"/> is thrown
            and a message is printed to <see cref="F:Lucene.Net.Index.IndexWriter.infoStream"/>, if set (see
            <see cref="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(Lucene.Net.Util.InfoStream)"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.GetReader(System.Boolean)">
             <summary>
             Expert: returns a readonly reader, covering all
             committed as well as un-committed changes to the index.
             this provides "near real-time" searching, in that
             changes made during an <see cref="T:Lucene.Net.Index.IndexWriter"/> session can be
             quickly made available for searching without closing
             the writer nor calling <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            
             <para>Note that this is functionally equivalent to calling
             Flush() and then opening a new reader.  But the turnaround time of this
             method should be faster since it avoids the potentially
             costly <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.</para>
            
             <para>You must close the <see cref="T:Lucene.Net.Index.IndexReader"/> returned by
             this method once you are done using it.</para>
            
             <para>It's <i>near</i> real-time because there is no hard
             guarantee on how quickly you can get a new reader after
             making changes with <see cref="T:Lucene.Net.Index.IndexWriter"/>.  You'll have to
             experiment in your situation to determine if it's
             fast enough.  As this is a new and experimental
             feature, please report back on your findings so we can
             learn, improve and iterate.</para>
            
             <para>The resulting reader supports
             <see cref="M:Lucene.Net.Index.DirectoryReader.DoOpenIfChanged"/>, but that call will simply forward
             back to this method (though this may change in the
             future).</para>
            
             <para>The very first time this method is called, this
             writer instance will make every effort to pool the
             readers that it opens for doing merges, applying
             deletes, etc.  This means additional resources (RAM,
             file descriptors, CPU time) will be consumed.</para>
            
             <para>For lower latency on reopening a reader, you should
             set <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/> to
             pre-warm a newly merged segment before it's committed
             to the index.  This is important for minimizing
             index-to-search delay after a large merge.  </para>
            
             <para>If an AddIndexes* call is running in another thread,
             then this reader will only search those segments from
             the foreign index that have been successfully copied
             over, so far.</para>
            
             <para><b>NOTE</b>: Once the writer is disposed, any
             outstanding readers may continue to be used.  However,
             if you attempt to reopen any of those readers, you'll
             hit an <see cref="T:System.ObjectDisposedException"/>.</para>
            
             @lucene.experimental
             </summary>
             <returns> <see cref="T:Lucene.Net.Index.IndexReader"/> that covers entire index plus all
             changes made so far by this <see cref="T:Lucene.Net.Index.IndexWriter"/> instance
             </returns>
             <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.ReaderPool">
            <summary>
            Holds shared <see cref="T:Lucene.Net.Index.SegmentReader"/> instances. <see cref="T:Lucene.Net.Index.IndexWriter"/> uses
            <see cref="T:Lucene.Net.Index.SegmentReader"/>s for 1) applying deletes, 2) doing
            merges, 3) handing out a real-time reader.  This pool
            reuses instances of the <see cref="T:Lucene.Net.Index.SegmentReader"/>s in all these
            places if it is in "near real-time mode" (<see cref="M:Lucene.Net.Index.IndexWriter.GetReader"/>
            has been called on this instance).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.DropAll(System.Boolean)">
            <summary>
            Remove all our references to readers, and commits
            any pending changes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.Commit(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Commit live docs changes for the segment readers for
            the provided infos.
            </summary>
            <exception cref="T:System.IO.IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.Get(Lucene.Net.Index.SegmentCommitInfo,System.Boolean)">
            <summary>
            Obtain a <see cref="T:Lucene.Net.Index.ReadersAndUpdates"/> instance from the
            readerPool.  If <paramref name="create"/> is <c>true</c>, you must later call
            <see cref="M:Lucene.Net.Index.IndexWriter.ReaderPool.Release(Lucene.Net.Index.ReadersAndUpdates)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ReaderPool.NoDups">
            <summary>
            Make sure that every segment appears only once in the
            pool:
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumDeletedDocs(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Obtain the number of deleted docs for a pooled reader.
            If the reader isn't being pooled, the segmentInfo's
            delCount is returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.EnsureOpen(System.Boolean)">
            <summary>
            Used internally to throw an <see cref="T:System.ObjectDisposedException"/> if this
            <see cref="T:Lucene.Net.Index.IndexWriter"/> has been disposed or is in the process of diposing.
            </summary>
            <param name="failIfDisposing">
                     if <c>true</c>, also fail when <see cref="T:Lucene.Net.Index.IndexWriter"/> is in the process of
                     disposing (<c>closing=true</c>) but not yet done disposing (
                     <c>closed=false</c>) </param>
            <exception cref="T:System.ObjectDisposedException">
                      if this IndexWriter is closed or in the process of closing </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.EnsureOpen">
            <summary>
            Used internally to throw an
            <see cref="T:System.ObjectDisposedException"/> if this <see cref="T:Lucene.Net.Index.IndexWriter"/> has been
            disposed (<c>closed=true</c>) or is in the process of
            disposing (<c>closing=true</c>).
            <para/>
            Calls <see cref="M:Lucene.Net.Index.IndexWriter.EnsureOpen(System.Boolean)"/>.
            </summary>
            <exception cref="T:System.ObjectDisposedException"> if this <see cref="T:Lucene.Net.Index.IndexWriter"/> is disposed </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexWriterConfig)">
             <summary>
             Constructs a new <see cref="T:Lucene.Net.Index.IndexWriter"/> per the settings given in <paramref name="conf"/>.
             If you want to make "live" changes to this writer instance, use
             <see cref="P:Lucene.Net.Index.IndexWriter.Config"/>.
            
             <para/>
             <b>NOTE:</b> after ths writer is created, the given configuration instance
             cannot be passed to another writer. If you intend to do so, you should
             <see cref="M:Lucene.Net.Index.IndexWriterConfig.Clone"/> it beforehand.
             </summary>
             <param name="d">
                      the index directory. The index is either created or appended
                      according <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/>. </param>
             <param name="conf">
                      the configuration settings according to which <see cref="T:Lucene.Net.Index.IndexWriter"/> should
                      be initialized. </param>
             <exception cref="T:System.IO.IOException">
                       if the directory cannot be read/written to, or if it does not
                       exist and <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/> is
                       <see cref="F:Lucene.Net.Index.OpenMode.APPEND"/> or if there is any other low-level
                       IO error </exception>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.FieldNumberMap">
            <summary>
            Loads or returns the already loaded the global field number map for <see cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/>.
            If <see cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/> has no global field number map the returned instance is empty
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Config">
            <summary>
            Returns a <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/>, which can be used to query the <see cref="T:Lucene.Net.Index.IndexWriter"/>
            current settings, as well as modify "live" ones.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Dispose">
             <summary>
             Commits all changes to an index, waits for pending merges
             to complete, and closes all associated files.
             <para/>
             This is a "slow graceful shutdown" which may take a long time
             especially if a big merge is pending: If you only want to close
             resources use <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>. If you only want to commit
             pending changes and close resources see <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/>.
             <para/>
             Note that this may be a costly
             operation, so, try to re-use a single writer instead of
             closing and opening a new one.  See <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> for
             caveats about write caching done by some IO devices.
            
             <para> If an <see cref="T:System.Exception"/> is hit during close, eg due to disk
             full or some other reason, then both the on-disk index
             and the internal state of the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance will
             be consistent.  However, the close will not be complete
             even though part of it (flushing buffered documents)
             may have succeeded, so the write lock will still be
             held.</para>
            
             <para> If you can correct the underlying cause (eg free up
             some disk space) then you can call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose"/> again.
             Failing that, if you want to force the write lock to be
             released (dangerous, because you may then lose buffered
             docs in the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance) then you can do
             something like this:</para>
            
             <code>
             try 
             {
                 writer.Dispose();
             } 
             finally 
             {
                 if (IndexWriter.IsLocked(directory)) 
                 {
                     IndexWriter.Unlock(directory);
                 }
             }
             </code>
             
             after which, you must be certain not to use the writer
             instance anymore.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer, again.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)">
             <summary>
             Closes the index with or without waiting for currently
             running merges to finish.  This is only meaningful when
             using a <see cref="T:Lucene.Net.Index.MergeScheduler"/> that runs merges in background
             threads.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer, again.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
            
             <para><b>NOTE</b>: it is dangerous to always call
             <c>Dispose(false)</c>, especially when <see cref="T:Lucene.Net.Index.IndexWriter"/> is not open
             for very long, because this can result in "merge
             starvation" whereby long merges will never have a
             chance to finish.  This will cause too many segments in
             your index over time.</para>
             </summary>
             <param name="waitForMerges"> if <c>true</c>, this call will block
             until all merges complete; else, it will ask all
             running merges to abort, wait until those merges have
             finished (which should be at most a few seconds), and
             then return. </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ShouldClose">
            <summary>
            Returns <c>true</c> if this thread should attempt to close, or
            false if IndexWriter is now closed; else, waits until
            another thread finishes closing
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Directory">
            <summary>
            Gets the <see cref="T:Lucene.Net.Store.Directory"/> used by this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.Analyzer">
            <summary>
            Gets the analyzer used by this index. </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.MaxDoc">
            <summary>
            Gets total number of docs in this index, including
            docs not yet flushed (still in the RAM buffer),
            not counting deletions.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriter.NumDocs"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.NumDocs">
            <summary>
            Gets total number of docs in this index, including
            docs not yet flushed (still in the RAM buffer), and
            including deletions.  <b>NOTE:</b> buffered deletions
            are not counted.  If you really need these to be
            counted you should call <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> first.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriter.MaxDoc"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasDeletions">
            <summary>
            Returns <c>true</c> if this index has deletions (including
            buffered deletions).  Note that this will return <c>true</c>
            if there are buffered Term/Query deletions, even if it
            turns out those buffered deletions don't match any
            documents. Also, if a merge kicked off as a result of flushing a
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
             <summary>
             Adds a document to this index.
            
             <para> Note that if an <see cref="T:System.Exception"/> is hit (for example disk full)
             then the index will be consistent, but this document
             may not have been added.  Furthermore, it's possible
             the index will have one segment in non-compound format
             even when using compound files (when a merge has
             partially succeeded).</para>
            
             <para>This method periodically flushes pending documents
             to the <see cref="P:Lucene.Net.Index.IndexWriter.Directory"/> (see <see cref="T:Lucene.Net.Index.IndexWriter"/>), and
             also periodically triggers segment merges in the index
             according to the <see cref="T:Lucene.Net.Index.MergePolicy"/> in use.</para>
            
             <para>Merges temporarily consume space in the
             directory. The amount of space required is up to 1X the
             size of all segments being merged, when no
             readers/searchers are open against the index, and up to
             2X the size of all segments being merged when
             readers/searchers are open against the index (see
             <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> for details). The sequence of
             primitive merge operations performed is governed by the
             merge policy.</para>
            
             <para>Note that each term in the document can be no longer
             than <see cref="F:Lucene.Net.Index.IndexWriter.MAX_TERM_LENGTH"/> in bytes, otherwise an
             <see cref="T:System.ArgumentException"/> will be thrown.</para>
            
             <para>Note that it's possible to create an invalid Unicode
             string in java if a UTF16 surrogate pair is malformed.
             In this case, the invalid characters are silently
             replaced with the Unicode replacement character
             U+FFFD.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Adds a document to this index, using the provided <paramref name="analyzer"/> instead of the
             value of <see cref="P:Lucene.Net.Index.IndexWriter.Analyzer"/>.
            
             <para>See <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/> for details on
             index and <see cref="T:Lucene.Net.Index.IndexWriter"/> state after an <see cref="T:System.Exception"/>, and
             flushing/merging temporary free space requirements.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
             <summary>
             Atomically adds a block of documents with sequentially
             assigned document IDs, such that an external reader
             will see all or none of the documents.
            
             <para><b>WARNING</b>: the index does not currently record
             which documents were added as a block.  Today this is
             fine, because merging will preserve a block. The order of
             documents within a segment will be preserved, even when child
             documents within a block are deleted. Most search features
             (like result grouping and block joining) require you to
             mark documents; when these documents are deleted these
             search features will not work as expected. Obviously adding
             documents to an existing block will require you the reindex
             the entire block.</para>
            
             <para>However it's possible that in the future Lucene may
             merge more aggressively re-order documents (for example,
             perhaps to obtain better index compression), in which case
             you may need to fully re-index your documents at that time.</para>
            
             <para>See <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/> for details on
             index and <see cref="T:Lucene.Net.Index.IndexWriter"/> state after an <see cref="T:System.Exception"/>, and
             flushing/merging temporary free space requirements.</para>
            
             <para><b>NOTE</b>: tools that do offline splitting of an index
             (for example, IndexSplitter in Lucene.Net.Misc) or
             re-sorting of documents (for example, IndexSorter in
             contrib) are not aware of these atomically added documents
             and will likely break them up.  Use such tools at your
             own risk!</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             
             @lucene.experimental 
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Atomically adds a block of documents, analyzed using the
            provided <paramref name="analyzer"/>, with sequentially assigned document
            IDs, such that an external reader will see all or none
            of the documents.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
            <summary>
            Atomically deletes documents matching the provided
            <paramref name="delTerm"/> and adds a block of documents with sequentially
            assigned document IDs, such that an external reader
            will see all or none of the documents.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Atomically deletes documents matching the provided
            <paramref name="delTerm"/> and adds a block of documents, analyzed using
            the provided <paramref name="analyzer"/>, with sequentially
            assigned document IDs, such that an external reader
            will see all or none of the documents.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
            <seealso cref="M:Lucene.Net.Index.IndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
             <summary>
             Deletes the document(s) containing <paramref name="term"/>.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See 
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="term"> the term to identify the documents to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.TryDeleteDocument(Lucene.Net.Index.IndexReader,System.Int32)">
             <summary>
             Expert: attempts to delete by document ID, as long as
             the provided <paramref name="readerIn"/> is a near-real-time reader (from 
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>.  If the
             provided <paramref name="readerIn"/> is an NRT reader obtained from this
             writer, and its segment has not been merged away, then
             the delete succeeds and this method returns <c>true</c>; else, it
             returns <c>false</c> the caller must then separately delete by
             Term or Query.
            
             <b>NOTE</b>: this method can only delete documents
             visible to the currently open NRT reader.  If you need
             to delete documents indexed after opening the NRT
             reader you must use the other DeleteDocument() methods
             (e.g., <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term)"/>).
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
             <summary>
             Deletes the document(s) containing any of the
             terms. All given deletes are applied and flushed atomically
             at the same time.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="terms"> array of terms to identify the documents
             to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)">
             <summary>
             Deletes the document(s) matching the provided query.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="query"> the query to identify the documents to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])">
             <summary>
             Deletes the document(s) matching any of the provided queries.
             All given deletes are applied and flushed atomically at the same time.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="queries"> array of queries to identify the documents
             to be deleted </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
             <summary>
             Updates a document by first deleting the document(s)
             containing <paramref name="term"/> and then adding the new
             document.  The delete and then add are atomic as seen
             by a reader on the same index (flush may happen only after
             the add).
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="term"> the term to identify the document(s) to be
             deleted </param>
             <param name="doc"> the document to be added </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
             <summary>
             Updates a document by first deleting the document(s)
             containing <paramref name="term"/> and then adding the new
             document.  The delete and then add are atomic as seen
             by a reader on the same index (flush may happen only after
             the add).
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
             <param name="term"> the term to identify the document(s) to be
             deleted </param>
             <param name="doc"> the document to be added </param>
             <param name="analyzer"> the analyzer to use when analyzing the document </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateNumericDocValue(Lucene.Net.Index.Term,System.String,System.Nullable{System.Int64})">
             <summary>
             Updates a document's <see cref="T:Lucene.Net.Index.NumericDocValues"/> for <paramref name="field"/> to the
             given <paramref name="value"/>. This method can be used to 'unset' a document's
             value by passing <c>null</c> as the new <paramref name="value"/>. Also, you can only update
             fields that already exist in the index, not add new fields through this
             method.
            
             <para>
             <b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/> you should immediately
             dispose the writer. See <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
             </para>
             </summary>
             <param name="term">
                      the term to identify the document(s) to be updated </param>
             <param name="field">
                      field name of the <see cref="T:Lucene.Net.Index.NumericDocValues"/> field </param>
             <param name="value">
                      new value for the field </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException">
                       if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException">
                       if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.UpdateBinaryDocValue(Lucene.Net.Index.Term,System.String,Lucene.Net.Util.BytesRef)">
             <summary>
             Updates a document's <see cref="T:Lucene.Net.Index.BinaryDocValues"/> for <paramref name="field"/> to the
             given <paramref name="value"/>. this method can be used to 'unset' a document's
             value by passing <c>null</c> as the new <paramref name="value"/>. Also, you can only update
             fields that already exist in the index, not add new fields through this
             method.
            
             <para/>
             <b>NOTE:</b> this method currently replaces the existing value of all
             affected documents with the new value.
            
             <para>
             <b>NOTE:</b> if this method hits an <see cref="T:System.OutOfMemoryException"/> you should immediately
             dispose the writer. See <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
             </para>
             </summary>
             <param name="term">
                      the term to identify the document(s) to be updated </param>
             <param name="field">
                      field name of the <see cref="T:Lucene.Net.Index.BinaryDocValues"/> field </param>
             <param name="value">
                      new value for the field </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException">
                       if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException">
                       if there is a low-level IO error </exception>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.infoStream">
            <summary>
            If non-null, information about merges will be printed to this.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)">
             <summary>
             Forces merge policy to merge segments until there are &lt;=
             <paramref name="maxNumSegments"/>.  The actual merges to be
             executed are determined by the <see cref="T:Lucene.Net.Index.MergePolicy"/>.
            
             <para>This is a horribly costly operation, especially when
             you pass a small <paramref name="maxNumSegments"/>; usually you
             should only call this if the index is static (will no
             longer be changed).</para>
            
             <para>Note that this requires up to 2X the index size free
             space in your Directory (3X if you're using compound
             file format).  For example, if your index size is 10 MB
             then you need up to 20 MB free for this to complete (30
             MB if you're using compound file format).  Also,
             it's best to call <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> afterwards,
             to allow <see cref="T:Lucene.Net.Index.IndexWriter"/> to free up disk space.</para>
            
             <para>If some but not all readers re-open while merging
             is underway, this will cause &gt; 2X temporary
             space to be consumed as those new readers will then
             hold open the temporary segments at that time.  It is
             best not to re-open readers while merging is running.</para>
            
             <para>The actual temporary usage could be much less than
             these figures (it depends on many factors).</para>
            
             <para>In general, once this completes, the total size of the
             index will be less than the size of the starting index.
             It could be quite a bit smaller (if there were many
             pending deletes) or just slightly smaller.</para>
            
             <para>If an <see cref="T:System.Exception"/> is hit, for example
             due to disk full, the index will not be corrupted and no
             documents will be lost.  However, it may have
             been partially merged (some segments were merged but
             not all), and it's possible that one of the segments in
             the index will be in non-compound format even when
             using compound file format.  This will occur when the
             <see cref="T:System.Exception"/> is hit during conversion of the segment into
             compound format.</para>
            
             <para>This call will merge those segments present in
             the index when the call started.  If other threads are
             still adding documents and flushing segments, those
             newly created segments will not be merged unless you
             call <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> again.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
            
             <para><b>NOTE</b>: if you call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/>
             with <c>false</c>, which aborts all running merges,
             then any thread still running this method might hit a
             <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>.</para>
             </summary>
             <param name="maxNumSegments"> maximum number of segments left
             in the index after merging finishes
             </param>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
             <seealso cref="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32,System.Boolean)">
             <summary>
             Just like <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>, except you can
             specify whether the call should block until
             all merging completes.  This is only meaningful with a
             <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/> that is able to run merges in
             background threads.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaxNumSegmentsMergesPending">
            <summary>
            Returns <c>true</c> if any merges in <see cref="F:Lucene.Net.Index.IndexWriter.pendingMerges"/> or
            <see cref="F:Lucene.Net.Index.IndexWriter.runningMerges"/> are <see cref="F:Lucene.Net.Index.IndexWriter.mergeMaxNumSegments"/> merges.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes(System.Boolean)">
             <summary>
             Just like <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/>, except you can
             specify whether the call should block until the
             operation completes.  This is only meaningful with a
             <see cref="T:Lucene.Net.Index.MergeScheduler"/> that is able to run merges in
             background threads.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
            
             <para><b>NOTE</b>: if you call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/>
             with <c>false</c>, which aborts all running merges,
             then any thread still running this method might hit a
             <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes">
             <summary>
             Forces merging of all segments that have deleted
             documents.  The actual merges to be executed are
             determined by the <see cref="T:Lucene.Net.Index.MergePolicy"/>.  For example,
             the default <see cref="T:Lucene.Net.Index.TieredMergePolicy"/> will only
             pick a segment if the percentage of
             deleted docs is over 10%.
            
             <para>This is often a horribly costly operation; rarely
             is it warranted.</para>
            
             <para>To see how
             many deletions you have pending in your index, call
             <see cref="P:Lucene.Net.Index.IndexReader.NumDeletedDocs"/>.</para>
            
             <para><b>NOTE</b>: this method first flushes a new
             segment (if there are indexed documents), and applies
             all buffered deletes.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MaybeMerge">
             <summary>
             Expert: asks the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> whether any merges are
             necessary now and if so, runs the requested merges and
             then iterate (test again if merges are needed) until no
             more merges are returned by the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/>.
             <para/>
             Explicit calls to <see cref="M:Lucene.Net.Index.IndexWriter.MaybeMerge"/> are usually not
             necessary. The most common case is when merge policy
             parameters have changed.
             <para/>
             this method will call the <see cref="F:Lucene.Net.Index.IndexWriter.mergePolicy"/> with
             <see cref="F:Lucene.Net.Index.MergeTrigger.EXPLICIT"/>.
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.MergingSegments">
            <summary>
            Expert: to be used by a <see cref="T:Lucene.Net.Index.MergePolicy"/> to avoid
            selecting merges for segments already being merged.
            The returned collection is not cloned, and thus is
            only safe to access if you hold <see cref="T:Lucene.Net.Index.IndexWriter"/>'s lock
            (which you do when <see cref="T:Lucene.Net.Index.IndexWriter"/> invokes the
            <see cref="T:Lucene.Net.Index.MergePolicy"/>).
            <para/>
            Do not alter the returned collection!
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NextMerge">
            <summary>
            Expert: the <see cref="F:Lucene.Net.Index.IndexWriter.mergeScheduler"/> calls this method to retrieve the next
            merge requested by the <see cref="T:Lucene.Net.Index.MergePolicy"/>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasPendingMerges">
            <summary>
            Expert: returns true if there are merges waiting to be scheduled.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Rollback">
            <summary>
            Close the <see cref="T:Lucene.Net.Index.IndexWriter"/> without committing
            any changes that have occurred since the last commit
            (or since it was opened, if commit hasn't been called).
            this removes any temporary files that had been created,
            after which the state of the index will be the same as
            it was when <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> was last called or when this
            writer was first opened.  This also clears a previous
            call to <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/>.
            </summary>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteAll">
             <summary>
             Delete all documents in the index.
            
             <para>This method will drop all buffered documents and will
                remove all segments from the index. This change will not be
                visible until a <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> has been called. This method
                can be rolled back using <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/>.</para>
            
             <para>NOTE: this method is much faster than using <c>DeleteDocuments(new MatchAllDocsQuery())</c>.
                Yet, this method also has different semantics compared to <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query)"/>
                / <see cref="M:Lucene.Net.Index.IndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])"/> since internal data-structures are cleared as well
                as all segment information is forcefully dropped anti-viral semantics like omitting norms
                are reset or doc value types are cleared. Essentially a call to <see cref="M:Lucene.Net.Index.IndexWriter.DeleteAll"/> is equivalent
                to creating a new <see cref="T:Lucene.Net.Index.IndexWriter"/> with <see cref="F:Lucene.Net.Index.OpenMode.CREATE"/> which a delete query only marks
                documents as deleted.</para>
            
             <para>NOTE: this method will forcefully abort all merges
                in progress.  If other threads are running 
                <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>, <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])"/> or
                <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/> methods, they may receive
                <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>s.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.WaitForMerges">
             <summary>
             Wait for any currently outstanding merges to finish.
            
             <para>It is guaranteed that any merges started prior to calling this method
                will have completed once this method completes.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Checkpoint">
            <summary>
            Called whenever the <see cref="T:Lucene.Net.Index.SegmentInfos"/> has been updated and
            the index files referenced exist (correctly) in the
            index directory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CheckpointNoSIS">
            <summary>
            Checkpoints with <see cref="T:Lucene.Net.Index.IndexFileDeleter"/>, so it's aware of
            new files, and increments <see cref="F:Lucene.Net.Index.IndexWriter.changeCount"/>, so on
            close/commit we will write a new segments file, but
            does NOT bump segmentInfos.version.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Changed">
            <summary>
            Called internally if any index state has changed. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.PublishFlushedSegment(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.FrozenBufferedUpdates,Lucene.Net.Index.FrozenBufferedUpdates)">
            <summary>
            Atomically adds the segment private delete packet and publishes the flushed
            segments <see cref="T:Lucene.Net.Index.SegmentInfo"/> to the index writer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AcquireWriteLocks(Lucene.Net.Store.Directory[])">
            <summary>
            Acquires write locks on all the directories; be sure
            to match with a call to <see cref="M:Lucene.Net.Util.IOUtils.Close(System.Collections.Generic.IEnumerable{System.IDisposable})"/> in a
            finally clause.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Store.Directory[])">
             <summary>
             Adds all segments from an array of indexes into this index.
            
             <para/>This may be used to parallelize batch indexing. A large document
             collection can be broken into sub-collections. Each sub-collection can be
             indexed in parallel, on a different thread, process or machine. The
             complete index can then be created by merging sub-collection indexes
             with this method.
            
             <para/>
             <b>NOTE:</b> this method acquires the write lock in
             each directory, to ensure that no <see cref="T:Lucene.Net.Index.IndexWriter"/>
             is currently open or tries to open while this is
             running.
            
             <para/>This method is transactional in how <see cref="T:System.Exception"/>s are
             handled: it does not commit a new segments_N file until
             all indexes are added.  this means if an <see cref="T:System.Exception"/>
             occurs (for example disk full), then either no indexes
             will have been added or they all will have been.
            
             <para/>Note that this requires temporary free space in the
             <see cref="T:Lucene.Net.Store.Directory"/> up to 2X the sum of all input indexes
             (including the starting index). If readers/searchers
             are open against the starting index, then temporary
             free space required will be higher by the size of the
             starting index (see <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> for details).
            
             <para/>
             <b>NOTE:</b> this method only copies the segments of the incoming indexes
             and does not merge them. Therefore deleted documents are not removed and
             the new segments are not merged with the existing ones.
            
             <para/>This requires this index not be among those to be added.
            
             <para/>
             <b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer. See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
             <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if we were unable to
               acquire the write lock in at least one directory </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
             <summary>
             Merges the provided indexes into this index.
            
             <para/>
             The provided <see cref="T:Lucene.Net.Index.IndexReader"/>s are not closed.
            
             <para/>
             See <see cref="M:Lucene.Net.Index.IndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])"/> for details on transactional semantics, temporary
             free space required in the <see cref="T:Lucene.Net.Store.Directory"/>, and non-CFS segments on an <see cref="T:System.Exception"/>.
            
             <para/>
             <b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/> you should immediately
             dispose the writer. See <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.
            
             <para/>
             <b>NOTE:</b> empty segments are dropped by this method and not added to this
             index.
            
             <para/>
             <b>NOTE:</b> this method merges all given <see cref="T:Lucene.Net.Index.IndexReader"/>s in one
             merge. If you intend to merge a large number of readers, it may be better
             to call this method multiple times, each time with a small set of readers.
             In principle, if you use a merge policy with a <c>mergeFactor</c> or
             <c>maxMergeAtOnce</c> parameter, you should pass that many readers in one
             call. Also, if the given readers are <see cref="T:Lucene.Net.Index.DirectoryReader"/>s, they can be
             opened with <c>termIndexInterval=-1</c> to save RAM, since during merge
             the in-memory structure is not used. See
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Store.Directory,System.Int32)"/>.
            
             <para/>
             <b>NOTE</b>: if you call <see cref="M:Lucene.Net.Index.IndexWriter.Dispose(System.Boolean)"/> with <c>false</c>, which
             aborts all running merges, then any thread still running this method might
             hit a <see cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>.
             </summary>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException">
                       if the index is corrupt </exception>
             <exception cref="T:System.IO.IOException">
                       if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CopySegmentAsIs(Lucene.Net.Index.SegmentCommitInfo,System.String,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.ISet{System.String},Lucene.Net.Store.IOContext,System.Collections.Generic.ISet{System.String})">
            <summary>
            Copies the segment files as-is into the <see cref="T:Lucene.Net.Index.IndexWriter"/>'s directory. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DoAfterFlush">
            <summary>
            A hook for extending classes to execute operations after pending added and
            deleted documents have been flushed to the <see cref="T:Lucene.Net.Store.Directory"/> but before the change
            is committed (new segments_N file written).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DoBeforeFlush">
            <summary>
            A hook for extending classes to execute operations before pending added and
            deleted documents are flushed to the <see cref="T:Lucene.Net.Store.Directory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.PrepareCommit">
             <summary>
             <para>Expert: prepare for commit.  This does the
             first phase of 2-phase commit. this method does all
             steps necessary to commit changes since this writer
             was opened: flushes pending added and deleted docs,
             syncs the index files, writes most of next segments_N
             file.  After calling this you must call either 
             <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> to finish the commit, or 
             <see cref="M:Lucene.Net.Index.IndexWriter.Rollback"/> to revert the commit and undo all changes
             done since the writer was opened.</para>
            
             <para>You can also just call <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> directly
             without <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/> first in which case that method
             will internally call <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/>.</para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SetCommitData(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Sets the commit user data map. That method is considered a transaction by
            <see cref="T:Lucene.Net.Index.IndexWriter"/> and will be committed (<see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> even if no other
            changes were made to the writer instance. Note that you must call this method
            before <see cref="M:Lucene.Net.Index.IndexWriter.PrepareCommit"/>, or otherwise it won't be included in the
            follow-on <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            <para/>
            <b>NOTE:</b> the dictionary is cloned internally, therefore altering the dictionary's
            contents after calling this method has no effect.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.CommitData">
            <summary>
            Returns the commit user data map that was last committed, or the one that
            was set on <see cref="M:Lucene.Net.Index.IndexWriter.SetCommitData(System.Collections.Generic.IDictionary{System.String,System.String})"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.commitLock">
            <summary>
            Used only by commit and prepareCommit, below; lock
            order is commitLock -> IW
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Commit">
             <summary>
             <para>Commits all pending changes (added &amp; deleted
             documents, segment merges, added
             indexes, etc.) to the index, and syncs all referenced
             index files, such that a reader will see the changes
             and the index updates will survive an OS or machine
             crash or power loss.  Note that this does not wait for
             any running background merges to finish.  This may be a
             costly operation, so you should test the cost in your
             application and do it only when really necessary.</para>
            
             <para> Note that this operation calls <see cref="M:Lucene.Net.Store.Directory.Sync(System.Collections.Generic.ICollection{System.String})"/> on
             the index files.  That call should not return until the
             file contents &amp; metadata are on stable storage.  For
             <see cref="T:Lucene.Net.Store.FSDirectory"/>, this calls the OS's fsync.  But, beware:
             some hardware devices may in fact cache writes even
             during fsync, and return before the bits are actually
             on stable storage, to give the appearance of faster
             performance.  If you have such a device, and it does
             not have a battery backup (for example) then on power
             loss it may still lose data.  Lucene cannot guarantee
             consistency on such devices.  </para>
            
             <para><b>NOTE</b>: if this method hits an <see cref="T:System.OutOfMemoryException"/>
             you should immediately dispose the writer.  See
             <see cref="T:Lucene.Net.Index.IndexWriter"/> for details.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.HasUncommittedChanges">
            <summary>
            Returns <c>true</c> if there may be changes that have not been
            committed.  There are cases where this may return <c>true</c>
            when there are no actual "real" changes to the index,
            for example if you've deleted by <see cref="T:Lucene.Net.Index.Term"/> or <see cref="T:Lucene.Net.Search.Query"/> but
            that <see cref="T:Lucene.Net.Index.Term"/> or <see cref="T:Lucene.Net.Search.Query"/> does not match any documents.
            Also, if a merge kicked off as a result of flushing a
            new segment during <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>, or a concurrent
            merged finished, this method may return <c>true</c> right
            after you had just called <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriter.fullFlushLock">
            <summary>
            Ensures only one <see cref="M:Lucene.Net.Index.IndexWriter.Flush(System.Boolean,System.Boolean)"/> is actually flushing segments
            at a time:
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Flush(System.Boolean,System.Boolean)">
            <summary>
            Flush all in-memory buffered updates (adds and deletes)
            to the <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="triggerMerge"> if <c>true</c>, we may merge segments (if
            deletes or docs were flushed) if necessary </param>
            <param name="applyAllDeletes"> whether pending deletes should also </param>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RamSizeInBytes">
            <summary>
            Expert:  Return the total size of all index files currently cached in memory.
            Useful for size management with flushRamDocs()
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.NumRamDocs">
            <summary>
            Expert:  Return the number of documents currently
            buffered in RAM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CommitMergedDeletesAndUpdates(Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Index.MergeState)">
            <summary>
            Carefully merges deletes and updates for the segments we just merged. This
            is tricky because, although merging will clear all deletes (compacts the
            documents) and compact all the updates, new deletes and updates may have
            been flushed to the segments since the merge was started. This method
            "carries over" such new deletes and updates onto the newly merged segment,
            and saves the resulting deletes and updates files (incrementing the delete
            and DV generations for merge.info). If no deletes were flushed, no new
            deletes file is saved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Merge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Merges the indicated segments, replacing them in the stack with a
            single segment.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeSuccess(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Hook that's called when the specified merge is complete. </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.RegisterMerge(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Checks whether this merge involves any segments
            already participating in a merge.  If not, this merge
            is "registered", meaning we record that its segments
            are now participating in a merge, and <c>true</c> is
            returned.  Else (the merge conflicts) <c>false</c> is
            returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeInit(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does initial setup for a merge, which is fast but holds
            the synchronized lock on <see cref="T:Lucene.Net.Index.IndexWriter"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeFinish(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does fininishing for a merge, which is fast but holds
            the synchronized lock on <see cref="T:Lucene.Net.Index.IndexWriter"/> instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.MergeMiddle(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Does the actual (time-consuming) work of the merge,
            but without holding synchronized lock on <see cref="T:Lucene.Net.Index.IndexWriter"/>
            instance
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString">
            <summary>
            Returns a string description of all segments, for
            debugging.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString(System.Collections.Generic.IEnumerable{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Returns a string description of the specified
            segments, for debugging.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SegString(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns a string description of the specified
            segment, for debugging.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriter.KeepFullyDeletedSegments">
            <summary>
            Only for testing.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.StartCommit(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Walk through all files referenced by the current
            <see cref="F:Lucene.Net.Index.IndexWriter.segmentInfos"/> and ask the <see cref="T:Lucene.Net.Store.Directory"/> to sync each file,
            if it wasn't already.  If that succeeds, then we
            prepare a new segments_N file but do not fully commit
            it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IsLocked(Lucene.Net.Store.Directory)">
            <summary>
            Returns <c>true</c> iff the index in the named directory is
            currently locked. </summary>
            <param name="directory"> the directory to check for a lock </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.Unlock(Lucene.Net.Store.Directory)">
            <summary>
            Forcibly unlocks the index in the named directory.
            <para/>
            Caution: this should only be used by failure recovery code,
            when it is known that no other process nor thread is in fact
            currently accessing this index.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.IndexReaderWarmer">
            <summary>
            If <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/> has
            been called (ie, this writer is in near real-time
            mode), then after a merge completes, this class can be
            invoked to warm the reader on the newly merged
            segment, before the merge commits.  This is not
            required for near real-time search, but will reduce
            search latency on opening a new near real-time reader
            after a merge completes.
            <para/>
            @lucene.experimental
            
            <para/><b>NOTE</b>: <see cref="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.Warm(Lucene.Net.Index.AtomicReader)"/> is called before any deletes have
            been carried over to the merged segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IndexReaderWarmer.Warm(Lucene.Net.Index.AtomicReader)">
            <summary>
            Invoked on the <see cref="T:Lucene.Net.Index.AtomicReader"/> for the newly
            merged segment, before that segment is made visible
            to near-real-time readers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteUnusedFiles">
             <summary>
             Expert: remove any index files that are no longer
             used.
            
             <para> <see cref="T:Lucene.Net.Index.IndexWriter"/> normally deletes unused files itself,
             during indexing.  However, on Windows, which disallows
             deletion of open files, if there is a reader open on
             the index then those files cannot be deleted.  This is
             fine, because <see cref="T:Lucene.Net.Index.IndexWriter"/> will periodically retry
             the deletion.</para>
            
             <para> However, <see cref="T:Lucene.Net.Index.IndexWriter"/> doesn't try that often: only
             on open, close, flushing a new segment, and finishing
             a merge.  If you don't do any of these actions with your
             <see cref="T:Lucene.Net.Index.IndexWriter"/>, you'll see the unused files linger.  If
             that's a problem, call this method to delete them
             (once you've closed the open readers that were
             preventing their deletion).</para>
            
             <para> In addition, you can call this method to delete
             unreferenced index commits. this might be useful if you
             are using an <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> which holds
             onto index commits until some criteria are met, but those
             commits are no longer needed. Otherwise, those commits will
             be deleted the next time <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/> is called.</para>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.CreateCompoundFile(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.CheckAbort,Lucene.Net.Index.SegmentInfo,Lucene.Net.Store.IOContext)">
            <summary>
            NOTE: this method creates a compound file for all files returned by
            info.files(). While, generally, this may include separate norms and
            deletion files, this <see cref="T:Lucene.Net.Index.SegmentInfo"/> must not reference such files when this
            method is called, because they are not allowed within a compound file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Tries to delete the given files if unreferenced </summary>
            <param name="files"> the files to delete </param>
            <exception cref="T:System.IO.IOException"> if an <see cref="T:System.IO.IOException"/> occurs </exception>
            <seealso cref="M:Lucene.Net.Index.IndexFileDeleter.DeleteNewFiles(System.Collections.Generic.ICollection{System.String})"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.FlushFailed(Lucene.Net.Index.SegmentInfo)">
            <summary>
            Cleans up residuals from a segment that could not be entirely flushed due to an error </summary>
            <seealso cref="M:Lucene.Net.Index.IndexFileDeleter.Refresh(System.String)"/>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriter.IEvent">
            <summary>
            Interface for internal atomic events. See <see cref="T:Lucene.Net.Index.DocumentsWriter"/> for details. Events are executed concurrently and no order is guaranteed.
            Each event should only rely on the serializeability within it's process method. All actions that must happen before or after a certain action must be
            encoded inside the <see cref="M:Lucene.Net.Index.IndexWriter.IEvent.Process(Lucene.Net.Index.IndexWriter,System.Boolean,System.Boolean)"/> method.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.IEvent.Process(Lucene.Net.Index.IndexWriter,System.Boolean,System.Boolean)">
            <summary>
            Processes the event. this method is called by the <see cref="T:Lucene.Net.Index.IndexWriter"/>
            passed as the first argument.
            </summary>
            <param name="writer">
                     the <see cref="T:Lucene.Net.Index.IndexWriter"/> that executes the event. </param>
            <param name="triggerMerge">
                     <c>false</c> iff this event should not trigger any segment merges </param>
            <param name="clearBuffers">
                     <c>true</c> iff this event should clear all buffers associated with the event. </param>
            <exception cref="T:System.IO.IOException">
                      if an <see cref="T:System.IO.IOException"/> occurs </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriter.SlowFileExists(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Used only by asserts: returns <c>true</c> if the file exists
            (can be opened), <c>false</c> if it cannot be opened, and
            (unlike <see cref="M:System.IO.File.Exists(System.String)"/>) throws <see cref="T:System.IO.IOException"/> if
            there's some unexpected error.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.IndexWriterConfig">
             <summary>
             Holds all the configuration that is used to create an <see cref="T:Lucene.Net.Index.IndexWriter"/>.
             Once <see cref="T:Lucene.Net.Index.IndexWriter"/> has been created with this object, changes to this
             object will not affect the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance. For that, use
             <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> that is returned from <see cref="P:Lucene.Net.Index.IndexWriter.Config"/>.
            
             <para/>
             LUCENENET NOTE: Unlike Lucene, we use property setters instead of setter methods.
             In C#, this allows you to initialize the <see cref="T:Lucene.Net.Index.IndexWriterConfig"/>
             using the language features of C#, for example:
             <code>
                 IndexWriterConfig conf = new IndexWriterConfig(analyzer)
                 {
                     Codec = Lucene46Codec(),
                     OpenMode = OpenMode.CREATE
                 };
             </code>
             
             However, if you prefer to match the syntax of Lucene using chained setter methods, 
             there are extension methods in the Lucene.Net.Support namespace. Example usage:
             <code>
                 using Lucene.Net.Support;
                 
                 ..
                 
                 IndexWriterConfig conf = new IndexWriterConfig(analyzer)
                     .SetCodec(new Lucene46Codec())
                     .SetOpenMode(OpenMode.CREATE);
             </code>
             
             @since 3.1
             </summary>
             <seealso cref="P:Lucene.Net.Index.IndexWriter.Config"/>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL">
            <summary>
            Default value is 32. Change using <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/> setter. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DISABLE_AUTO_FLUSH">
            <summary>
            Denotes a flush trigger is disabled. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_BUFFERED_DELETE_TERMS">
            <summary>
            Disabled by default (because IndexWriter flushes by RAM usage by default). </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_BUFFERED_DOCS">
            <summary>
            Disabled by default (because IndexWriter flushes by RAM usage by default). </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB">
            <summary>
            Default value is 16 MB (which means flush when buffered docs consume
            approximately 16 MB RAM).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.WRITE_LOCK_TIMEOUT">
            <summary>
            Default value for the write lock timeout (1,000 ms).
            </summary>
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout"/>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_READER_POOLING">
            <summary>
            Default setting for <see cref="P:Lucene.Net.Index.IndexWriterConfig.UseReaderPooling"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_READER_TERMS_INDEX_DIVISOR">
            <summary>
            Default value is 1. Change using <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor"/> setter. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB">
            <summary>
            Default value is 1945. Change using <see cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/> setter. </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES">
            <summary>
            The maximum number of simultaneous threads that may be
            indexing documents at once in <see cref="T:Lucene.Net.Index.IndexWriter"/>; if more
            than this many threads arrive they will wait for
            others to finish. Default value is 8.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_USE_COMPOUND_FILE_SYSTEM">
            <summary>
            Default value for compound file system for newly written segments
            (set to <c>true</c>). For batch indexing with very large
            ram buffers use <c>false</c>
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_CHECK_INTEGRITY_AT_MERGE">
            <summary>
            Default value for calling <see cref="M:Lucene.Net.Index.AtomicReader.CheckIntegrity"/> before
            merging segments (set to <c>false</c>). You can set this
            to <c>true</c> for additional safety.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout">
            <summary>
            Gets or sets the default (for any instance) maximum time to wait for a write lock
            (in milliseconds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetIndexWriter(Lucene.Net.Index.IndexWriter)">
            <summary>
            Gets or sets the <see cref="T:Lucene.Net.Index.IndexWriter"/> this config is attached to.
            </summary>
            <exception cref="!:Util.SetOnce&lt;T&gt;.AlreadySetException">
                      if this config is already attached to a writer. </exception>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.#ctor(Lucene.Net.Util.LuceneVersion,Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a new config that with defaults that match the specified
            <see cref="T:Lucene.Net.Util.LuceneVersion"/> as well as the default 
            <see cref="T:Lucene.Net.Analysis.Analyzer"/>. If <paramref name="matchVersion"/> is &gt;= 
            <see cref="F:Lucene.Net.Util.LuceneVersion.LUCENE_32"/>, <see cref="T:Lucene.Net.Index.TieredMergePolicy"/> is used
            for merging; else <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>.
            Note that <see cref="T:Lucene.Net.Index.TieredMergePolicy"/> is free to select
            non-contiguous merges, which means docIDs may not
            remain monotonic over time.  If this is a problem you
            should switch to <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/> or
            <see cref="T:Lucene.Net.Index.LogDocMergePolicy"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.OpenMode">
             <summary>
             Specifies <see cref="T:Lucene.Net.Index.OpenMode"/> of the index.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexDeletionPolicy">
             <summary>
             Expert: allows an optional <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation to be
             specified. You can use this to control when prior commits are deleted from
             the index. The default policy is <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>
             which removes all prior commits as soon as a new commit is done (this
             matches behavior before 2.2). Creating your own policy can allow you to
             explicitly keep previous "point in time" commits alive in the index for
             some time, to allow readers to refresh to the new commit without having the
             old commit deleted out from under them. This is necessary on filesystems
             like NFS that do not support "delete on last close" semantics, which
             Lucene's "point in time" search normally relies on.
             <para/>
             <b>NOTE:</b> the deletion policy cannot be <c>null</c>.
            
             <para/>Only takes effect when IndexWriter is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexCommit">
             <summary>
             Expert: allows to open a certain commit point. The default is <c>null</c> which
             opens the latest commit point.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.Similarity">
             <summary>
             Expert: set the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation used by this <see cref="T:Lucene.Net.Index.IndexWriter"/>.
             <para/>
             <b>NOTE:</b> the similarity cannot be <c>null</c>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.MergeScheduler">
             <summary>
             Expert: Gets or sets the merge scheduler used by this writer. The default is
             <see cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>.
             <para/>
             <b>NOTE:</b> the merge scheduler cannot be <c>null</c>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.WriteLockTimeout">
             <summary>
             Gets or sets the maximum time to wait for a write lock (in milliseconds) for this
             instance. You can change the default value for all instances by calling the
             <see cref="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout"/> setter.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.Codec">
             <summary>
             Gets or sets the <see cref="T:Lucene.Net.Codecs.Codec"/>.
            
             <para/>
             Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.MergePolicy">
             <summary>
             Expert: <see cref="T:Lucene.Net.Index.MergePolicy"/> is invoked whenever there are changes to the
             segments in the index. Its role is to select which merges to do, if any,
             and return a <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> describing the merges.
             It also selects merges to do for <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexerThreadPool">
            <summary>
            Expert: Gets or sets the <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> instance used by the
            <see cref="T:Lucene.Net.Index.IndexWriter"/> to assign thread-states to incoming indexing threads. If no
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> is set <see cref="T:Lucene.Net.Index.IndexWriter"/> will use
            <see cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> with max number of
            thread-states set to <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES"/> (see
            <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES"/>).
            <para>
            NOTE: The given <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> instance must not be used with
            other <see cref="T:Lucene.Net.Index.IndexWriter"/> instances once it has been initialized / associated with an
            <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </para>
            <para>
            NOTE: this only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.</para>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.MaxThreadStates">
             <summary>
             Gets or sets the max number of simultaneous threads that may be indexing documents
             at once in <see cref="T:Lucene.Net.Index.IndexWriter"/>. Values &lt; 1 are invalid and if passed
             <c>maxThreadStates</c> will be set to
             <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_MAX_THREAD_STATES"/>.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.UseReaderPooling">
             <summary>
             By default, <see cref="T:Lucene.Net.Index.IndexWriter"/> does not pool the
             <see cref="T:Lucene.Net.Index.SegmentReader"/>s it must open for deletions and
             merging, unless a near-real-time reader has been
             obtained by calling <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>.
             this setting lets you enable pooling without getting a
             near-real-time reader.  NOTE: if you set this to
             <c>false</c>, <see cref="T:Lucene.Net.Index.IndexWriter"/> will still pool readers once
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/> is called.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.IndexingChain">
             <summary>
             Expert: Gets or sets the <see cref="T:Lucene.Net.Index.DocConsumer"/> chain to be used to process documents.
            
             <para/>Only takes effect when <see cref="T:Lucene.Net.Index.IndexWriter"/> is first created.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB">
            <summary>
            Expert: Gets or sets the maximum memory consumption per thread triggering a forced
            flush if exceeded. A <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> is forcefully flushed
            once it exceeds this limit even if the <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/> has
            not been exceeded. This is a safety limit to prevent a
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> from address space exhaustion due to its
            internal 32 bit signed integer based memory addressing.
            The given value must be less that 2GB (2048MB).
            </summary>
            <seealso cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_PER_THREAD_HARD_LIMIT_MB"/>
        </member>
        <member name="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy">
            <summary>
            Expert: Controls when segments are flushed to disk during indexing.
            The <see cref="T:Lucene.Net.Index.FlushPolicy"/> initialized during <see cref="T:Lucene.Net.Index.IndexWriter"/> instantiation and once initialized
            the given instance is bound to this <see cref="T:Lucene.Net.Index.IndexWriter"/> and should not be used with another writer.
            </summary>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>
            <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(Lucene.Net.Util.InfoStream)">
            <summary>
            Information about merges, deletes and a
            message when maxFieldLength is reached will be printed
            to this. Must not be <c>null</c>, but <see cref="F:Lucene.Net.Util.InfoStream.NO_OUTPUT"/>
            may be used to supress output.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(System.IO.TextWriter)">
            <summary>
            Convenience method that uses <see cref="T:Lucene.Net.Util.PrintStreamInfoStream"/> to write to the passed in <see cref="T:System.IO.TextWriter"/>. 
            Must not be <c>null</c>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.OpenMode">
            <summary>
            Specifies the open mode for <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.OpenMode.CREATE">
            <summary>
            Creates a new index or overwrites an existing one.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.OpenMode.APPEND">
            <summary>
            Opens an existing index.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.OpenMode.CREATE_OR_APPEND">
            <summary>
            Creates a new index if one does not exist,
            otherwise it opens the index and documents will be appended.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.Abort">
            <summary>
            Abort (called after hitting AbortException) </summary>
        </member>
        <member name="M:Lucene.Net.Index.InvertedDocConsumer.Flush(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Index.InvertedDocConsumerPerField},Lucene.Net.Index.SegmentWriteState)">
            <summary>
            Flush a new segment </summary>
        </member>
        <member name="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy">
            <summary>
            This <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> implementation that
            keeps only the most recent commit and immediately removes
            all prior commits after a new commit is done.  This is
            the default deletion policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnInit``1(System.Collections.Generic.IList{``0})">
            <summary>
            Deletes all commits except the most recent one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy.OnCommit``1(System.Collections.Generic.IList{``0})">
            <summary>
            Deletes all commits except the most recent one.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LiveIndexWriterConfig">
             <summary>
             Holds all the configuration used by <see cref="T:Lucene.Net.Index.IndexWriter"/> with few setters for
             settings that can be changed on an <see cref="T:Lucene.Net.Index.IndexWriter"/> instance "live".
            
             @since 4.0
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.delPolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> controlling when commit
            points are deleted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.commit">
            <summary>
            <see cref="T:Lucene.Net.Index.IndexCommit"/> that <see cref="T:Lucene.Net.Index.IndexWriter"/> is
            opened on.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.openMode">
            <summary>
            <see cref="T:Lucene.Net.Index.OpenMode"/> that <see cref="T:Lucene.Net.Index.IndexWriter"/> is opened
            with.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.similarity">
            <summary>
            <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> to use when encoding norms. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.mergeScheduler">
            <summary>
            <see cref="T:Lucene.Net.Index.IMergeScheduler"/> to use for running merges. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.writeLockTimeout">
            <summary>
            Timeout when trying to obtain the write lock on init. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.indexingChain">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain"/> that determines how documents are
            indexed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.codec">
            <summary>
            <see cref="T:Lucene.Net.Codecs.Codec"/> used to write new segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.infoStream">
            <summary>
            <see cref="T:Lucene.Net.Util.InfoStream"/> for debugging messages. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.mergePolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.MergePolicy"/> for selecting merges. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.indexerThreadPool">
            <summary>
            <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> to control how
            threads are allocated to <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.readerPooling">
            <summary>
            True if readers should be pooled. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.flushPolicy">
            <summary>
            <see cref="T:Lucene.Net.Index.FlushPolicy"/> to control when segments are
            flushed.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.perThreadHardLimitMB">
            <summary>
            Sets the hard upper bound on RAM usage for a single
            segment, after which the segment is forced to flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.matchVersion">
            <summary>
            <see cref="T:Lucene.Net.Util.LuceneVersion"/> that <see cref="T:Lucene.Net.Index.IndexWriter"/> should emulate. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.useCompoundFile">
            <summary>
            True if segment flushes should use compound file format </summary>
        </member>
        <member name="F:Lucene.Net.Index.LiveIndexWriterConfig.checkIntegrityAtMerge">
            <summary>
            True if merging should check integrity of segments before merge </summary>
        </member>
        <member name="M:Lucene.Net.Index.LiveIndexWriterConfig.#ctor(Lucene.Net.Index.IndexWriterConfig)">
            <summary>
            Creates a new config that that handles the live <see cref="T:Lucene.Net.Index.IndexWriter"/>
            settings.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Analyzer">
            <summary>
            Gets the default analyzer to use for indexing documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval">
             <summary>
             Expert: Gets or sets the interval between indexed terms. Large values cause less
             memory to be used by <see cref="T:Lucene.Net.Index.IndexReader"/>, but slow random-access to terms. Small
             values cause more memory to be used by an <see cref="T:Lucene.Net.Index.IndexReader"/>, and speed
             random-access to terms.
             <para/>
             This parameter determines the amount of computation required per query
             term, regardless of the number of documents that contain that term. In
             particular, it is the maximum number of other terms that must be scanned
             before a term is located and its frequency and position information may be
             processed. In a large index with user-entered query terms, query processing
             time is likely to be dominated not by term lookup but rather by the
             processing of frequency and positional data. In a small index or when many
             uncommon query terms are generated (e.g., by wildcard queries) term lookup
             may become a dominant cost.
             <para/>
             In particular, <c>numUniqueTerms/interval</c> terms are read into
             memory by an <see cref="T:Lucene.Net.Index.IndexReader"/>, and, on average, <c>interval/2</c> terms
             must be scanned for each random term access.
            
             <para/>
             Takes effect immediately, but only applies to newly flushed/merged
             segments.
            
             <para/>
             <b>NOTE:</b> this parameter does not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/> implementations,
             including the default one in this release. It only makes sense for term indexes
             that are implemented as a fixed gap between terms. For example,
             <see cref="T:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat"/> implements the term index instead based upon how
             terms share prefixes. To configure its parameters (the minimum and maximum size
             for a block), you would instead use <see cref="M:Lucene.Net.Codecs.Lucene41.Lucene41PostingsFormat.#ctor(System.Int32,System.Int32)"/>.
             which can also be configured on a per-field basis:
             <code>
             public class MyLucene45Codec : Lucene45Codec
             {
                 //customize Lucene41PostingsFormat, passing minBlockSize=50, maxBlockSize=100
                 private readonly PostingsFormat tweakedPostings = new Lucene41PostingsFormat(50, 100);
             
                 public override PostingsFormat GetPostingsFormatForField(string field)
                 {
                     if (field.Equals("fieldWithTonsOfTerms", StringComparison.Ordinal))
                         return tweakedPostings;
                     else
                         return base.GetPostingsFormatForField(field);
                 }
             }
             ...
             
             iwc.Codec = new MyLucene45Codec();
             </code>
             Note that other implementations may have their own parameters, or no parameters at all.
             </summary>
             <seealso cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_TERM_INDEX_INTERVAL"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms">
             <summary>
             Gets or sets a value that determines the maximum number of delete-by-term operations that will be
             buffered before both the buffered in-memory delete terms and queries are
             applied and flushed.
             <para/>
             Disabled by default (writer flushes by RAM usage).
             <para/>
             NOTE: this setting won't trigger a segment flush.
            
             <para/>
             Takes effect immediately, but only the next time a document is added,
             updated or deleted. Also, if you only delete-by-query, this setting has no
             effect, i.e. delete queries are buffered until the next segment is flushed.
             </summary>
             <exception cref="T:System.ArgumentException">
                       if maxBufferedDeleteTerms is enabled but smaller than 1
             </exception>
             <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB">
             <summary>
             Gets or sets a value that determines the amount of RAM that may be used for buffering added documents
             and deletions before they are flushed to the <see cref="T:Lucene.Net.Store.Directory"/>. Generally for
             faster indexing performance it's best to flush by RAM usage instead of
             document count and use as large a RAM buffer as you can.
             <para/>
             When this is set, the writer will flush whenever buffered documents and
             deletions use this much RAM. Pass in
             <see cref="F:Lucene.Net.Index.IndexWriterConfig.DISABLE_AUTO_FLUSH"/> to prevent triggering a flush
             due to RAM usage. Note that if flushing by document count is also enabled,
             then the flush will be triggered by whichever comes first.
             <para/>
             The maximum RAM limit is inherently determined by the runtime's available
             memory. Yet, an <see cref="T:Lucene.Net.Index.IndexWriter"/> session can consume a significantly
             larger amount of memory than the given RAM limit since this limit is just
             an indicator when to flush memory resident documents to the <see cref="T:Lucene.Net.Store.Directory"/>.
             Flushes are likely happen concurrently while other threads adding documents
             to the writer. For application stability the available memory in the runtime
             should be significantly larger than the RAM buffer used for indexing.
             <para/>
             <b>NOTE</b>: the account of RAM usage for pending deletions is only
             approximate. Specifically, if you delete by <see cref="T:Lucene.Net.Search.Query"/>, Lucene currently has no
             way to measure the RAM usage of individual Queries so the accounting will
             under-estimate and you should compensate by either calling <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>
             periodically yourself, or by setting <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>
             to flush and apply buffered deletes by count instead of RAM usage (for each
             buffered delete <see cref="T:Lucene.Net.Search.Query"/> a constant number of bytes is used to estimate RAM
             usage). Note that enabling <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/> will not
             trigger any segment flushes.
             <para/>
             <b>NOTE</b>: It's not guaranteed that all memory resident documents are
             flushed once this limit is exceeded. Depending on the configured
             <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.FlushPolicy"/> only a subset of the buffered documents are flushed and
             therefore only parts of the RAM buffer is released.
             <para/>
            
             The default value is <see cref="F:Lucene.Net.Index.IndexWriterConfig.DEFAULT_RAM_BUFFER_SIZE_MB"/>.
            
             <para/>
             Takes effect immediately, but only the next time a document is added,
             updated or deleted.
             </summary>
             <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/>
             <exception cref="T:System.ArgumentException">
                       if ramBufferSizeMB is enabled but non-positive, or it disables
                       ramBufferSizeMB when maxBufferedDocs is already disabled </exception>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs">
             <summary>
             Gets or sets a value that determines the minimal number of documents required before the buffered
             in-memory documents are flushed as a new Segment. Large values generally
             give faster indexing.
            
             <para/>
             When this is set, the writer will flush every maxBufferedDocs added
             documents. Pass in <see cref="F:Lucene.Net.Index.IndexWriterConfig.DISABLE_AUTO_FLUSH"/> to prevent
             triggering a flush due to number of buffered documents. Note that if
             flushing by RAM usage is also enabled, then the flush will be triggered by
             whichever comes first.
            
             <para/>
             Disabled by default (writer flushes by RAM usage).
            
             <para/>
             Takes effect immediately, but only the next time a document is added,
             updated or deleted.
             </summary>
             <seealso cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>
             <exception cref="T:System.ArgumentException">
                       if maxBufferedDocs is enabled but smaller than 2, or it disables
                       maxBufferedDocs when ramBufferSizeMB is already disabled </exception>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer">
            <summary>
            Gets or sets the merged segment warmer. See <see cref="T:Lucene.Net.Index.IndexWriter.IndexReaderWarmer"/>.
            <para/>
            Takes effect on the next merge.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor">
             <summary>
             Gets or sets the termsIndexDivisor passed to any readers that <see cref="T:Lucene.Net.Index.IndexWriter"/> opens,
             for example when applying deletes or creating a near-real-time reader in
             <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/>. If you pass -1, the
             terms index won't be loaded by the readers. This is only useful in advanced
             situations when you will only .Next() through all terms; attempts to seek
             will hit an exception.
            
             <para/>
             Takes effect immediately, but only applies to readers opened after this
             call
             <para/>
             <b>NOTE:</b> divisor settings &gt; 1 do not apply to all <see cref="T:Lucene.Net.Codecs.PostingsFormat"/>
             implementations, including the default one in this release. It only makes
             sense for terms indexes that can efficiently re-sample terms at load time.
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.OpenMode">
            <summary>
            Gets the <see cref="T:Lucene.Net.Index.OpenMode"/> set by <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/> setter. </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexDeletionPolicy">
            <summary>
            Gets the <see cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> specified in
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexDeletionPolicy"/> setter or
            the default <see cref="T:Lucene.Net.Index.KeepOnlyLastCommitDeletionPolicy"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexCommit">
            <summary>
            Gets the <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexCommit"/> as specified in
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexCommit"/> setter or the default,
            <c>null</c> which specifies to open the latest index commit point.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Similarity">
            <summary>
            Expert: returns the <see cref="T:Lucene.Net.Search.Similarities.Similarity"/> implementation used by this
            <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergeScheduler">
            <summary>
            Returns the <see cref="T:Lucene.Net.Index.IMergeScheduler"/> that was set by
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.MergeScheduler"/> setter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.WriteLockTimeout">
            <summary>
            Returns allowed timeout when acquiring the write lock.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.WriteLockTimeout"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.Codec">
            <summary>
            Returns the current <see cref="T:Lucene.Net.Codecs.Codec"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MergePolicy">
            <summary>
            Returns the current <see cref="T:Lucene.Net.Index.MergePolicy"/> in use by this writer.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.MergePolicy"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexerThreadPool">
            <summary>
            Returns the configured <see cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> instance.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.IndexerThreadPool"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxThreadStates">
            <summary>
            Returns the max number of simultaneous threads that may be indexing
            documents at once in <see cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.UseReaderPooling">
            <summary>
            Returns <c>true</c> if <see cref="T:Lucene.Net.Index.IndexWriter"/> should pool readers even if
            <see cref="M:Lucene.Net.Index.DirectoryReader.Open(Lucene.Net.Index.IndexWriter,System.Boolean)"/> has not been called.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.IndexingChain">
            <summary>
            Returns the indexing chain set on
            <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexingChain"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMPerThreadHardLimitMB">
            <summary>
            Returns the max amount of memory each <see cref="T:Lucene.Net.Index.DocumentsWriterPerThread"/> can
            consume until forcefully flushed.
            </summary>
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.FlushPolicy">
            <seealso cref="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.InfoStream">
            <summary>
            Returns <see cref="T:Lucene.Net.Util.InfoStream"/> used for debugging.
            </summary>
            <seealso cref="M:Lucene.Net.Index.IndexWriterConfig.SetInfoStream(Lucene.Net.Util.InfoStream)"/>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.UseCompoundFile">
            <summary>
            Gets or sets if the <see cref="T:Lucene.Net.Index.IndexWriter"/> should pack newly written segments in a
            compound file. Default is <c>true</c>.
            <para>
            Use <c>false</c> for batch indexing with very large RAM buffer
            settings.
            </para>
            <para>
            <b>Note: To control compound file usage during segment merges see
            <seealso cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/> and
            <seealso cref="P:Lucene.Net.Index.MergePolicy.MaxCFSSegmentSizeMB"/>. This setting only
            applies to newly created segments.</b>
            </para>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LiveIndexWriterConfig.CheckIntegrityAtMerge">
            <summary>
            Gets or sets if <see cref="T:Lucene.Net.Index.IndexWriter"/> should call <see cref="M:Lucene.Net.Index.AtomicReader.CheckIntegrity"/>
            on existing segments before merging them into a new one.
            <para>
            Use <c>true</c> to enable this safety check, which can help
            reduce the risk of propagating index corruption from older segments
            into new ones, at the expense of slower merging.
            </para>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogByteSizeMergePolicy">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.LogMergePolicy"/> that measures size of a
            segment as the total byte size of the segment's files.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MIN_MERGE_MB">
            <summary>Default minimum segment size. </summary>
            <seealso cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MinMergeMB"/>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB">
            <summary>
            Default maximum segment size.  A segment of this size 
            or larger will never be merged. </summary> 
            <seealso cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB"/>
        </member>
        <member name="F:Lucene.Net.Index.LogByteSizeMergePolicy.DEFAULT_MAX_MERGE_MB_FOR_FORCED_MERGE">
            <summary>
            Default maximum segment size.  A segment of this size 
            or larger will never be merged during <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>.  </summary>
            <seealso cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMBForForcedMerge"/>
        </member>
        <member name="M:Lucene.Net.Index.LogByteSizeMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
            defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB">
             <summary>
             <para>Determines the largest segment (measured by total
             byte size of the segment's files, in MB) that may be
             merged with other segments.  Small values (e.g., less
             than 50 MB) are best for interactive indexing, as this
             limits the length of pauses while indexing to a few
             seconds.  Larger values are best for batched indexing
             and speedier searches.</para>
            
             <para>Note that <see cref="P:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs"/> is also
             used to check whether a segment is too large for
             merging (it's either or).</para>
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMBForForcedMerge">
            <summary>
            Determines the largest segment (measured by total
            byte size of the segment's files, in MB) that may be
            merged with other segments during forceMerge. Setting
            it low will leave the index with more than 1 segment,
            even if <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> is called.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogByteSizeMergePolicy.MinMergeMB">
            <summary>
            Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogDocMergePolicy">
            <summary>
            This is a <see cref="T:Lucene.Net.Index.LogMergePolicy"/> that measures size of a
            segment as the number of documents (not taking deletions
            into account).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogDocMergePolicy.DEFAULT_MIN_MERGE_DOCS">
            <summary> Default minimum segment size. </summary>
            <seealso cref="P:Lucene.Net.Index.LogDocMergePolicy.MinMergeDocs"/>
        </member>
        <member name="M:Lucene.Net.Index.LogDocMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
            defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogDocMergePolicy.MinMergeDocs">
            <summary>
            Sets the minimum size for the lowest level segments.
            Any segments below this size are considered to be on
            the same level (even if they vary drastically in size)
            and will be merged whenever there are mergeFactor of
            them.  This effectively truncates the "long tail" of
            small segments that would otherwise be created into a
            single level.  If you set this too large, it could
            greatly increase the merging cost during indexing (if
            you flush many small segments).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.LogMergePolicy">
             <summary>
             <para>This class implements a <see cref="T:Lucene.Net.Index.MergePolicy"/> that tries
             to merge segments into levels of exponentially
             increasing size, where each level has fewer segments than
             the value of the merge factor. Whenever extra segments
             (beyond the merge factor upper bound) are encountered,
             all segments within the level are merged. You can get or
             set the merge factor using <see cref="P:Lucene.Net.Index.LogMergePolicy.MergeFactor"/>.</para>
            
             <para>This class is abstract and requires a subclass to
             define the <see cref="M:Lucene.Net.Index.MergePolicy.Size(Lucene.Net.Index.SegmentCommitInfo)"/> method which specifies how a
             segment's size is determined.  <see cref="T:Lucene.Net.Index.LogDocMergePolicy"/>
             is one subclass that measures size by document count in
             the segment.  <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/> is another
             subclass that measures size as the total byte size of the
             file(s) for the segment.</para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.LEVEL_LOG_SPAN">
            <summary>
            Defines the allowed range of log(size) for each
            level.  A level is computed by taking the max segment
            log size, minus LEVEL_LOG_SPAN, and finding all
            segments falling within that range.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MERGE_FACTOR">
            <summary>
            Default merge factor, which is how many segments are
            merged at a time
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_MAX_MERGE_DOCS">
            <summary>
            Default maximum segment size.  A segment of this size 
            or larger will never be merged. </summary> 
            <seealso cref="P:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs"/>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.DEFAULT_NO_CFS_RATIO">
            <summary>
            Default noCFSRatio.  If a merge's size is >= 10% of
            the index, then we disable compound file for it. </summary>
            <seealso cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_mergeFactor">
            <summary>
            How many segments to merge at a time. </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_minMergeSize">
            <summary>
            Any segments whose size is smaller than this value
            will be rounded up to this value.  This ensures that
            tiny segments are aggressively merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeSize">
            <summary>
            If the size of a segment exceeds this value then it
            will never be merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeSizeForForcedMerge">
            <summary>
            If the size of a segment exceeds this value then it
            will never be merged during <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeDocs">
            <summary>
            If a segment has more than this many documents then it
            will never be merged.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.LogMergePolicy.m_calibrateSizeByDeletes">
            <summary>
            If true, we pro-rate a segment's size by the
            percentage of non-deleted documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.IsVerbose">
            <summary>
            Returns true if <see cref="T:Lucene.Net.Index.LogMergePolicy"/> is enabled in <see cref="F:Lucene.Net.Index.IndexWriter.infoStream"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.Message(System.String)">
            <summary>
            Print a debug message to <see cref="F:Lucene.Net.Index.IndexWriter.infoStream"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.MergeFactor">
            <summary>
            Gets or Sets the number of segments that are merged at
            once and also controls the total number of segments
            allowed to accumulate in the index.
            <para/>
            This determines how often segment indices are merged by
            <see cref="M:Lucene.Net.Index.IndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})"/>.  With smaller values, less RAM is used
            while indexing, and searches are
            faster, but indexing speed is slower.  With larger
            values, more RAM is used during indexing, and while
            searches is slower, indexing is
            faster.  Thus larger values (> 10) are best for batch
            index creation, and smaller values (&lt; 10) for indices
            that are interactively maintained.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes">
            <summary>
            Gets or Sets whether the segment size should be calibrated by
            the number of deletes when choosing segments for merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SizeDocs(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the number of documents in the provided 
            <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>, pro-rated by percentage of
            non-deleted documents if 
            <see cref="P:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes"/> is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.SizeBytes(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the byte size of the provided 
            <see cref="T:Lucene.Net.Index.SegmentCommitInfo"/>, pro-rated by percentage of
            non-deleted documents if 
            <see cref="P:Lucene.Net.Index.LogMergePolicy.CalibrateSizeByDeletes"/> is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.IsMerged(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Returns <c>true</c> if the number of segments eligible for
            merging is less than or equal to the specified 
            <paramref name="maxNumSegments"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMergesSizeLimit(Lucene.Net.Index.SegmentInfos,System.Int32,System.Int32)">
            <summary>
            Returns the merges necessary to merge the index, taking the max merge
            size or max merge docs into consideration. this method attempts to respect
            the {@code maxNumSegments} parameter, however it might be, due to size
            constraints, that more than that number of segments will remain in the
            index. Also, this method does not guarantee that exactly {@code
            maxNumSegments} will remain, but &lt;= that number.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMergesMaxNumSegments(Lucene.Net.Index.SegmentInfos,System.Int32,System.Int32)">
            <summary>
            Returns the merges necessary to <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> the index. this method constraints
            the returned merges only by the <paramref name="maxNumSegments"/> parameter, and
            guaranteed that exactly that number of segments will remain in the index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedMerges(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Returns the merges necessary to merge the index down
            to a specified number of segments.
            this respects the <see cref="F:Lucene.Net.Index.LogMergePolicy.m_maxMergeSizeForForcedMerge"/> setting.
            By default, and assuming <c>maxNumSegments=1</c>, only
            one segment will be left in the index, where that segment
            has no deletions pending nor separate norms, and it is in
            compound file format if the current useCompoundFile
            setting is <c>true</c>.  This method returns multiple merges
            (mergeFactor at a time) so the <see cref="T:Lucene.Net.Index.MergeScheduler"/>
            in use may make use of concurrency.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindForcedDeletesMerges(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Finds merges necessary to force-merge all deletes from the
            index.  We simply merge adjacent segments that have
            deletes, up to mergeFactor at a time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.LogMergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)">
            <summary>
            Checks if any merges are now necessary and returns a
            <see cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> if so.  A merge
            is necessary when there are more than 
            <see cref="P:Lucene.Net.Index.LogMergePolicy.MergeFactor"/> segments at a given level.  When
            multiple levels have too many segments, this method
            will return multiple merges, allowing the 
            <see cref="T:Lucene.Net.Index.MergeScheduler"/> to use concurrency.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.LogMergePolicy.MaxMergeDocs">
             <summary>
             <para>Determines the largest segment (measured by
             document count) that may be merged with other segments.
             Small values (e.g., less than 10,000) are best for
             interactive indexing, as this limits the length of
             pauses while indexing to a few seconds.  Larger values
             are best for batched indexing and speedier
             searches.</para>
            
             <para>The default value is <see cref="F:System.Int32.MaxValue"/>.</para>
            
             <para>The default merge policy 
             (<see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>) also allows you to set this
             limit by net size (in MB) of the segment, using 
             <see cref="P:Lucene.Net.Index.LogByteSizeMergePolicy.MaxMergeMB"/>.</para>
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy">
             <summary>
             <p>Expert: a MergePolicy determines the sequence of
             primitive merge operations.</p>
            
             <p>Whenever the segments in an index have been altered by
             <seealso cref="T:Lucene.Net.Index.IndexWriter"/>, either the addition of a newly
             flushed segment, addition of many segments from
             addIndexes* calls, or a previous merge that may now need
             to cascade, <seealso cref="T:Lucene.Net.Index.IndexWriter"/> invokes {@link
             #findMerges} to give the MergePolicy a chance to pick
             merges that are now required.  this method returns a
             <seealso cref="T:Lucene.Net.Index.MergePolicy.MergeSpecification"/> instance describing the set of
             merges that should be done, or null if no merges are
             necessary.  When IndexWriter.forceMerge is called, it calls
             <seealso cref="!:#findForcedMerges(SegmentInfos,int,Map)"/> and the MergePolicy should
             then return the necessary merges.</p>
            
             <p>Note that the policy can return more than one merge at
             a time.  In this case, if the writer is using {@link
             SerialMergeScheduler}, the merges will be run
             sequentially but if it is using {@link
             ConcurrentMergeScheduler} they will be run concurrently.</p>
            
             <p>The default MergePolicy is {@link
             TieredMergePolicy}.</p>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.DocMap">
            <summary>
            A map of doc IDs. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.#ctor">
            <summary>
            Sole constructor, typically invoked from sub-classes constructors. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.Map(System.Int32)">
            <summary>
            Return the new doc ID according to its old value. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.DocMap.IsConsistent(System.Int32)">
            <summary>
            Useful from an assert. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.OneMerge">
            <summary>
            OneMerge provides the information necessary to perform
             an individual primitive merge operation, resulting in
             a single new segment.  The merge spec includes the
             subset of segments to be merged as well as whether the
             new segment should use the compound file format.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.EstimatedMergeBytes">
            <summary>
            Estimated size in bytes of the merged segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Segments">
            <summary>
            Segments to be merged. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.TotalDocCount">
            <summary>
            Number of documents in the merged segment. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.#ctor(System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Sole constructor. </summary>
            <param name="segments"> List of <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s
                   to be merged.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.GetMergeReaders">
            <summary>
            Expert: Get the list of readers to merge. Note that this list does not
             necessarily match the list of segments to merge and should only be used
             to feed SegmentMerger to initialize a merge. When a <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/>
             reorders doc IDs, it must override <seealso cref="!:#getDocMap"/> too so that
             deletes that happened during the merge can be applied to the newly
             merged segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Info">
            <summary>
            Expert: Sets the <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/> of this <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/>.
            Allows sub-classes to e.g. set diagnostics properties.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.GetDocMap(Lucene.Net.Index.MergeState)">
            <summary>
            Expert: If <seealso cref="!:#getMergeReaders()"/> reorders document IDs, this method
             must be overridden to return a mapping from the <i>natural</i> doc ID
             (the doc ID that would result from a natural merge) to the actual doc
             ID. this mapping is used to apply deletions that happened during the
             merge to the new segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.Exception">
            <summary>
            Record that an exception occurred while executing
             this merge
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.Abort">
            <summary>
            Mark this merge as aborted.  If this is called
             before the merge is committed then the merge will
             not be committed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.IsAborted">
            <summary>
            Returns true if this merge was aborted. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.CheckAborted(Lucene.Net.Store.Directory)">
            <summary>
            Called periodically by <seealso cref="T:Lucene.Net.Index.IndexWriter"/> while
             merging to see if the merge is aborted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.SetPause(System.Boolean)">
            <summary>
            Set or clear whether this merge is paused paused (for example
             <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/> will pause merges
             if too many are running).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.IsPaused">
            <summary>
            Returns true if this merge is paused.
            </summary>
            <seealso cref="M:Lucene.Net.Index.MergePolicy.OneMerge.SetPause(System.Boolean)"/>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.OneMerge.SegString(Lucene.Net.Store.Directory)">
            <summary>
            Returns a readable description of the current merge
             state.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.TotalBytesSize">
            <summary>
            Returns the total size in bytes of this merge. Note that this does not
            indicate the size of the merged segment, but the
            input total size. this is only set once the merge is
            initialized by IndexWriter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.TotalNumDocs">
             <summary>
             Returns the total number of documents that are included with this merge.
             Note that this does not indicate the number of documents after the merge.
            
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.OneMerge.MergeInfo">
            <summary>
            Return <seealso cref="P:Lucene.Net.Index.MergePolicy.OneMerge.MergeInfo"/> describing this merge. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeSpecification">
            <summary>
            A MergeSpecification instance provides the information
            necessary to perform multiple merges.  It simply
            contains a list of <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/> instances.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.MergeSpecification.Merges">
            <summary>
            The subset of segments to be included in the primitive merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.#ctor">
            <summary>
            Sole constructor.  Use {@link
             #add(MergePolicy.OneMerge)} to add merges.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.Add(Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Adds the provided <seealso cref="T:Lucene.Net.Index.MergePolicy.OneMerge"/> to this
             specification.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeSpecification.SegString(Lucene.Net.Store.Directory)">
            <summary>
            Returns a description of the merges in this
             specification.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeException">
            <summary>
            Exception thrown if there are any problems while
             executing a merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.String,Lucene.Net.Store.Directory)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.MergePolicy.MergeException"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.Exception,Lucene.Net.Store.Directory)">
            <summary>
            Create a <see cref="T:Lucene.Net.Index.MergePolicy.MergeException"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Lucene.Net.Index.MergePolicy.MergeException.Directory">
            <summary>
            Returns the <seealso cref="P:Lucene.Net.Index.MergePolicy.MergeException.Directory"/> of the index that hit
             the exception.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergePolicy.MergeAbortedException">
            <summary>
            Thrown when a merge was explicity aborted because
             <seealso cref="!:IndexWriter#close(boolean)"/> was called with
             <code>false</code>.  Normally this exception is
             privately caught and suppresed by <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor">
            <summary>
            Create a <seealso cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor(System.String)">
            <summary>
            Create a <seealso cref="T:Lucene.Net.Index.MergePolicy.MergeAbortedException"/> with a
             specified message.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.MergeAbortedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.DEFAULT_NO_CFS_RATIO">
            <summary>
            Default ratio for compound file system usage. Set to <tt>1.0</tt>, always use
            compound file system.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.DEFAULT_MAX_CFS_SEGMENT_SIZE">
            <summary>
            Default max segment size in order to use compound file system. Set to <seealso cref="!:Long#MAX_VALUE"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.m_writer">
            <summary>
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/> that contains this instance. </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.m_noCFSRatio">
            <summary>
            If the size of the merge segment exceeds this ratio of
             the total index size then it will remain in
             non-compound format
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergePolicy.m_maxCFSSegmentSize">
            <summary>
            If the size of the merged segment exceeds
             this value then it will not use compound file format.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.#ctor">
            <summary>
            Creates a new merge policy instance. Note that if you intend to use it
            without passing it to <seealso cref="T:Lucene.Net.Index.IndexWriter"/>, you should call
            <seealso cref="!:#setIndexWriter(IndexWriter)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.#ctor(System.Double,System.Int64)">
            <summary>
            Creates a new merge policy instance with default settings for noCFSRatio
            and maxCFSSegmentSize. this ctor should be used by subclasses using different
            defaults than the <seealso cref="T:Lucene.Net.Index.MergePolicy"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MergePolicy.SetIndexWriter(Lucene.Net.Index.IndexWriter)" -->
        <member name="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)">
            <summary>
            Determine what set of merge operations are now necessary on the index.
            <see cref="T:Lucene.Net.Index.IndexWriter"/> calls this whenever there is a change to the segments.
            this call is always synchronized on the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance so
            only one thread at a time will call this method. </summary>
            <param name="mergeTrigger"> the event that triggered the merge </param>
            <param name="segmentInfos">
                     the total set of segments in the index </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindForcedMerges(Lucene.Net.Index.SegmentInfos,System.Int32,System.Collections.Generic.IDictionary{Lucene.Net.Index.SegmentCommitInfo,System.Nullable{System.Boolean}})">
            <summary>
            Determine what set of merge operations is necessary in
            order to merge to &lt;= the specified segment count. <see cref="T:Lucene.Net.Index.IndexWriter"/> calls this when its
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> method is called. this call is always
            synchronized on the <see cref="T:Lucene.Net.Index.IndexWriter"/> instance so only one thread at a
            time will call this method.
            </summary>
            <param name="segmentInfos">
                     the total set of segments in the index </param>
            <param name="maxSegmentCount">
                     requested maximum number of segments in the index (currently this
                     is always 1) </param>
            <param name="segmentsToMerge">
                     contains the specific SegmentInfo instances that must be merged
                     away. this may be a subset of all
                     SegmentInfos.  If the value is True for a
                     given SegmentInfo, that means this segment was
                     an original segment present in the
                     to-be-merged index; else, it was a segment
                     produced by a cascaded merge. </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.FindForcedDeletesMerges(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Determine what set of merge operations is necessary in order to expunge all
            deletes from the index.
            </summary>
            <param name="segmentInfos">
                     the total set of segments in the index </param>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Dispose">
            <summary>
            Release all resources for the policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Dispose(System.Boolean)">
            <summary>
            Release all resources for the policy.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.UseCompoundFile(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns true if a new segment (regardless of its origin) should use the
            compound file format. The default implementation returns <code>true</code>
            iff the size of the given mergedInfo is less or equal to
            <seealso cref="!:#getMaxCFSSegmentSizeMB()"/> and the size is less or equal to the
            TotalIndexSize * <seealso cref="!:#getNoCFSRatio()"/> otherwise <code>false</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.Size(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Return the byte size of the provided {@link
             SegmentCommitInfo}, pro-rated by percentage of
             non-deleted documents is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergePolicy.IsMerged(Lucene.Net.Index.SegmentInfos,Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns true if this single info is already fully merged (has no
             pending deletes, is in the same dir as the
             writer, and matches the current compound file setting
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MergePolicy.NoCFSRatio" -->
        <member name="P:Lucene.Net.Index.MergePolicy.MaxCFSSegmentSizeMB">
            <summary>
            Returns the largest size allowed for a compound file segment </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeScheduler">
            <summary>
            <p>Expert: <seealso cref="T:Lucene.Net.Index.IndexWriter"/> uses an instance
             implementing this interface to execute the merges
             selected by a <seealso cref="T:Lucene.Net.Index.MergePolicy"/>.  The default
             MergeScheduler is <seealso cref="T:Lucene.Net.Index.ConcurrentMergeScheduler"/>.</p>
             <p>Implementers of sub-classes should make sure that <seealso cref="!:#clone()"/>
             returns an independent instance able to work with any <seealso cref="T:Lucene.Net.Index.IndexWriter"/>
             instance.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Merge(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergeTrigger,System.Boolean)">
            <summary>
            Run the merges provided by <see cref="M:Lucene.Net.Index.IndexWriter.NextMerge"/>. </summary>
            <param name="writer"> the <see cref="T:Lucene.Net.Index.IndexWriter"/> to obtain the merges from. </param>
            <param name="trigger"> the <see cref="T:Lucene.Net.Index.MergeTrigger"/> that caused this merge to happen </param>
            <param name="newMergesFound"> <c>true</c> iff any new merges were found by the caller; otherwise <c>false</c>
             </param>
        </member>
        <member name="M:Lucene.Net.Index.MergeScheduler.Dispose(System.Boolean)">
            <summary>
            Close this MergeScheduler. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeState">
             <summary>
             Holds common state used during segment merging.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeState.DocMap">
            <summary>
            Remaps docids around deletes during merge
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.DocMap.Get(System.Int32)">
            <summary>
            Returns the mapped docID corresponding to the provided one. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.MaxDoc">
            <summary>
            Returns the total number of documents, ignoring
             deletions.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.NumDocs">
            <summary>
            Returns the number of not-deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.NumDeletedDocs">
            <summary>
            Returns the number of deleted documents. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMap.HasDeletions">
            <summary>
            Returns true if there are any deletions. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.DocMap.Build(Lucene.Net.Index.AtomicReader)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Index.MergeState.DocMap"/> instance appropriate for
             this reader.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.SegmentInfo">
            <summary>
            <seealso cref="P:Lucene.Net.Index.MergeState.SegmentInfo"/> of the newly merged segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.FieldInfos">
            <summary>
            <seealso cref="P:Lucene.Net.Index.MergeState.FieldInfos"/> of the newly merged segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.Readers">
            <summary>
            Readers being merged. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocMaps">
            <summary>
            Maps docIDs around deletions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.DocBase">
            <summary>
            New docID base per reader. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.CheckAbort">
            <summary>
            Holds the CheckAbort instance, which is invoked
             periodically to see if the merge has been aborted.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.InfoStream">
            <summary>
            InfoStream for debugging messages. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.MatchingSegmentReaders">
            <summary>
            <seealso cref="T:Lucene.Net.Index.SegmentReader"/>s that have identical field
            name/number mapping, so their stored fields and term
            vectors may be bulk merged.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MergeState.MatchedCount">
            <summary>
            How many <seealso cref="!:#matchingSegmentReaders"/> are set. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MergeState.#ctor(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReader},Lucene.Net.Index.SegmentInfo,Lucene.Net.Util.InfoStream,Lucene.Net.Index.CheckAbort)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.CheckAbort">
            <summary>
            Class for recording units of work when merging segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckAbort.#ctor(Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Store.Directory)">
            <summary>
            Creates a #CheckAbort instance. </summary>
        </member>
        <member name="M:Lucene.Net.Index.CheckAbort.Work(System.Double)">
            <summary>
            Records the fact that roughly units amount of work
            have been done since this method was last called.
            When adding time-consuming code into SegmentMerger,
            you should test different values for units to ensure
            that the time in between calls to merge.checkAborted
            is up to ~ 1 second.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.CheckAbort.NONE">
            <summary>
            If you use this: IW.close(false) cannot abort your merge!
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MergeTrigger">
            <summary>
            MergeTrigger is passed to
            <see cref="M:Lucene.Net.Index.MergePolicy.FindMerges(Lucene.Net.Index.MergeTrigger,Lucene.Net.Index.SegmentInfos)"/> to indicate the
            event that triggered the merge.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.SEGMENT_FLUSH">
            <summary>
            Merge was triggered by a segment flush.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.FULL_FLUSH">
            <summary>
            Merge was triggered by a full flush. Full flushes
            can be caused by a commit, NRT reader reopen or a close call on the index writer.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.EXPLICIT">
            <summary>
            Merge has been triggered explicitly by the user.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.MERGE_FINISHED">
            <summary>
            Merge was triggered by a successfully finished merge.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.MergeTrigger.CLOSING">
            <summary>
            Merge was triggered by a closing IndexWriter.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiBits" -->
        <member name="T:Lucene.Net.Index.MultiBits.SubResult">
            <summary>
            Represents a sub-Bits from
            <seealso cref="!:MultiBits#getMatchingSub(Lucene.Net.Index.ReaderSlice) getMatchingSub()"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiBits.GetMatchingSub(Lucene.Net.Index.ReaderSlice)" -->
        <member name="T:Lucene.Net.Index.MultiDocsAndPositionsEnum">
             <summary>
             Exposes flex API, merged from flex API of sub-segments.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.#ctor(Lucene.Net.Index.MultiTermsEnum,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.CanReuse(Lucene.Net.Index.MultiTermsEnum)">
            <summary>
            Returns {@code true} if this instance can be reused by
             the provided <seealso cref="T:Lucene.Net.Index.MultiTermsEnum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsAndPositionsEnum.Reset(Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice[],System.Int32)">
            <summary>
            Rre-use and reset this instance on the provided slices. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MultiDocsAndPositionsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice">
            <summary>
            Holds a <seealso cref="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.DocsAndPositionsEnum"/> along with the
             corresponding <seealso cref="T:Lucene.Net.Index.ReaderSlice"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.DocsAndPositionsEnum">
            <summary>
            <seealso cref="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.DocsAndPositionsEnum"/> for this sub-reader. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsAndPositionsEnum.EnumWithSlice.Slice">
            <summary>
            <seealso cref="T:Lucene.Net.Index.ReaderSlice"/> describing how this sub-reader
             fits into the composite reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsEnum">
             <summary>
             Exposes <seealso cref="T:Lucene.Net.Index.DocsEnum"/>, merged from <seealso cref="T:Lucene.Net.Index.DocsEnum"/>
             API of sub-segments.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsEnum.#ctor(Lucene.Net.Index.MultiTermsEnum,System.Int32)">
            <summary>
            Sole constructor </summary>
            <param name="parent"> The <seealso cref="T:Lucene.Net.Index.MultiTermsEnum"/> that created us. </param>
            <param name="subReaderCount"> How many sub-readers are being merged.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocsEnum.CanReuse(Lucene.Net.Index.MultiTermsEnum)">
            <summary>
            Returns {@code true} if this instance can be reused by
             the provided <seealso cref="T:Lucene.Net.Index.MultiTermsEnum"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MultiDocsEnum.NumSubs" -->
        <member name="P:Lucene.Net.Index.MultiDocsEnum.Subs">
            <summary>
            Returns sub-readers we are merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice">
            <summary>
            Holds a <seealso cref="P:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.DocsEnum"/> along with the
             corresponding <seealso cref="T:Lucene.Net.Index.ReaderSlice"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.DocsEnum">
            <summary>
            <seealso cref="P:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.DocsEnum"/> of this sub-reader. </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocsEnum.EnumWithSlice.Slice">
            <summary>
            <seealso cref="T:Lucene.Net.Index.ReaderSlice"/> describing how this sub-reader
             fits into the composite reader.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiDocValues" -->
        <member name="M:Lucene.Net.Index.MultiDocValues.#ctor">
            <summary>
            No instantiation </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetNormValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a NumericDocValues for a reader's norms (potentially merging on-the-fly).
            <p>
            this is a slow way to access normalization values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getNormValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetNumericValues(Lucene.Net.Index.IndexReader,System.String)">
             <summary>
             Returns a NumericDocValues for a reader's docvalues (potentially merging on-the-fly)
             <p>
             this is a slow way to access numeric values. Instead, access them per-segment
             with <seealso cref="!:AtomicReader#getNumericDocValues(String)"/>
             </p>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetDocsWithField(Lucene.Net.Index.IndexReader,System.String)">
             <summary>
             Returns a Bits for a reader's docsWithField (potentially merging on-the-fly)
             <p>
             this is a slow way to access this bitset. Instead, access them per-segment
             with <seealso cref="!:AtomicReader#getDocsWithField(String)"/>
             </p>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetBinaryValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a BinaryDocValues for a reader's docvalues (potentially merging on-the-fly)
            <p>
            this is a slow way to access binary values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getBinaryDocValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetSortedValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a SortedDocValues for a reader's docvalues (potentially doing extremely slow things).
            <p>
            this is an extremely slow way to access sorted values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getSortedDocValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.GetSortedSetValues(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
            Returns a SortedSetDocValues for a reader's docvalues (potentially doing extremely slow things).
            <p>
            this is an extremely slow way to access sorted values. Instead, access them per-segment
            with <seealso cref="!:AtomicReader#getSortedSetDocValues(String)"/>
            </p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.OrdinalMap">
            <summary>
            maps per-segment ordinals to/from global ordinal space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.#ctor(System.Object,Lucene.Net.Index.TermsEnum[])">
            <summary>
            Creates an ordinal map that allows mapping ords to/from a merged
            space from <code>subs</code>. </summary>
            <param name="owner"> a cache key </param>
            <param name="subs"> TermsEnums that support <seealso cref="!:TermsEnum#ord()"/>. They need
                        not be dense (e.g. can be FilteredTermsEnums}. </param>
            <exception cref="!:IOException"> if an I/O error occurred. </exception>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetGlobalOrd(System.Int32,System.Int64)">
            <summary>
            Given a segment number and segment ordinal, returns
            the corresponding global ordinal.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetFirstSegmentOrd(System.Int64)">
            <summary>
            Given global ordinal, returns the ordinal of the first segment which contains
            this ordinal (the corresponding to the segment return <seealso cref="!:#getFirstSegmentNumber"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.GetFirstSegmentNumber(System.Int64)">
            <summary>
            Given a global ordinal, returns the index of the first
            segment that contains this term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.OrdinalMap.ValueCount">
            <summary>
            Returns the total number of unique terms in global ord space.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.OrdinalMap.RamBytesUsed">
            <summary>
            Returns total byte size used by this ordinal map.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues">
            <summary>
            Implements SortedDocValues over n subs, using an OrdinalMap
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.DocStarts">
            <summary>
            docbase for each leaf: parallel with <seealso cref="!:#values"/> </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.Values">
            <summary>
            leaf values </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.Mapping">
            <summary>
            ordinal map mapping ords from <code>values</code> to global ord space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.MultiSortedDocValues.#ctor(Lucene.Net.Index.SortedDocValues[],System.Int32[],Lucene.Net.Index.MultiDocValues.OrdinalMap)">
            <summary>
            Creates a new MultiSortedDocValues over <code>values</code> </summary>
        </member>
        <member name="T:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues">
            <summary>
            Implements MultiSortedSetDocValues over n subs, using an OrdinalMap
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.DocStarts">
            <summary>
            docbase for each leaf: parallel with <seealso cref="!:#values"/> </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.Values">
            <summary>
            leaf values </summary>
        </member>
        <member name="P:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.Mapping">
            <summary>
            ordinal map mapping ords from <code>values</code> to global ord space </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiDocValues.MultiSortedSetDocValues.#ctor(Lucene.Net.Index.SortedSetDocValues[],System.Int32[],Lucene.Net.Index.MultiDocValues.OrdinalMap)">
            <summary>
            Creates a new MultiSortedSetDocValues over <code>values</code> </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiFields" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetFields(Lucene.Net.Index.IndexReader)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetLiveDocs(Lucene.Net.Index.IndexReader)" -->
        <member name="M:Lucene.Net.Index.MultiFields.GetTerms(Lucene.Net.Index.IndexReader,System.String)">
            <summary>
             this method may return null if the field does not exist. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermDocsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermDocsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Index.DocsFlags)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermPositionsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetTermPositionsEnum(Lucene.Net.Index.IndexReader,Lucene.Net.Util.IBits,System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Index.DocsAndPositionsFlags)" -->
        <member name="M:Lucene.Net.Index.MultiFields.#ctor(Lucene.Net.Index.Fields[],Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Expert: construct a new MultiFields instance directly.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetMergedFieldInfos(Lucene.Net.Index.IndexReader)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiFields.GetIndexedFields(Lucene.Net.Index.IndexReader)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.MultiReader" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.MultiReader.#ctor(Lucene.Net.Index.IndexReader[],System.Boolean)" -->
        <member name="T:Lucene.Net.Index.MultiTerms">
             <summary>
             Exposes flex API, merged from flex API of
             sub-segments.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTerms.#ctor(Lucene.Net.Index.Terms[],Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Sole constructor.
            </summary>
            <param name="subs"> The <seealso cref="T:Lucene.Net.Index.Terms"/> instances of all sub-readers. </param>
            <param name="subSlices"> A parallel array (matching {@code
                   subs}) describing the sub-reader slices. </param>
        </member>
        <member name="T:Lucene.Net.Index.MultiTermsEnum">
             <summary>
             Exposes <seealso cref="T:Lucene.Net.Index.TermsEnum"/> API, merged from <seealso cref="T:Lucene.Net.Index.TermsEnum"/> API of sub-segments.
             this does a merge sort, by term text, of the sub-readers.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.MultiTermsEnum.MatchCount" -->
        <member name="P:Lucene.Net.Index.MultiTermsEnum.MatchArray">
            <summary>
            Returns sub-reader slices positioned to the current term. </summary>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermsEnum.#ctor(Lucene.Net.Index.ReaderSlice[])">
            <summary>
            Sole constructor. </summary>
             <param name="slices"> Which sub-reader slices we should
             merge.  </param>
        </member>
        <member name="M:Lucene.Net.Index.MultiTermsEnum.Reset(Lucene.Net.Index.MultiTermsEnum.TermsEnumIndex[])">
            <summary>
            The terms array must be newly created TermsEnum, ie
             <seealso cref="!:TermsEnum#next"/> has not yet been called.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoDeletionPolicy">
            <summary>
            An <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> which keeps all index commits around, never
            deleting them. this class is a singleton and can be accessed by referencing
            <seealso cref="!:#INSTANCE"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoDeletionPolicy.INSTANCE">
            <summary>
            The single instance of this class. </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoMergePolicy">
            <summary>
            A <seealso cref="T:Lucene.Net.Index.MergePolicy"/> which never returns merges to execute (hence it's
            name). It is also a singleton and can be accessed through
            <seealso cref="!:NoMergePolicy#NO_COMPOUND_FILES"/> if you want to indicate the index
            does not use compound files, or through <seealso cref="!:NoMergePolicy#COMPOUND_FILES"/>
            otherwise. Use it if you want to prevent an <seealso cref="T:Lucene.Net.Index.IndexWriter"/> from ever
            executing merges, without going through the hassle of tweaking a merge
            policy's settings to achieve that, such as changing its merge factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergePolicy.NO_COMPOUND_FILES">
            <summary>
            A singleton <seealso cref="T:Lucene.Net.Index.NoMergePolicy"/> which indicates the index does not use
            compound files.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergePolicy.COMPOUND_FILES">
            <summary>
            A singleton <seealso cref="T:Lucene.Net.Index.NoMergePolicy"/> which indicates the index uses compound
            files.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NoMergeScheduler">
            <summary>
            A <see cref="T:Lucene.Net.Index.MergeScheduler"/> which never executes any merges. It is also a
            singleton and can be accessed through <see cref="F:Lucene.Net.Index.NoMergeScheduler.INSTANCE"/>. Use
            it if you want to prevent an <see cref="T:Lucene.Net.Index.IndexWriter"/> from ever executing merges,
            regardless of the <seealso cref="T:Lucene.Net.Index.MergePolicy"/> used. Note that you can achieve the
            same thing by using <seealso cref="T:Lucene.Net.Index.NoMergePolicy"/>, however with
            <seealso cref="T:Lucene.Net.Index.NoMergeScheduler"/> you also ensure that no unnecessary code of any
            <seealso cref="T:Lucene.Net.Index.MergeScheduler"/> implementation is ever executed. Hence it is
            recommended to use both if you want to disable merges from ever happening.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.NoMergeScheduler.INSTANCE">
            <summary>
            The single instance of <seealso cref="T:Lucene.Net.Index.NoMergeScheduler"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.NormsConsumer">
            <summary>
            Writes norms.  Each thread X field accumulates the norms
             for the doc/fields it saw, then the flush method below
             merges all of these together into a single _X.nrm file.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValues">
            <summary>
            A per-document numeric value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.NumericDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.NumericDocValues.Get(System.Int32)">
            <summary>
            Returns the numeric value for the specified document ID. </summary>
            <param name="docID"> document ID to lookup </param>
            <returns> numeric value </returns>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValuesFieldUpdates">
             <summary>
             A <seealso cref="T:Lucene.Net.Index.DocValuesFieldUpdates"/> which holds updates of documents, of a single
             <seealso cref="T:Lucene.Net.Documents.NumericDocValuesField"/>.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Index.NumericDocValuesWriter">
            <summary>
            Buffers up pending long per doc, then flushes when
             segment flushes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.OrdTermState">
             <summary>
             An ordinal based <seealso cref="T:Lucene.Net.Index.TermState"/>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.OrdTermState.Ord">
            <summary>
            Term ordinal, i.e. it's position in the full list of
             sorted terms.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.OrdTermState.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ParallelAtomicReader" -->
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(Lucene.Net.Index.AtomicReader[])">
            <summary>
            Create a ParallelAtomicReader based on the provided
             readers; auto-closes the given readers on <seealso cref="!:#close()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(System.Boolean,Lucene.Net.Index.AtomicReader[])">
            <summary>
            Create a ParallelAtomicReader based on the provided
             readers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelAtomicReader.#ctor(System.Boolean,Lucene.Net.Index.AtomicReader[],Lucene.Net.Index.AtomicReader[])">
            <summary>
            Expert: create a ParallelAtomicReader based on the provided
             readers and storedFieldReaders; when a document is
             loaded, only storedFieldsReaders will be used.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.ParallelAtomicReader.FieldInfos" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ParallelCompositeReader" -->
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(Lucene.Net.Index.CompositeReader[])">
            <summary>
            Create a ParallelCompositeReader based on the provided
             readers; auto-closes the given readers on <seealso cref="!:#close()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(System.Boolean,Lucene.Net.Index.CompositeReader[])">
            <summary>
            Create a ParallelCompositeReader based on the provided
             readers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ParallelCompositeReader.#ctor(System.Boolean,Lucene.Net.Index.CompositeReader[],Lucene.Net.Index.CompositeReader[])">
            <summary>
            Expert: create a ParallelCompositeReader based on the provided
             readers and storedFieldReaders; when a document is
             loaded, only storedFieldsReaders will be used.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy" -->
        <member name="F:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.SNAPSHOTS_PREFIX">
            <summary>
            Prefix used for the save file. </summary>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Store.Directory)">
            <summary>
            <seealso cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/> wraps another
            <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to enable flexible
            snapshotting, passing <seealso cref="!:OpenMode#CREATE_OR_APPEND"/>
            by default.
            </summary>
            <param name="primary">
                     the <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> that is used on non-snapshotted
                     commits. Snapshotted commits, by definition, are not deleted until
                     explicitly released via <seealso cref="!:#release"/>. </param>
            <param name="dir">
                     the <seealso cref="T:Lucene.Net.Store.Directory"/> which will be used to persist the snapshots
                     information. </param>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy,Lucene.Net.Store.Directory,Lucene.Net.Index.OpenMode)">
            <summary>
            <seealso cref="T:Lucene.Net.Index.PersistentSnapshotDeletionPolicy"/> wraps another
            <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> to enable flexible snapshotting.
            </summary>
            <param name="primary">
                     the <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> that is used on non-snapshotted
                     commits. Snapshotted commits, by definition, are not deleted until
                     explicitly released via <seealso cref="!:#release"/>. </param>
            <param name="dir">
                     the <seealso cref="T:Lucene.Net.Store.Directory"/> which will be used to persist the snapshots
                     information. </param>
            <param name="mode">
                     specifies whether a new index should be created, deleting all
                     existing snapshots information (immediately), or open an existing
                     index, initializing the class with the snapshots information. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Snapshot" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.Release(System.Int64)" -->
        <member name="P:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.LastSaveFile">
            <summary>
            Returns the file name the snapshots are currently
             saved to, or null if no snapshots have been saved.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.PersistentSnapshotDeletionPolicy.LoadPriorSnapshots">
            <summary>
            Reads the snapshots information from the given <seealso cref="T:Lucene.Net.Store.Directory"/>. this
            method can be used if the snapshots information is needed, however you
            cannot instantiate the deletion policy (because e.g., some other process
            keeps a lock on the snapshots directory).
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.PrefixCodedTerms">
            <summary>
            Prefix codes term instances (prefixes are shared)
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.GetSizeInBytes">
            <returns> size in bytes </returns>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.GetEnumerator">
            <returns> iterator over the bytes </returns>
        </member>
        <member name="T:Lucene.Net.Index.PrefixCodedTerms.Builder">
            <summary>
            Builds a PrefixCodedTerms: call add repeatedly, then finish. </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.Builder.Add(Lucene.Net.Index.Term)">
            <summary>
            add a term </summary>
        </member>
        <member name="M:Lucene.Net.Index.PrefixCodedTerms.Builder.Finish">
            <summary>
            return finalized form </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.RandomAccessOrds" -->
        <member name="M:Lucene.Net.Index.RandomAccessOrds.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.RandomAccessOrds.OrdAt(System.Int32)" -->
        <member name="M:Lucene.Net.Index.RandomAccessOrds.Cardinality">
            <summary>
            Returns the cardinality for the current document (previously
            set by <seealso cref="!:#setDocument(int)"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.ReaderManager" -->
        <member name="M:Lucene.Net.Index.ReaderManager.#ctor(Lucene.Net.Index.IndexWriter,System.Boolean)">
            <summary>
            Creates and returns a new ReaderManager from the given
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
            <param name="writer">
                     the IndexWriter to open the IndexReader from. </param>
            <param name="applyAllDeletes">
                     If <code>true</code>, all buffered deletes will be applied (made
                     visible) in the <seealso cref="T:Lucene.Net.Search.IndexSearcher"/> / <seealso cref="T:Lucene.Net.Index.DirectoryReader"/>.
                     If <code>false</code>, the deletes may or may not be applied, but
                     remain buffered (in IndexWriter) so that they will be applied in
                     the future. Applying deletes can be costly, so if your app can
                     tolerate deleted documents being returned you might gain some
                     performance by passing <code>false</code>. See
                     <seealso cref="!:DirectoryReader#openIfChanged(DirectoryReader, IndexWriter, boolean)"/>.
            </param>
            <exception cref="!:IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.ReaderManager.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Creates and returns a new ReaderManager from the given <seealso cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="dir"> the directory to open the DirectoryReader on.
            </param>
            <exception cref="!:IOException"> If there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReader(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Index.SegmentReader"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReadOnlyClone(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a ref to a clone. NOTE: you should decRef() the reader when you're
            dont (ie do not call close()).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetInt64Enumerable(Lucene.Net.Index.SegmentReader,System.String,Lucene.Net.Index.NumericDocValuesFieldUpdates)">
            <summary>
            NOTE: This was getLongEnumerable() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.GetReaderForMerge(Lucene.Net.Store.IOContext)">
            <summary>
            Returns a reader for merge. this method applies field updates if there are
            any and marks that this segment is currently merging.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReadersAndUpdates.DropMergingUpdates">
            <summary>
            Drops all merging updates. Called from IndexWriter after this segment
            finished merging (whether successfully or not).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReadersAndUpdates.MergingFieldUpdates">
            <summary>
            Returns updates that came in while this segment was merging. </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReaderSlice">
             <summary>
             Subreader slice from a parent composite reader.
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.ReaderSlice.EMPTY_ARRAY">
            <summary>
            Zero-length {@code ReaderSlice} array. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReaderSlice.Start">
            <summary>
            Document ID this slice starts from. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReaderSlice.Length">
            <summary>
            Number of documents in this slice. </summary>
        </member>
        <member name="P:Lucene.Net.Index.ReaderSlice.ReaderIndex">
            <summary>
            Sub-reader index for this slice. </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderSlice.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Index.ReaderUtil">
             <summary>
             Common util methods for dealing with <seealso cref="T:Lucene.Net.Index.IndexReader"/>s and <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>s.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.GetTopLevelContext(Lucene.Net.Index.IndexReaderContext)">
            <summary>
            Walks up the reader tree and return the given context's top level reader
            context, or in other words the reader tree's root context.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.SubIndex(System.Int32,System.Int32[])">
            <summary>
            Returns index of the searcher/reader for document <code>n</code> in the
            array used to construct this searcher/reader.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ReaderUtil.SubIndex(System.Int32,System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Returns index of the searcher/reader for document <code>n</code> in the
            array used to construct this searcher/reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentCommitInfo">
             <summary>
             Embeds a [read-only] SegmentInfo and adds per-commit
              fields.
            
              @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.Info">
            <summary>
            The <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> that we wrap. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.#ctor(Lucene.Net.Index.SegmentInfo,System.Int32,System.Int64,System.Int64)">
            <summary>
            Sole constructor.
            </summary>
            <param name="info">
                     <seealso cref="T:Lucene.Net.Index.SegmentInfo"/> that we wrap </param>
            <param name="delCount">
                     number of deleted documents in this segment </param>
            <param name="delGen">
                     deletion generation number (used to name deletion files) </param>
            <param name="fieldInfosGen">
                     FieldInfos generation number (used to name field-infos files)
             </param>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.UpdatesFiles">
            <summary>
            Returns the per generation updates files. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.SetGenUpdatesFiles(System.Collections.Generic.IDictionary{System.Int64,System.Collections.Generic.ISet{System.String}})">
            <summary>
            Sets the updates file names per generation. Does not deep clone the map. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceDelGen">
            <summary>
            Called when we succeed in writing deletes </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceNextWriteDelGen">
            <summary>
            Called if there was an exception while writing
             deletes, so that we don't try to write to the same
             file more than once.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceFieldInfosGen">
            <summary>
            Called when we succeed in writing a new FieldInfos generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.AdvanceNextWriteFieldInfosGen">
            <summary>
            Called if there was an exception while writing a new generation of
            FieldInfos, so that we don't try to write to the same file more than once.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentCommitInfo.GetSizeInBytes" -->
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.Files">
            <summary>
            Returns all files in use by this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.HasDeletions">
            <summary>
            Returns true if there are any deletions for the
            segment at this commit.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.HasFieldUpdates">
            <summary>
            Returns true if there are any field updates for the segment in this commit. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.NextFieldInfosGen">
            <summary>
            Returns the next available generation number of the FieldInfos files. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.FieldInfosGen">
            <summary>
            Returns the generation number of the field infos file or -1 if there are no
            field updates yet.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.NextDelGen">
            <summary>
            Returns the next available generation number
            of the live docs file.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.DelGen">
            <summary>
            Returns generation number of the live docs file
            or -1 if there are no deletes yet.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentCommitInfo.DelCount">
            <summary>
            Returns the number of deleted docs in the segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCommitInfo.ToString(Lucene.Net.Store.Directory,System.Int32)">
            <summary>
            Returns a description of this segment. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentCoreReaders">
            <summary>
            Holds core readers that are shared (unchanged) when
            SegmentReader is cloned or reopened
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentCoreReaders.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentDocValues">
            <summary>
            Manages the <seealso cref="T:Lucene.Net.Codecs.DocValuesProducer"/> held by <seealso cref="T:Lucene.Net.Index.SegmentReader"/> and
            keeps track of their reference counting.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentDocValues.GetDocValuesProducer(System.Nullable{System.Int64},Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Store.IOContext,Lucene.Net.Store.Directory,Lucene.Net.Codecs.DocValuesFormat,System.Collections.Generic.IList{Lucene.Net.Index.FieldInfo},System.Int32)">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Codecs.DocValuesProducer"/> for the given generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentDocValues.DecRef(System.Collections.Generic.IList{System.Nullable{System.Int64}})">
            <summary>
            Decrement the reference count of the given <seealso cref="T:Lucene.Net.Codecs.DocValuesProducer"/>
            generations.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfo">
             <summary>
             Information about a segment such as it's name, directory, and files related
             to the segment.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.NO">
            <summary>
            Used by some member fields to mean not present (e.g.,
             norms, deletions).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.YES">
            <summary>
            Used by some member fields to mean present (e.g.,
             norms, deletions).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Name">
            <summary>
            Unique segment name in the directory. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Dir">
            <summary>
            Where this segment resides. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfo.attributes">
            @deprecated not used anymore
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.String,System.String,System.Int32,System.Boolean,Lucene.Net.Codecs.Codec,System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Construct a new complete SegmentInfo instance from input.
            <p>Note: this is public only to allow access from
            the codecs package.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.#ctor(Lucene.Net.Store.Directory,System.String,System.String,System.Int32,System.Boolean,Lucene.Net.Codecs.Codec,System.Collections.Generic.IDictionary{System.String,System.String},System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Construct a new complete SegmentInfo instance from input.
            <p>Note: this is public only to allow access from
            the codecs package.</p>
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.HasSeparateNorms">
            @deprecated separate norms are not supported in >= 4.0
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.UseCompoundFile">
            <summary>
            Mark whether this segment is stored as a compound file.
            </summary>
            <param name="isCompoundFile"> true if this is a compound file;
            else, false </param>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.Codec">
            <summary>
            Can only be called once. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfo.DocCount">
            <summary>
            Returns number of documents in this segment (deletions
             are not taken into account).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetFiles">
            <summary>
            Return all files referenced by this SegmentInfo. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.ToString(Lucene.Net.Store.Directory,System.Int32)">
             <summary>
             Used for debugging.  Format may suddenly change.
            
              <p>Current format looks like
              <code>_a(3.1):c45/4</code>, which means the segment's
              name is <code>_a</code>; it was created with Lucene 3.1 (or
              '?' if it's unknown); it's using compound file
              format (would be <code>C</code> if not compound); it
              has 45 documents; it has 4 deletions (this part is
              left off when there are no deletions).</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.Equals(System.Object)">
            <summary>
            We consider another SegmentInfo instance equal if it
             has the same dir and same name.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.SegmentInfo.Version" -->
        <member name="M:Lucene.Net.Index.SegmentInfo.SetFiles(System.Collections.Generic.ISet{System.String})">
            <summary>
            Sets the files written for this segment. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AddFiles(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Add these files to the set of files written for this
             segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.AddFile(System.String)">
            <summary>
            Add this file to the set of files written for this
             segment.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfo.GetAttribute(System.String)">
            <summary>
            Get a codec attribute value, or null if it does not exist
            </summary>
            @deprecated no longer supported
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfo.PutAttribute(System.String,System.String)" -->
        <member name="P:Lucene.Net.Index.SegmentInfo.Attributes">
            <summary>
            Returns the internal codec attributes map.
            </summary>
            <returns> internal codec attributes map. May be null if no mappings exist.
            </returns>
            @deprecated no longer supported
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentInfos" -->
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_40">
            <summary>
            The file format version for the segments_N codec header, up to 4.5. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_46">
            <summary>
            The file format version for the segments_N codec header, since 4.6+. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.VERSION_48">
            <summary>
            The file format version for the segments_N codec header, since 4.8+ </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.FORMAT_SEGMENTS_GEN_CURRENT">
            <summary>
            Current format of segments.gen </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Counter">
            <summary>
            Used to name new segments. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SegmentInfos.userData">
            <summary>
            Opaque Map&lt;String, String&gt; that user can specify during IndexWriter.commit </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Index.SegmentInfos.infoStream" -->
        <member name="M:Lucene.Net.Index.SegmentInfos.#ctor">
            <summary>
            Sole constructor. Typically you call this and then
             use {@link #read(Directory) or
             #read(Directory,String)} to populate each {@link
             SegmentCommitInfo}.  Alternatively, you can add/remove your
             own <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Info(System.Int32)">
            <summary>
            Returns <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/> at the provided
             index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitGeneration(System.String[])">
            <summary>
            Get the generation of the most recent commit to the
            list of index files (N in the segments_N file).
            </summary>
            <param name="files"> -- array of file names to check </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitGeneration(Lucene.Net.Store.Directory)">
            <summary>
            Get the generation of the most recent commit to the
            index in this directory (N in the segments_N file).
            </summary>
            <param name="directory"> -- directory to search for the latest segments_N file </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitSegmentsFileName(System.String[])">
            <summary>
            Get the filename of the segments_N file for the most
            recent commit in the list of index files.
            </summary>
            <param name="files"> -- array of file names to check </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetLastCommitSegmentsFileName(Lucene.Net.Store.Directory)">
            <summary>
            Get the filename of the segments_N file for the most
            recent commit to the index in this Directory.
            </summary>
            <param name="directory"> -- directory to search for the latest segments_N file </param>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GetSegmentsFileName">
            <summary>
            Get the segments_N filename in use by this segment infos.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.GenerationFromSegmentsFileName(System.String)">
            <summary>
            Parse the generation off the segments file name and
            return it.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.WriteSegmentsGen(Lucene.Net.Store.Directory,System.Int64)" -->
        <member name="M:Lucene.Net.Index.SegmentInfos.GetNextSegmentFileName">
            <summary>
            Get the next segments_N filename that will be written.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Read a particular segmentFileName.  Note that this may
            throw an IOException if a commit is in process.
            </summary>
            <param name="directory"> -- directory containing the segments file </param>
            <param name="segmentFileName"> -- segment file to load </param>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="T:System.IO.IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Read(Lucene.Net.Store.Directory)">
            <summary>
            Find the latest commit ({@code segments_N file}) and
             load all <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clone">
            <summary>
            Returns a copy of this instance, also copying each
            SegmentInfo.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Version">
            <summary>
            Counts how often the index has been changed.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Generation">
            <summary>
            Returns current generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.LastGeneration">
            <summary>
            Returns last succesfully read or written generation. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.InfoStream">
            <summary>
            If non-null, information about retries when loading
            the segments file will be printed to this.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.DefaultGenLookaheadCount">
             <summary>
             Gets or Sets the <see cref="F:Lucene.Net.Index.SegmentInfos.defaultGenLookaheadCount"/>.
             
             Advanced: set how many times to try incrementing the
             gen when loading the segments file.  this only runs if
             the primary (listing directory) and secondary (opening
             segments.gen file) methods fail to find the segments
             file.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Message(System.String)">
            <summary>
            Prints the given message to the infoStream. Note, this method does not
            check for null infoStream. It assumes this check has been performed by the
            caller, which is recommended to avoid the (usually) expensive message
            creation.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentInfos.FindSegmentsFile">
            <summary>
            Utility class for executing code that needs to do
            something with the current segments file.  this is
            necessary with lock-less commits because from the time
            you locate the current segments file name, until you
            actually open it, read its contents, or check modified
            time, etc., it could have been deleted due to a writer
            commit finishing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.Run">
            <summary>
            Locate the most recent {@code segments} file and
             run <seealso cref="!:#doBody"/> on it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.Run(Lucene.Net.Index.IndexCommit)">
            <summary>
            Run <seealso cref="!:#doBody"/> on the provided commit. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.FindSegmentsFile.DoBody(System.String)">
            <summary>
            Subclass must implement this.  The assumption is an
            IOException will be thrown if something goes wrong
            during the processing that could have been caused by
            a writer committing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.PrepareCommit(Lucene.Net.Store.Directory)">
             <summary>
             Call this to start a commit.  this writes the new
              segments file, but writes an invalid checksum at the
              end, so that it is not visible to readers.  Once this
              is called you must call <seealso cref="!:#finishCommit"/> to complete
              the commit or <seealso cref="!:#rollbackCommit"/> to abort it.
              <p>
              Note: <seealso cref="!:#changed()"/> should be called prior to this
              method if changes have been made to this <seealso cref="T:Lucene.Net.Index.SegmentInfos"/> instance
              </p>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Files(Lucene.Net.Store.Directory,System.Boolean)">
            <summary>
            Returns all file names referenced by SegmentInfo
             instances matching the provided Directory (ie files
             associated with any "external" segments are skipped).
             The returned collection is recomputed on each
             invocation.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Commit(Lucene.Net.Store.Directory)" -->
        <member name="M:Lucene.Net.Index.SegmentInfos.ToString(Lucene.Net.Store.Directory)">
            <summary>
            Returns readable description of this segment. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.SegmentInfos.UserData" -->
        <member name="M:Lucene.Net.Index.SegmentInfos.Replace(Lucene.Net.Index.SegmentInfos)">
            <summary>
            Replaces all segments in this instance, but keeps
             generation, version, counter so that future commits
             remain write once.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.TotalDocCount">
            <summary>
            Returns sum of all segment's docCounts.  Note that
             this does not include deletions
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Changed">
            <summary>
            Call this before committing if changes have been made to the
             segments.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.ApplyMergeChanges(Lucene.Net.Index.MergePolicy.OneMerge,System.Boolean)">
            <summary>
            applies all changes caused by committing a merge to this SegmentInfos </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.AsList">
            <summary>
            Returns all contained segments as an <b>unmodifiable</b> <seealso cref="!:List"/> view. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentInfos.Count">
            <summary>
            Returns number of <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. 
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Add(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Appends the provided <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.AddAll(System.Collections.Generic.IEnumerable{Lucene.Net.Index.SegmentCommitInfo})">
            <summary>
            Appends the provided <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentInfos.Clear">
            <summary>
            Clear all <seealso cref="T:Lucene.Net.Index.SegmentCommitInfo"/>s. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Remove(Lucene.Net.Index.SegmentCommitInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Remove(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.Contains(Lucene.Net.Index.SegmentCommitInfo)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentInfos.IndexOf(Lucene.Net.Index.SegmentCommitInfo)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentMerger" -->
        <member name="P:Lucene.Net.Index.SegmentMerger.ShouldMerge">
            <summary>
            True if any merging should happen </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.Merge">
            <summary>
            Merges the readers into the directory passed to the constructor </summary>
            <returns> The number of documents that were merged </returns>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeFields">
            
             <returns> The number of documents in all of the readers </returns>
             <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
             <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentMerger.MergeVectors">
            <summary>
            Merge the TermVectors from each of the segments into the new one. </summary>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SegmentReader" -->
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,System.Int32,Lucene.Net.Store.IOContext)">
            <summary>
            Constructs a new SegmentReader with a new core. </summary>
            <exception cref="T:Lucene.Net.Index.CorruptIndexException"> if the index is corrupt </exception>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.SegmentReader)">
            <summary>
            Create new SegmentReader sharing core from a previous
             SegmentReader and loading new live docs from a new
             deletes file.  Used by openIfChanged.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.#ctor(Lucene.Net.Index.SegmentCommitInfo,Lucene.Net.Index.SegmentReader,Lucene.Net.Util.IBits,System.Int32)">
            <summary>
            Create new SegmentReader sharing core from a previous
             SegmentReader and using the provided in-memory
             liveDocs.  Used by IndexWriter to provide a new NRT
             reader
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.ReadFieldInfos(Lucene.Net.Index.SegmentCommitInfo)">
             <summary>
             Reads the most recent <seealso cref="P:Lucene.Net.Index.SegmentReader.FieldInfos"/> of the given segment info.
            
             @lucene.internal
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.FieldsReader">
            <summary>
            Expert: retrieve thread-private {@link
             StoredFieldsReader}
             @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.TermVectorsReader">
            <summary>
            Expert: retrieve thread-private {@link
             TermVectorsReader}
             @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.SegmentName">
            <summary>
            Return the name of the segment this reader is reading.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.SegmentInfo">
            <summary>
            Return the SegmentInfoPerCommit of the segment this reader is reading.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.Directory">
            <summary>
            Returns the directory this index resides in. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReader.TermInfosIndexDivisor">
            <summary>
            Returns term infos index divisor originally passed to
             <seealso cref="!:#SegmentReader(SegmentCommitInfo, int, IOContext)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReader.ICoreClosedListener">
             <summary>
             Called when the shared core for this SegmentReader
             is closed.
             <p>
             this listener is called only once all SegmentReaders
             sharing the same core are closed.  At this point it
             is safe for apps to evict this reader from any caches
             keyed on <seealso cref="!:#getCoreCacheKey"/>.  this is the same
             interface that <seealso cref="!:IFieldCache"/> uses, internally,
             to evict entries.</p>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.ICoreClosedListener.OnClose(System.Object)">
            <summary>
            Invoked when the shared core of the original {@code
             SegmentReader} has closed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.AddCoreClosedListener(Lucene.Net.Index.SegmentReader.ICoreClosedListener)">
            <summary>
            Expert: adds a CoreClosedListener to this reader's shared core </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.RemoveCoreClosedListener(Lucene.Net.Index.SegmentReader.ICoreClosedListener)">
            <summary>
            Expert: removes a CoreClosedListener from this reader's shared core </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReader.RamBytesUsed">
            <summary>
            Returns approximate RAM Bytes used </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentReadState">
            <summary>
            Holder class for common parameters used during read.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.Directory">
            <summary>
            <seealso cref="P:Lucene.Net.Index.SegmentReadState.Directory"/> where this segment is read from. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.SegmentInfo">
            <summary>
            <seealso cref="P:Lucene.Net.Index.SegmentReadState.SegmentInfo"/> describing this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.FieldInfos">
            <summary>
            <seealso cref="P:Lucene.Net.Index.SegmentReadState.FieldInfos"/> describing all fields in this
             segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentReadState.Context">
            <summary>
            <seealso cref="T:Lucene.Net.Store.IOContext"/> to pass to {@link
             Directory#openInput(String,IOContext)}.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.SegmentReadState.TermsIndexDivisor" -->
        <member name="P:Lucene.Net.Index.SegmentReadState.SegmentSuffix">
            <summary>
            Unique suffix for any postings files read for this
             segment.  <seealso cref="T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat"/> sets this for
             each of the postings formats it wraps.  If you create
             a new <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/> then any files you
             write/read must be derived using this suffix (use
             <seealso cref="!:IndexFileNames#segmentFileName(String,String,String)"/>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.Int32)">
            <summary>
            Create a {@code SegmentReadState}. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,Lucene.Net.Store.IOContext,System.Int32,System.String)">
            <summary>
            Create a {@code SegmentReadState}. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentReadState.#ctor(Lucene.Net.Index.SegmentReadState,System.String)">
            <summary>
            Create a {@code SegmentReadState}. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SegmentWriteState">
            <summary>
            Holder class for common parameters used during write.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.InfoStream">
            <summary>
            <seealso cref="P:Lucene.Net.Index.SegmentWriteState.InfoStream"/> used for debugging messages. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.Directory">
            <summary>
            <seealso cref="P:Lucene.Net.Index.SegmentWriteState.Directory"/> where this segment will be written
             to.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.SegmentInfo">
            <summary>
            <seealso cref="P:Lucene.Net.Index.SegmentWriteState.SegmentInfo"/> describing this segment. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.FieldInfos">
            <summary>
            <seealso cref="P:Lucene.Net.Index.SegmentWriteState.FieldInfos"/> describing all fields in this
             segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.DelCountOnFlush">
            <summary>
            Number of deleted documents set while flushing the
             segment.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.SegUpdates">
            <summary>
            Deletes and updates to apply while we are flushing the segment. A Term is
            enrolled in here if it was deleted/updated at one point, and it's mapped to
            the docIDUpto, meaning any docID &lt; docIDUpto containing this term should
            be deleted/updated.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.LiveDocs">
            <summary>
            <seealso cref="T:Lucene.Net.Util.IMutableBits"/> recording live documents; this is
             only set if there is one or more deleted documents.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.SegmentSuffix">
            <summary>
            Unique suffix for any postings files written for this
             segment.  <seealso cref="T:Lucene.Net.Codecs.PerField.PerFieldPostingsFormat"/> sets this for
             each of the postings formats it wraps.  If you create
             a new <seealso cref="T:Lucene.Net.Codecs.PostingsFormat"/> then any files you
             write/read must be derived using this suffix (use
             <seealso cref="!:IndexFileNames#segmentFileName(String,String,String)"/>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.TermIndexInterval">
            <summary>
            Expert: The fraction of terms in the "dictionary" which should be stored
            in RAM.  Smaller values use more memory, but make searching slightly
            faster, while larger values use less memory and make searching slightly
            slower.  Searching is typically not dominated by dictionary lookup, so
            tweaking this is rarely useful.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.SegmentWriteState.Context">
            <summary>
            <seealso cref="T:Lucene.Net.Store.IOContext"/> for all writes; you should pass this
             to <seealso cref="!:Directory#createOutput(String,IOContext)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,System.Int32,Lucene.Net.Index.BufferedUpdates,Lucene.Net.Store.IOContext)">
            <summary>
            Sole constructor. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Util.InfoStream,Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfo,Lucene.Net.Index.FieldInfos,System.Int32,Lucene.Net.Index.BufferedUpdates,Lucene.Net.Store.IOContext,System.String)" -->
        <member name="M:Lucene.Net.Index.SegmentWriteState.#ctor(Lucene.Net.Index.SegmentWriteState,System.String)">
            <summary>
            Create a shallow copy of <seealso cref="T:Lucene.Net.Index.SegmentWriteState"/> with a new segment suffix. </summary>
        </member>
        <member name="T:Lucene.Net.Index.SerialMergeScheduler">
            <summary>
            A <seealso cref="T:Lucene.Net.Index.MergeScheduler"/> that simply does each merge
             sequentially, using the current thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SerialMergeScheduler.Merge(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergeTrigger,System.Boolean)">
            <summary>
            Just do the merges in sequence. We do this
            "synchronized" so that even if the application is using
            multiple threads, only one merge may run at a time.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SimpleMergedSegmentWarmer">
            <summary>
            A very simple merged segment warmer that just ensures
            data structures are initialized.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SimpleMergedSegmentWarmer.#ctor(Lucene.Net.Util.InfoStream)">
            <summary>
            Creates a new SimpleMergedSegmentWarmer </summary>
            <param name="infoStream"> InfoStream to log statistics about warming. </param>
        </member>
        <member name="T:Lucene.Net.Index.SingleTermsEnum">
            <summary>
            Subclass of FilteredTermsEnum for enumerating a single term.
            <para/>
            For example, this can be used by <see cref="T:Lucene.Net.Search.MultiTermQuery"/>s
            that need only visit one term, but want to preserve
            MultiTermQuery semantics such as <see cref="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SingleTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SingletonSortedSetDocValues" -->
        <member name="M:Lucene.Net.Index.SingletonSortedSetDocValues.#ctor(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Creates a multi-valued view over the provided SortedDocValues </summary>
        </member>
        <member name="P:Lucene.Net.Index.SingletonSortedSetDocValues.SortedDocValues">
            <summary>
            Return the wrapped <seealso cref="P:Lucene.Net.Index.SingletonSortedSetDocValues.SortedDocValues"/> </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SlowCompositeReaderWrapper" -->
        <member name="M:Lucene.Net.Index.SlowCompositeReaderWrapper.Wrap(Lucene.Net.Index.IndexReader)">
            <summary>
            this method is sugar for getting an <seealso cref="T:Lucene.Net.Index.AtomicReader"/> from
            an <seealso cref="T:Lucene.Net.Index.IndexReader"/> of any kind. If the reader is already atomic,
            it is returned unchanged, otherwise wrapped by this class.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SnapshotDeletionPolicy" -->
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.m_refCounts">
            <summary>
            Records how many snapshots are held against each
             commit generation
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.m_indexCommits">
            <summary>
            Used to map gen to IndexCommit. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.primary">
            <summary>
            Wrapped <seealso cref="T:Lucene.Net.Index.IndexDeletionPolicy"/> </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.m_lastCommit">
            <summary>
            Most recently committed <seealso cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.initCalled">
            <summary>
            Used to detect misuse </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.#ctor(Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>
            Sole constructor, taking the incoming {@link
             IndexDeletionPolicy} to wrap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.Release(Lucene.Net.Index.IndexCommit)">
            <summary>
            Release a snapshotted commit.
            </summary>
            <param name="commit">
                     the commit previously returned by <seealso cref="!:#snapshot"/> </param>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.ReleaseGen(System.Int64)">
            <summary>
            Release a snapshot by generation. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.IncRef(Lucene.Net.Index.IndexCommit)">
            <summary>
            Increments the refCount for this <seealso cref="T:Lucene.Net.Index.IndexCommit"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SnapshotDeletionPolicy.Snapshot" -->
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.GetSnapshots">
            <summary>
            Returns all IndexCommits held by at least one snapshot. </summary>
        </member>
        <member name="P:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCount">
            <summary>
            Returns the total number of snapshots currently held. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.GetIndexCommit(System.Int64)">
            <summary>
            Retrieve an <seealso cref="T:Lucene.Net.Index.IndexCommit"/> from its generation;
             returns null if this IndexCommit is not currently
             snapshotted
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.WrapCommits``1(System.Collections.Generic.IList{``0})">
            <summary>
            Wraps each <seealso cref="T:Lucene.Net.Index.IndexCommit"/> as a {@link
             SnapshotCommitPoint}.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint">
            <summary>
            Wraps a provided <seealso cref="T:Lucene.Net.Index.IndexCommit"/> and prevents it
             from being deleted.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint.m_cp">
            <summary>
            The <seealso cref="T:Lucene.Net.Index.IndexCommit"/> we are preventing from deletion. </summary>
        </member>
        <member name="M:Lucene.Net.Index.SnapshotDeletionPolicy.SnapshotCommitPoint.#ctor(Lucene.Net.Index.SnapshotDeletionPolicy,Lucene.Net.Index.IndexCommit)">
            <summary>
            Creates a {@code SnapshotCommitPoint} wrapping the provided
             <seealso cref="T:Lucene.Net.Index.IndexCommit"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SortedDocValues" -->
        <member name="M:Lucene.Net.Index.SortedDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.GetOrd(System.Int32)">
            <summary>
            Returns the ordinal for the specified docID. </summary>
            <param name="docID"> document ID to lookup </param>
            <returns> ordinal for the document: this is dense, starts at 0, then
                    increments by 1 for the next value in sorted order. Note that
                    missing values are indicated by -1. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SortedDocValues.LookupOrd(System.Int32,Lucene.Net.Util.BytesRef)" -->
        <member name="P:Lucene.Net.Index.SortedDocValues.ValueCount">
            <summary>
            Returns the number of unique values. </summary>
            <returns> number of unique values in this SortedDocValues. this is
                    also equivalent to one plus the maximum ordinal. </returns>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.LookupTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            If {@code key} exists, returns its ordinal, else
             returns {@code -insertionPoint-1}, like {@code
             Arrays.binarySearch}.
            </summary>
             <param name="key"> Key to look up
             </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValues.GetTermsEnum">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> over the values.
            The enum supports <seealso cref="!:TermsEnum#ord()"/> and <seealso cref="!:TermsEnum#seekExact(long)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedDocValuesTermsEnum">
            <summary>
            Implements a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> wrapping a provided
            <seealso cref="T:Lucene.Net.Index.SortedDocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedDocValuesTermsEnum.#ctor(Lucene.Net.Index.SortedDocValues)">
            <summary>
            Creates a new TermsEnum over the provided values </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedDocValuesWriter">
            <summary>
            Buffers up pending byte[] per doc, deref and sorting via
             int ord, then flushes when segment flushes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.SortedSetDocValues" -->
        <member name="M:Lucene.Net.Index.SortedSetDocValues.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.SortedSetDocValues.NO_MORE_ORDS">
            <summary>
            When returned by <seealso cref="!:#nextOrd()"/> it means there are no more
            ordinals for the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.NextOrd">
            <summary>
            Returns the next ordinal for the current document (previously
            set by <seealso cref="!:#setDocument(int)"/>. </summary>
            <returns> next ordinal for the document, or <seealso cref="!:#NO_MORE_ORDS"/>.
                    ordinals are dense, start at 0, then increment by 1 for
                    the next value in sorted order.  </returns>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.SetDocument(System.Int32)">
            <summary>
            Sets iteration to the specified docID </summary>
            <param name="docID"> document ID  </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.SortedSetDocValues.LookupOrd(System.Int64,Lucene.Net.Util.BytesRef)" -->
        <member name="P:Lucene.Net.Index.SortedSetDocValues.ValueCount">
            <summary>
            Returns the number of unique values. </summary>
            <returns> number of unique values in this SortedDocValues. this is
                    also equivalent to one plus the maximum ordinal. </returns>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.LookupTerm(Lucene.Net.Util.BytesRef)">
            <summary>
            If {@code key} exists, returns its ordinal, else
             returns {@code -insertionPoint-1}, like {@code
             Arrays.binarySearch}.
            </summary>
             <param name="key"> Key to look up
             </param>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValues.GetTermsEnum">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> over the values.
            The enum supports <seealso cref="!:TermsEnum#ord()"/> and <seealso cref="!:TermsEnum#seekExact(long)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedSetDocValuesTermsEnum">
            <summary>
            Implements a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> wrapping a provided
            <seealso cref="T:Lucene.Net.Index.SortedSetDocValues"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.SortedSetDocValuesTermsEnum.#ctor(Lucene.Net.Index.SortedSetDocValues)">
            <summary>
            Creates a new TermsEnum over the provided values </summary>
        </member>
        <member name="T:Lucene.Net.Index.SortedSetDocValuesWriter">
            <summary>
            Buffers up pending byte[]s per doc, deref and sorting via
             int ord, then flushes when segment flushes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Index.AtomicReader[],Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfos,System.Int32,System.Boolean)">
            <summary>
            called only from static open() methods </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.IndexCommit,System.Int32)">
            <summary>
            called from DirectoryReader.open(...) methods </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.SegmentInfos,System.Boolean)">
            <summary>
            Used by near real-time search </summary>
        </member>
        <member name="M:Lucene.Net.Index.StandardDirectoryReader.Open(Lucene.Net.Store.Directory,Lucene.Net.Index.SegmentInfos,System.Collections.Generic.IList{Lucene.Net.Index.AtomicReader},System.Int32)">
            <summary>
            this constructor is only used for <seealso cref="!:#doOpenIfChanged(SegmentInfos)"/> </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldsProcessor">
            <summary>
            this is a StoredFieldsConsumer that writes stored fields. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldsProcessor.Fill(System.Int32)">
            <summary>
            Fills in any hole in the docIDs </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.StoredFieldVisitor" -->
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.BinaryField(Lucene.Net.Index.FieldInfo,System.Byte[])">
            <summary>
            Process a binary field. </summary>
            <param name="value"> newly allocated byte array with the binary contents.  </param>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.StringField(Lucene.Net.Index.FieldInfo,System.String)">
            <summary>
            Process a string field </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.Int32Field(Lucene.Net.Index.FieldInfo,System.Int32)">
            <summary>
            Process a int numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.Int64Field(Lucene.Net.Index.FieldInfo,System.Int64)">
            <summary>
            Process a long numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.SingleField(Lucene.Net.Index.FieldInfo,System.Single)">
            <summary>
            Process a float numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.DoubleField(Lucene.Net.Index.FieldInfo,System.Double)">
            <summary>
            Process a double numeric field. </summary>
        </member>
        <member name="M:Lucene.Net.Index.StoredFieldVisitor.NeedsField(Lucene.Net.Index.FieldInfo)">
            <summary>
            Hook before processing a field.
            Before a field is processed, this method is invoked so that
            subclasses can return a <seealso cref="T:Lucene.Net.Index.StoredFieldVisitor.Status"/> representing whether
            they need that particular field or not, or to stop processing
            entirely.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.StoredFieldVisitor.Status">
            <summary>
            Enumeration of possible return values for <seealso cref="!:#needsField"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.YES">
            <summary>
            YES: the field should be visited. </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.NO">
            <summary>
            NO: don't visit this field, but continue processing fields for this document. </summary>
        </member>
        <member name="F:Lucene.Net.Index.StoredFieldVisitor.Status.STOP">
            <summary>
            STOP: don't visit this field and stop processing any other fields for this document. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TaskMergeScheduler">
            <summary>
             A <seealso cref="T:Lucene.Net.Index.MergeScheduler"/> that runs each merge using
             Tasks on the default TaskScheduler.
            
             <p>If more than <seealso cref="!:#GetMaxMergeCount"/> merges are
             requested then this class will forcefully throttle the
             incoming threads by pausing until one more more merges
             complete.</p>
             
            LUCENENET specific
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._mergeThreads">
            <summary>
            List of currently active <seealso cref="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread"/>s.</summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._mergeThreadCount">
            <summary>
            How many <seealso cref="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread"/>s have kicked off (this is use
             to name them).
            </summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._directory">
            <summary>
            <seealso cref="T:Lucene.Net.Store.Directory"/> that holds the index. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TaskMergeScheduler._writer">
            <summary>
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/> that owns this instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.#ctor">
            <summary>
            Sole constructor, with all settings set to default
             values.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.SetMaxMergesAndThreads(System.Int32,System.Int32)">
            <summary>
            Sets the maximum number of merge threads and simultaneous merges allowed.
            </summary>
            <param name="maxMergeCount"> the max # simultaneous merges that are allowed.
                  If a merge is necessary yet we already have this many
                  threads running, the incoming thread (that is calling
                  add/updateDocument) will block until a merge thread
                  has completed.  Note that we will only run the
                  smallest <code>maxThreadCount</code> merges at a time. </param>
            <param name="maxThreadCount"> the max # simultaneous merge threads that should
                  be running at once.  this must be &lt;= <code>maxMergeCount</code> </param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.TaskMergeScheduler.MaxThreadCount" -->
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MaxMergeCount">
            <summary>
            Max number of merges we accept before forcefully
            throttling the incoming threads
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThreadPriority">
            <summary>
            Return the priority that merge threads run at. This is always the same.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.SetMergeThreadPriority(System.Int32)">
            <summary>
            This method has no effect in <see cref="T:Lucene.Net.Index.TaskMergeScheduler"/> because the
            <see cref="P:Lucene.Net.Index.TaskMergeScheduler.MergeThreadPriority"/> returns a constant value.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TaskMergeScheduler.UpdateMergeThreads" -->
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.Verbose">
             <summary>
             Returns true if verbosing is enabled. this method is usually used in
             conjunction with <seealso cref="!:#message(String)"/>, like that:
            
             <pre class="prettyprint">
             if (verbose()) {
               message(&quot;your message&quot;);
             }
             </pre>
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.Message(System.String)">
            <summary>
            Outputs the given message - this method assumes <seealso cref="!:#verbose()"/> was
            called and returned true.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.Sync">
            <summary>
            Wait for any running merge threads to finish. 
            This call is not interruptible as used by <seealso cref="!:#Dispose()"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThreadCount">
            <summary>
            Returns the number of merge threads that are alive. Note that this number
            is &lt;= <seealso cref="!:#mergeThreads"/> size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.CreateTask(Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge)">
            <summary>
            Create and return a new MergeThread </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.HandleMergeException(System.Exception)">
            <summary>
            Called when an exception is hit in a background merge
             thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.SetSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.ClearSuppressExceptions">
            <summary>
            Used for testing </summary>
        </member>
        <member name="T:Lucene.Net.Index.TaskMergeScheduler.MergeThread">
            <summary>
            Runs a merge thread, which may run one or more merges
             in sequence.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TaskMergeScheduler.MergeThread.#ctor(System.String,Lucene.Net.Index.IndexWriter,Lucene.Net.Index.MergePolicy.OneMerge,Lucene.Net.Util.InfoStream,System.Boolean,System.Threading.ManualResetEventSlim,System.Action{System.Exception})">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThread.RunningMerge">
            <summary>
            Record the currently running merge. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TaskMergeScheduler.MergeThread.CurrentMerge">
            <summary>
            Return the current merge, or null if this {@code
             MergeThread} is done.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Term">
             <summary>
              A Term represents a word from text.  this is the unit of search.  It is
              composed of two elements, the text of the word, as a string, and the name of
              the field that the text occurred in.
            
              Note that terms may represent more than words from text fields, but also
              things like dates, email addresses, urls, etc.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.#ctor(System.String,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.#ctor(System.String,System.String)" -->
        <member name="M:Lucene.Net.Index.Term.#ctor(System.String)">
            <summary>
            Constructs a Term with the given field and empty text.
            this serves two purposes: 1) reuse of a Term with the same field.
            2) pattern for a query.
            </summary>
            <param name="fld"> field's name </param>
        </member>
        <member name="P:Lucene.Net.Index.Term.Field">
            <summary>
            Returns the field of this term.   The field indicates
             the part of a document which this term came from.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.Text">
            <summary>
            Returns the text of this term.  In the case of words, this is simply the
             text of the word.  In the case of dates and other types, this is an
             encoding of the object as a string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.ToString(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns human-readable form of the term text. If the term is not unicode,
            the raw bytes will be printed instead.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Term.Bytes">
            <summary>
            Returns the bytes of this term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Term.CompareTo(Lucene.Net.Index.Term)">
             <summary>
             Compares two terms, returning a negative integer if this
              term belongs before the argument, zero if this term is equal to the
              argument, and a positive integer if this term belongs after the argument.
            
              The ordering of terms is first by field, then by text.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.Term.Set(System.String,Lucene.Net.Util.BytesRef)" -->
        <member name="T:Lucene.Net.Index.TermContext">
             <summary>
             Maintains a <seealso cref="T:Lucene.Net.Index.IndexReader"/> <seealso cref="T:Lucene.Net.Index.TermState"/> view over
             <seealso cref="T:Lucene.Net.Index.IndexReader"/> instances containing a single term. The
             <seealso cref="T:Lucene.Net.Index.TermContext"/> doesn't track if the given <seealso cref="T:Lucene.Net.Index.TermState"/>
             objects are valid, neither if the <seealso cref="T:Lucene.Net.Index.TermState"/> instances refer to the
             same terms in the associated readers.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermContext.TopReaderContext">
             <summary>
             Holds the <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/> of the top-level
              <seealso cref="T:Lucene.Net.Index.IndexReader"/>, used internally only for
              asserting.
            
              @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.#ctor(Lucene.Net.Index.IndexReaderContext)">
            <summary>
            Creates an empty <seealso cref="T:Lucene.Net.Index.TermContext"/> from a <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.#ctor(Lucene.Net.Index.IndexReaderContext,Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Index.TermContext"/> with an initial <seealso cref="T:Lucene.Net.Index.TermState"/>,
            <seealso cref="T:Lucene.Net.Index.IndexReader"/> pair.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermContext.Build(Lucene.Net.Index.IndexReaderContext,Lucene.Net.Index.Term)" -->
        <member name="M:Lucene.Net.Index.TermContext.Clear">
            <summary>
            Clears the <seealso cref="T:Lucene.Net.Index.TermContext"/> internal state and removes all
            registered <seealso cref="T:Lucene.Net.Index.TermState"/>s
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Register(Lucene.Net.Index.TermState,System.Int32,System.Int32,System.Int64)">
            <summary>
            Registers and associates a <seealso cref="T:Lucene.Net.Index.TermState"/> with an leaf ordinal. The leaf ordinal
            should be derived from a <seealso cref="T:Lucene.Net.Index.IndexReaderContext"/>'s leaf ord.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermContext.Get(System.Int32)">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Index.TermState"/> for an leaf ordinal or <code>null</code> if no
            <seealso cref="T:Lucene.Net.Index.TermState"/> for the ordinal was registered.
            </summary>
            <param name="ord">
                     the readers leaf ordinal to get the <seealso cref="T:Lucene.Net.Index.TermState"/> for. </param>
            <returns> the <seealso cref="T:Lucene.Net.Index.TermState"/> for the given readers ord or <code>null</code> if no
                    <seealso cref="T:Lucene.Net.Index.TermState"/> for the reader was registered </returns>
        </member>
        <member name="P:Lucene.Net.Index.TermContext.TotalTermFreq">
            <summary>
             Returns the accumulated term frequency of all <seealso cref="T:Lucene.Net.Index.TermState"/>
                    instances passed to <seealso cref="!:#register(TermState, int, int, long)"/>. </summary>
            <returns> the accumulated term frequency of all <seealso cref="T:Lucene.Net.Index.TermState"/>
                    instances passed to <seealso cref="!:#register(TermState, int, int, long)"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Index.TermContext.DocFreq">
            <summary>
            expert: only available for queries that want to lie about docfreq
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.Terms">
            <summary>
            Access to the terms in a specific field.  See <seealso cref="T:Lucene.Net.Index.Fields"/>.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.GetIterator(Lucene.Net.Index.TermsEnum)">
            <summary>
            Returns an iterator that will step through all
             terms. this method will not return null.  If you have
             a previous TermsEnum, for example from a different
             field, you can pass it for possible reuse if the
             implementation can do so.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.Terms.Intersect(Lucene.Net.Util.Automaton.CompiledAutomaton,Lucene.Net.Util.BytesRef)">
             <summary>
             Returns a TermsEnum that iterates over all terms that
              are accepted by the provided {@link
              CompiledAutomaton}.  If the <code>startTerm</code> is
              provided then the returned enum will only accept terms
              > <code>startTerm</code>, but you still must call
              next() first to get to the first term.  Note that the
              provided <code>startTerm</code> must be accepted by
              the automaton.
            
             <p><b>NOTE</b>: the returned TermsEnum cannot
             seek</p>.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Index.Terms.Comparer" -->
        <member name="P:Lucene.Net.Index.Terms.Count">
            <summary>
            Returns the number of terms for this field, or -1 if this
            measure isn't stored by the codec. Note that, just like
            other term measures, this measure does not take deleted
            documents into account.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.SumTotalTermFreq">
            <summary>
            Returns the sum of <seealso cref="!:TermsEnum#totalTermFreq"/> for
             all terms in this field, or -1 if this measure isn't
             stored by the codec (or if this fields omits term freq
             and positions).  Note that, just like other term
             measures, this measure does not take deleted documents
             into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.SumDocFreq">
            <summary>
            Returns the sum of <seealso cref="!:TermsEnum#docFreq()"/> for
             all terms in this field, or -1 if this measure isn't
             stored by the codec.  Note that, just like other term
             measures, this measure does not take deleted documents
             into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.DocCount">
            <summary>
            Returns the number of documents that have at least one
             term for this field, or -1 if this measure isn't
             stored by the codec.  Note that, just like other term
             measures, this measure does not take deleted documents
             into account.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasFreqs">
            <summary>
            Returns true if documents in this field store
             per-document term frequency (<seealso cref="!:DocsEnum#freq"/>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasOffsets">
            <summary>
            Returns true if documents in this field store offsets. </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasPositions">
            <summary>
            Returns true if documents in this field store positions. </summary>
        </member>
        <member name="P:Lucene.Net.Index.Terms.HasPayloads">
            <summary>
            Returns true if documents in this field store payloads. </summary>
        </member>
        <member name="F:Lucene.Net.Index.Terms.EMPTY_ARRAY">
            <summary>
            Zero-length array of <seealso cref="T:Lucene.Net.Index.Terms"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsEnum">
             <summary>
             Iterator to seek (<see cref="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)"/>, 
             <see cref="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef)"/>) or step through 
             (<see cref="M:Lucene.Net.Index.TermsEnum.Next"/> terms to obtain frequency information 
             (<see cref="P:Lucene.Net.Index.TermsEnum.DocFreq"/>), <see cref="T:Lucene.Net.Index.DocsEnum"/> or 
             <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the current term 
             (<see cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)"/>).
            
             <para/>Term enumerations are always ordered by
             <see cref="P:Lucene.Net.Index.TermsEnum.Comparer"/>.  Each term in the enumeration is
             greater than the one before it.
            
             <para/>The <see cref="T:Lucene.Net.Index.TermsEnum"/> is unpositioned when you first obtain it
             and you must first successfully call <see cref="M:Lucene.Net.Index.TermsEnum.Next"/> or one
             of the <c>Seek</c> methods.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.Attributes">
            <summary>
            Returns the related attributes. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsEnum.SeekStatus">
            <summary>
            Represents returned result from <see cref="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.END">
            <summary>
            The term was not found, and the end of iteration was hit. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.FOUND">
            <summary>
            The precise term was found. </summary>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.SeekStatus.NOT_FOUND">
            <summary>
            A different term was found after the requested term </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            Attempts to seek to the exact term, returning
            true if the term is found.  If this returns false, the
            enum is unpositioned.  For some codecs, <see cref="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef)"/> may
            be substantially faster than <see cref="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to the specified term, if it exists, or to the
            next (ceiling) term.  Returns <see cref="T:Lucene.Net.Index.TermsEnum.SeekStatus"/> to
            indicate whether exact term was found, a different
            term was found, or EOF was hit.  The target term may
            be before or after the current term.  If this returns
            <see cref="F:Lucene.Net.Index.TermsEnum.SeekStatus.END"/>, the enum is unpositioned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(System.Int64)">
            <summary>
            Seeks to the specified term by ordinal (position) as
            previously returned by <see cref="P:Lucene.Net.Index.TermsEnum.Ord"/>. The target <paramref name="ord"/>
            may be before or after the current ord, and must be
            within bounds.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)">
            <summary>
            Expert: Seeks a specific position by <see cref="T:Lucene.Net.Index.TermState"/> previously obtained
            from <see cref="M:Lucene.Net.Index.TermsEnum.GetTermState"/>. Callers should maintain the <see cref="T:Lucene.Net.Index.TermState"/> to
            use this method. Low-level implementations may position the <see cref="T:Lucene.Net.Index.TermsEnum"/>
            without re-seeking the term dictionary.
            <para/>
            Seeking by <see cref="T:Lucene.Net.Index.TermState"/> should only be used iff the state was obtained
            from the same <see cref="T:Lucene.Net.Index.TermsEnum"/> instance.
            <para/>
            NOTE: Using this method with an incompatible <see cref="T:Lucene.Net.Index.TermState"/> might leave
            this <see cref="T:Lucene.Net.Index.TermsEnum"/> in undefined state. On a segment level
            <see cref="T:Lucene.Net.Index.TermState"/> instances are compatible only iff the source and the
            target <see cref="T:Lucene.Net.Index.TermsEnum"/> operate on the same field. If operating on segment
            level, TermState instances must not be used across segments.
            <para/>
            NOTE: A seek by <see cref="T:Lucene.Net.Index.TermState"/> might not restore the
            <see cref="T:Lucene.Net.Util.AttributeSource"/>'s state. <see cref="T:Lucene.Net.Util.AttributeSource"/> states must be
            maintained separately if this method is used. </summary>
            <param name="term"> the term the <see cref="T:Lucene.Net.Index.TermState"/> corresponds to </param>
            <param name="state"> the <see cref="T:Lucene.Net.Index.TermState"/> </param>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.Term">
            <summary>
            Returns current term. Do not call this when the enum
            is unpositioned.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.Ord">
            <summary>
            Returns ordinal position for current term.  this is an
            optional method (the codec may throw <see cref="T:System.NotSupportedException"/>.
            Do not call this when the enum is unpositioned.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.DocFreq">
            <summary>
            Returns the number of documents containing the current
            term.  Do not call this when the enum is unpositioned.
            </summary>
            <seealso cref="F:Lucene.Net.Index.TermsEnum.SeekStatus.END"/>
        </member>
        <member name="P:Lucene.Net.Index.TermsEnum.TotalTermFreq">
            <summary>
            Returns the total number of occurrences of this term
             across all documents (the sum of the freq() for each
             doc that has this term).  this will be -1 if the
             codec doesn't support this measure.  Note that, like
             other term measures, this measure does not take
             deleted documents into account.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)">
            <summary>
            Get <see cref="T:Lucene.Net.Index.DocsEnum"/> for the current term. Do not
            call this when the enum is unpositioned. This method
            will not return null.
            </summary>
            <param name="liveDocs"> unset bits are documents that should not
            be returned </param>
            <param name="reuse"> pass a prior <see cref="T:Lucene.Net.Index.DocsEnum"/> for possible reuse  </param>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum,Lucene.Net.Index.DocsFlags)">
            <summary>
            Get <see cref="T:Lucene.Net.Index.DocsEnum"/> for the current term, with
            control over whether freqs are required. Do not
            call this when the enum is unpositioned. This method
            will not return null.
            </summary>
            <param name="liveDocs"> unset bits are documents that should not
            be returned </param>
            <param name="reuse"> pass a prior DocsEnum for possible reuse </param>
            <param name="flags"> specifies which optional per-document values
                   you require; <see cref="T:Lucene.Net.Index.DocsFlags"/></param>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.Docs(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsEnum)"/>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum)" -->
        <member name="M:Lucene.Net.Index.TermsEnum.DocsAndPositions(Lucene.Net.Util.IBits,Lucene.Net.Index.DocsAndPositionsEnum,Lucene.Net.Index.DocsAndPositionsFlags)">
            <summary>
            Get <see cref="T:Lucene.Net.Index.DocsAndPositionsEnum"/> for the current term,
            with control over whether offsets and payloads are
            required.  Some codecs may be able to optimize their
            implementation when offsets and/or payloads are not required.
            Do not call this when the enum is unpositioned. This
            will return null if positions were not indexed.
            </summary>
            <param name="liveDocs"> unset bits are documents that should not
            be returned </param>
            <param name="reuse"> pass a prior DocsAndPositionsEnum for possible reuse </param>
            <param name="flags"> specifies which optional per-position values you
                    require; see <see cref="T:Lucene.Net.Index.DocsAndPositionsFlags"/>. </param>
        </member>
        <member name="M:Lucene.Net.Index.TermsEnum.GetTermState">
            <summary>
            Expert: Returns the TermsEnums internal state to position the <see cref="T:Lucene.Net.Index.TermsEnum"/>
            without re-seeking the term dictionary.
            <para/>
            NOTE: A seek by <see cref="M:Lucene.Net.Index.TermsEnum.GetTermState"/> might not capture the
            <see cref="T:Lucene.Net.Util.AttributeSource"/>'s state. Callers must maintain the
            <see cref="T:Lucene.Net.Util.AttributeSource"/> states separately
            </summary>
            <seealso cref="T:Lucene.Net.Index.TermState"/>
            <seealso cref="M:Lucene.Net.Index.TermsEnum.SeekExact(Lucene.Net.Util.BytesRef,Lucene.Net.Index.TermState)"/>
        </member>
        <member name="F:Lucene.Net.Index.TermsEnum.EMPTY">
            <summary>
            An empty <see cref="T:Lucene.Net.Index.TermsEnum"/> for quickly returning an empty instance e.g.
            in <see cref="T:Lucene.Net.Search.MultiTermQuery"/>
            <para/><em>Please note:</em> this enum should be unmodifiable,
            but it is currently possible to add Attributes to it.
            this should not be a problem, as the enum is always empty and
            the existence of unused Attributes does not matter.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TermsHash">
            <summary>
            this class implements <seealso cref="T:Lucene.Net.Index.InvertedDocConsumer"/>, which
             is passed each token produced by the analyzer on each
             field.  It stores these tokens in a hash table, and
             allocates separate byte streams per token.  Consumers of
             this class, eg <seealso cref="T:Lucene.Net.Index.FreqProxTermsWriter"/> and {@link
             TermVectorsConsumer}, write their own byte streams
             under each term.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermsHashConsumerPerField" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TermsHashPerField.SortPostings(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})" -->
        <member name="M:Lucene.Net.Index.TermsHashPerField.WriteVInt32(System.Int32,System.Int32)">
            <summary>
            NOTE: This was writeVInt() in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TermState" -->
        <member name="M:Lucene.Net.Index.TermState.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
             constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermState.CopyFrom(Lucene.Net.Index.TermState)">
            <summary>
            Copies the content of the given <seealso cref="T:Lucene.Net.Index.TermState"/> to this instance
            </summary>
            <param name="other">
                     the TermState to copy </param>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsConsumer.Fill(System.Int32)">
            <summary>
            Fills in no-term-vectors for all docs we haven't seen
             since the last doc that had term vectors.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TermVectorsConsumerPerField.Finish">
            <summary>
            Called once per field per document if term vectors
             are enabled, to write the vectors to
             RAMOutputStream, which is then quickly flushed to
             the real term vectors files in the Directory. 	  /// </summary>
        </member>
        <member name="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool">
            <summary>
            A <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool"/> implementation that tries to assign an
            indexing thread to the same <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> each time the thread tries to
            obtain a <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>. Once a new <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is created it is
            associated with the creating thread. Subsequently, if the threads associated
            <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is not in use it will be associated with the requesting
            thread. Otherwise, if the <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/> is used by another thread
            <seealso cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> tries to find the currently
            minimal contended <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool.#ctor(System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Index.ThreadAffinityDocumentsWriterThreadPool"/> with a given maximum of <seealso cref="T:Lucene.Net.Index.DocumentsWriterPerThreadPool.ThreadState"/>s.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TieredMergePolicy">
             <summary>
             Merges segments of approximately equal size, subject to
             an allowed number of segments per tier.  This is similar
             to <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>, except this merge
             policy is able to merge non-adjacent segment, and
             separates how many segments are merged at once (<see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnce"/>) 
             from how many segments are allowed
             per tier (<see cref="P:Lucene.Net.Index.TieredMergePolicy.SegmentsPerTier"/>).  This merge
             policy also does not over-merge (i.e. cascade merges).
            
             <para/>For normal merging, this policy first computes a
             "budget" of how many segments are allowed to be in the
             index.  If the index is over-budget, then the policy
             sorts segments by decreasing size (pro-rating by percent
             deletes), and then finds the least-cost merge.  Merge
             cost is measured by a combination of the "skew" of the
             merge (size of largest segment divided by smallest segment),
             total merge size and percent deletes reclaimed,
             so that merges with lower skew, smaller size
             and those reclaiming more deletes, are
             favored.
            
             <para/>If a merge will produce a segment that's larger than
             <see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergedSegmentMB"/>, then the policy will
             merge fewer segments (down to 1 at once, if that one has
             deletions) to keep the segment size under budget.
            
             <para/><b>NOTE</b>: This policy freely merges non-adjacent
             segments; if this is a problem, use <see cref="T:Lucene.Net.Index.LogMergePolicy"/>.
            
             <para/><b>NOTE</b>: This policy always merges by byte size
             of the segments, always pro-rates by percent deletes,
             and does not apply any maximum segment size during
             forceMerge (unlike <see cref="T:Lucene.Net.Index.LogByteSizeMergePolicy"/>).
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Index.TieredMergePolicy.DEFAULT_NO_CFS_RATIO">
            <summary>
            Default noCFSRatio.  If a merge's size is >= 10% of
            the index, then we disable compound file for it.
            </summary>
            <seealso cref="P:Lucene.Net.Index.MergePolicy.NoCFSRatio"/>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.#ctor">
            <summary>
            Sole constructor, setting all settings to their
            defaults.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnce">
            <summary>
            Gets or sets maximum number of segments to be merged at a time
            during "normal" merging.  For explicit merging (eg,
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> or 
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/> was called), see 
            <see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnceExplicit"/>.  Default is 10.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnceExplicit">
            <summary>
            Gets or sets maximum number of segments to be merged at a time,
            during <see cref="M:Lucene.Net.Index.IndexWriter.ForceMerge(System.Int32)"/> or 
            <see cref="M:Lucene.Net.Index.IndexWriter.ForceMergeDeletes"/>. Default is 30.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MaxMergedSegmentMB">
            <summary>
            Gets or sets maximum sized segment to produce during
            normal merging.  This setting is approximate: the
            estimate of the merged segment size is made by summing
            sizes of to-be-merged segments (compensating for
            percent deleted docs).  Default is 5 GB.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.ReclaimDeletesWeight">
            <summary>
            Controls how aggressively merges that reclaim more
            deletions are favored.  Higher values will more
            aggressively target merges that reclaim deletions, but
            be careful not to go so high that way too much merging
            takes place; a value of 3.0 is probably nearly too
            high.  A value of 0.0 means deletions don't impact
            merge selection.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.FloorSegmentMB">
            <summary>
            Segments smaller than this are "rounded up" to this
            size, ie treated as equal (floor) size for merge
            selection.  this is to prevent frequent flushing of
            tiny segments from allowing a long tail in the index.
            Default is 2 MB.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.ForceMergeDeletesPctAllowed">
            <summary>
            When forceMergeDeletes is called, we only merge away a
            segment if its delete percentage is over this
            threshold.  Default is 10%.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.SegmentsPerTier">
            <summary>
            Gets or sets the allowed number of segments per tier.  Smaller
            values mean more merging but fewer segments.
            
            <para/><b>NOTE</b>: this value should be >= the 
            <see cref="P:Lucene.Net.Index.TieredMergePolicy.MaxMergeAtOnce"/> otherwise you'll force too much
            merging to occur.
            
            <para/>Default is 10.0.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.TieredMergePolicy.MergeScore">
            <summary>
            Holds score and explanation for a single candidate
            merge.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.MergeScore.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MergeScore.Score">
            <summary>
            Returns the score for this merge candidate; lower
            scores are better.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TieredMergePolicy.MergeScore.Explanation">
            <summary>
            Human readable explanation of how the merge got this
            score.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TieredMergePolicy.Score(System.Collections.Generic.IList{Lucene.Net.Index.SegmentCommitInfo},System.Boolean,System.Int64)">
            <summary>
            Expert: scores one merge; subclasses can override. </summary>
        </member>
        <member name="T:Lucene.Net.Index.TrackingIndexWriter">
             <summary>
             Class that tracks changes to a delegated
              IndexWriter, used by {@link
              ControlledRealTimeReopenThread} to ensure specific
              changes are visible.   Create this class (passing your
              IndexWriter), and then pass this class to {@link
              ControlledRealTimeReopenThread}.
              Be sure to make all changes via the
              TrackingIndexWriter, otherwise {@link
              ControlledRealTimeReopenThread} won't know about the changes.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.#ctor(Lucene.Net.Index.IndexWriter)">
            <summary>
            Create a {@code TrackingIndexWriter} wrapping the
             provided <seealso cref="P:Lucene.Net.Index.TrackingIndexWriter.IndexWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#updateDocument(Term,Iterable,Analyzer)}
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocument(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
            <summary>
            Calls {@link
             IndexWriter#updateDocument(Term,Iterable)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#updateDocuments(Term,Iterable,Analyzer)}
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.UpdateDocuments(Lucene.Net.Index.Term,System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
            <summary>
            Calls {@link
             IndexWriter#updateDocuments(Term,Iterable)} and returns
             the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Index.Term)">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Term)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Index.Term[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Term...)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Search.Query)">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Query)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteDocuments(Lucene.Net.Search.Query[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteDocuments(Query...)"/>
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.DeleteAll">
            <summary>
            Calls <seealso cref="!:IndexWriter#deleteAll"/> and returns the
             generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#addDocument(Iterable,Analyzer)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}},Lucene.Net.Analysis.Analyzer)">
            <summary>
            Calls {@link
             IndexWriter#addDocuments(Iterable,Analyzer)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocument(System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField})">
            <summary>
            Calls <seealso cref="!:IndexWriter#addDocument(Iterable)"/>
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddDocuments(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{Lucene.Net.Index.IIndexableField}})">
            <summary>
            Calls <seealso cref="!:IndexWriter#addDocuments(Iterable)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddIndexes(Lucene.Net.Store.Directory[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#addIndexes(Directory...)"/> and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.AddIndexes(Lucene.Net.Index.IndexReader[])">
            <summary>
            Calls <seealso cref="!:IndexWriter#addIndexes(IndexReader...)"/>
             and returns the generation that reflects this change.
            </summary>
        </member>
        <member name="P:Lucene.Net.Index.TrackingIndexWriter.Generation">
            <summary>
            Return the current generation being indexed. </summary>
        </member>
        <member name="P:Lucene.Net.Index.TrackingIndexWriter.IndexWriter">
            <summary>
            Return the wrapped <seealso cref="P:Lucene.Net.Index.TrackingIndexWriter.IndexWriter"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.GetAndIncrementGeneration">
             <summary>
             Return and increment current gen.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.TrackingIndexWriter.TryDeleteDocument(Lucene.Net.Index.IndexReader,System.Int32)">
            <summary>
            Cals {@link
             IndexWriter#tryDeleteDocument(IndexReader,int)} and
             returns the generation that reflects this change.
            </summary>
        </member>
        <member name="T:Lucene.Net.Index.ITwoPhaseCommit">
             <summary>
             An interface for implementations that support 2-phase commit. You can use
             <seealso cref="T:Lucene.Net.Index.TwoPhaseCommitTool"/> to execute a 2-phase commit algorithm over several
             <seealso cref="T:Lucene.Net.Index.ITwoPhaseCommit"/>s.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Index.ITwoPhaseCommit.PrepareCommit">
            <summary>
            The first stage of a 2-phase commit. Implementations should do as much work
            as possible in this method, but avoid actual committing changes. If the
            2-phase commit fails, <seealso cref="!:#rollback()"/> is called to discard all changes
            since last successful commit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ITwoPhaseCommit.Commit">
            <summary>
            The second phase of a 2-phase commit. Implementations should ideally do
            very little work in this method (following <seealso cref="!:#prepareCommit()"/>, and
            after it returns, the caller can assume that the changes were successfully
            committed to the underlying storage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.ITwoPhaseCommit.Rollback">
            <summary>
            Discards any changes that have occurred since the last commit. In a 2-phase
            commit algorithm, where one of the objects failed to <seealso cref="!:#commit()"/> or
            <seealso cref="!:#prepareCommit()"/>, this method is used to roll all other objects
            back to their previous state.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.TwoPhaseCommitTool" -->
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.#ctor">
            <summary>
            No instance </summary>
        </member>
        <member name="T:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException">
            <summary>
            Thrown by <seealso cref="!:TwoPhaseCommitTool#execute(TwoPhaseCommit...)"/> when an
            object fails to prepareCommit().
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException.#ctor(System.Exception,Lucene.Net.Index.ITwoPhaseCommit)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.PrepareCommitFailException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException">
            <summary>
            Thrown by <seealso cref="!:TwoPhaseCommitTool#execute(TwoPhaseCommit...)"/> when an
            object fails to commit().
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException.#ctor(System.Exception,Lucene.Net.Index.ITwoPhaseCommit)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.CommitFailException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Lucene.Net.Index.TwoPhaseCommitTool.Rollback(Lucene.Net.Index.ITwoPhaseCommit[])">
            <summary>
            rollback all objects, discarding any exceptions that occur. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Index.TwoPhaseCommitTool.Execute(Lucene.Net.Index.ITwoPhaseCommit[])" -->
        <member name="T:Lucene.Net.Index.TwoStoredFieldsConsumers">
            <summary>
            Just switches between two <seealso cref="T:Lucene.Net.Index.DocFieldConsumer"/>s. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Index.UpgradeIndexMergePolicy" -->
        <member name="F:Lucene.Net.Index.UpgradeIndexMergePolicy.m_base">
            <summary>
            Wrapped <seealso cref="T:Lucene.Net.Index.MergePolicy"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Index.UpgradeIndexMergePolicy.#ctor(Lucene.Net.Index.MergePolicy)">
            <summary>
            Wrap the given <seealso cref="T:Lucene.Net.Index.MergePolicy"/> and intercept forceMerge requests to
            only upgrade segments written with previous Lucene versions.
            </summary>
        </member>
        <member name="M:Lucene.Net.Index.UpgradeIndexMergePolicy.ShouldUpgradeSegment(Lucene.Net.Index.SegmentCommitInfo)">
            <summary>
            Returns if the given segment should be upgraded. The default implementation
            will return {@code !Constants.LUCENE_MAIN_VERSION.equals(si.getVersion())},
            so all segments created with a different version number than this Lucene version will
            get upgraded.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.AutomatonQuery">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Query"/> that will match terms against a finite-state machine.
            <p>
            this query will match documents that contain terms accepted by a given
            finite-state machine. The automaton can be constructed with the
            <seealso cref="N:Lucene.Net.Util.Automaton"/> API. Alternatively, it can be
            created from a regular expression with <seealso cref="T:Lucene.Net.Search.RegexpQuery"/> or from
            the standard Lucene wildcard syntax with <seealso cref="T:Lucene.Net.Search.WildcardQuery"/>.
            </p>
            <p>
            When the query is executed, it will create an equivalent DFA of the
            finite-state machine, and will enumerate the term dictionary in an
            intelligent way to reduce the number of comparisons. For example: the regular
            expression of <code>[dl]og?</code> will make approximately four comparisons:
            do, dog, lo, and log.
            </p>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.AutomatonQuery.m_automaton">
            <summary>
            the automaton to match index terms against </summary>
        </member>
        <member name="F:Lucene.Net.Search.AutomatonQuery.m_term">
            <summary>
            term containing the field, and possibly some pattern structure </summary>
        </member>
        <member name="M:Lucene.Net.Search.AutomatonQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Create a new AutomatonQuery from an <seealso cref="P:Lucene.Net.Search.AutomatonQuery.Automaton"/>.
            </summary>
            <param name="term"> Term containing field and possibly some pattern structure. The
                   term text is ignored. </param>
            <param name="automaton"> Automaton to run, terms that are accepted are considered a
                   match. </param>
        </member>
        <member name="P:Lucene.Net.Search.AutomatonQuery.Automaton">
            <summary>
            Returns the automaton used to create this query </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BitsFilteredDocIdSet" -->
        <member name="M:Lucene.Net.Search.BitsFilteredDocIdSet.Wrap(Lucene.Net.Search.DocIdSet,Lucene.Net.Util.IBits)">
            <summary>
            Convenience wrapper method: If {@code acceptDocs == null} it returns the original set without wrapping. </summary>
            <param name="set"> Underlying DocIdSet. If {@code null}, this method returns {@code null} </param>
            <param name="acceptDocs"> Allowed docs, all docids not in this set will not be returned by this DocIdSet.
            If {@code null}, this method returns the original set without wrapping. </param>
        </member>
        <member name="M:Lucene.Net.Search.BitsFilteredDocIdSet.#ctor(Lucene.Net.Search.DocIdSet,Lucene.Net.Util.IBits)">
            <summary>
            Constructor. </summary>
            <param name="innerSet"> Underlying DocIdSet </param>
            <param name="acceptDocs"> Allowed docs, all docids not in this set will not be returned by this DocIdSet </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanClause">
            <summary>
            A clause in a BooleanQuery. </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanClause.query">
            <summary>
            The query whose matching documents are combined by the boolean query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Occur)">
            <summary>
            Constructs a BooleanClause.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanClause.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Occur">
            <summary>
            Specifies how clauses are to occur in matching documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Occur.MUST">
            <summary>
            Use this operator for clauses that <i>must</i> appear in the matching documents.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Occur.SHOULD" -->
        <member name="F:Lucene.Net.Search.Occur.MUST_NOT">
            <summary>
            Use this operator for clauses that <i>must not</i> appear in the matching documents.
            Note that it is not possible to search for queries that only consist
            of a <code>MUST_NOT</code> clause.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery">
            <summary>
            A Query that matches documents matching boolean combinations of other
            queries, e.g. <seealso cref="T:Lucene.Net.Search.TermQuery"/>s, <seealso cref="T:Lucene.Net.Search.PhraseQuery"/>s or other
            BooleanQuerys.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException">
            <summary>
            Thrown when an attempt is made to add more than {@link
            #getMaxClauseCount()} clauses. this typically happens if
            a PrefixQuery, FuzzyQuery, WildcardQuery, or TermRangeQuery
            is expanded to many terms during search.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.TooManyClausesException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.BooleanQuery.MaxClauseCount" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor">
            <summary>
            Constructs an empty boolean query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.#ctor(System.Boolean)">
             <summary>
             Constructs an empty boolean query.
            
             <seealso cref="!:Similarity#coord(int,int)"/> may be disabled in scoring, as
             appropriate. For example, this score factor does not make sense for most
             automatically generated queries, like <seealso cref="T:Lucene.Net.Search.WildcardQuery"/> and {@link
             FuzzyQuery}.
             </summary>
             <param name="disableCoord"> disables <seealso cref="!:Similarity#coord(int,int)"/> in scoring. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.BooleanQuery.CoordDisabled" -->
        <member name="P:Lucene.Net.Search.BooleanQuery.MinimumNumberShouldMatch">
             <summary>
             Specifies a minimum number of the optional BooleanClauses
             which must be satisfied.
            
             <p>
             By default no optional clauses are necessary for a match
             (unless there are no required clauses).  If this method is used,
             then the specified number of clauses is required.
             </p>
             <p>
             Use of this method is totally independent of specifying that
             any specific clauses are required (or prohibited).  this number will
             only be compared against the number of matching optional clauses.
             </p>
             </summary>
             <param name="min"> the number of optional clauses that must match </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.Query,Lucene.Net.Search.Occur)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.BooleanQuery.Add(Lucene.Net.Search.BooleanClause)" -->
        <member name="M:Lucene.Net.Search.BooleanQuery.GetClauses">
            <summary>
            Returns the set of clauses in this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.BooleanQuery.Clauses">
            <summary>
            Returns the list of clauses in this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetEnumerator">
            <summary>
            Returns an iterator on the clauses in this query. It implements the <seealso cref="!:Iterable"/> interface to
            make it possible to do:
            <pre class="prettyprint">for (BooleanClause clause : booleanQuery) {}</pre>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanQuery.BooleanWeight">
             <summary>
             Expert: the Weight for BooleanQuery, used to
             normalize, score and explain these queries.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanQuery.BooleanWeight.m_similarity">
            <summary>
            The Similarity implementation. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer.BucketTable">
            <summary>
            A simple hash table of document scores within a range. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.BooleanScorer2" -->
        <member name="F:Lucene.Net.Search.BooleanScorer2.countingSumScorer">
            <summary>
            The scorer to which all scoring will be delegated,
            except for computing and using the coordination factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BooleanScorer2.minNrShouldMatch">
            <summary>
            The number of optionalScorers that need to match (if there are any) </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.#ctor(Lucene.Net.Search.BooleanQuery.BooleanWeight,System.Boolean,System.Int32,System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Int32)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Search.Scorer"/> with the given similarity and lists of required,
            prohibited and optional scorers. In no required scorers are added, at least
            one of the optional scorers will have to match during the search.
            </summary>
            <param name="weight">
                     The BooleanWeight to be used. </param>
            <param name="disableCoord">
                     If this parameter is true, coordination level matching
                     (<seealso cref="!:Similarity#coord(int, int)"/>) is not used. </param>
            <param name="minNrShouldMatch">
                     The minimum number of optional added scorers that should match
                     during the search. In case no required scorers are added, at least
                     one of the optional scorers will have to match during the search. </param>
            <param name="required">
                     the list of required scorers. </param>
            <param name="prohibited">
                     the list of prohibited scorers. </param>
            <param name="optional">
                     the list of optional scorers. </param>
        </member>
        <member name="T:Lucene.Net.Search.BooleanScorer2.SingleMatchScorer">
            <summary>
            Count a scorer as a single match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.MakeCountingSumScorer(System.Boolean)">
            <summary>
            Returns the scorer to be used for match counting and score summing.
            Uses requiredScorers, optionalScorers and prohibitedScorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BooleanScorer2.AddProhibitedScorers(Lucene.Net.Search.Scorer)">
            <summary>
            Returns the scorer to be used for match counting and score summing.
            Uses the given required scorer and the prohibitedScorers. </summary>
            <param name="requiredCountingSumScorer"> A required scorer already built. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IBoostAttribute" -->
        <member name="T:Lucene.Net.Search.BoostAttribute">
            <summary>
            Implementation class for <seealso cref="T:Lucene.Net.Search.IBoostAttribute"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.BoostAttribute.boost">
            <summary>
            Sets the boost in this attribute </summary>
        </member>
        <member name="T:Lucene.Net.Search.BulkScorer">
            <summary>
            this class is used to score a range of documents at
             once, and is returned by <seealso cref="!:Weight#bulkScorer"/>.  Only
             queries that have a more optimized means of scoring
             across a range of documents need to override this.
             Otherwise, a default implementation is wrapped around
             the <seealso cref="T:Lucene.Net.Search.Scorer"/> returned by <seealso cref="!:Weight#scorer"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.BulkScorer.Score(Lucene.Net.Search.ICollector)">
            <summary>
            Scores and collects all matching documents. </summary>
            <param name="collector"> The collector to which all matching documents are passed. </param>
        </member>
        <member name="M:Lucene.Net.Search.BulkScorer.Score(Lucene.Net.Search.ICollector,System.Int32)">
            <summary>
            Collects matching documents in a range.
            </summary>
            <param name="collector"> The collector to which all matching documents are passed. </param>
            <param name="max"> Score up to, but not including, this doc </param>
            <returns> true if more matching documents may remain. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.CachingCollector" -->
        <member name="F:Lucene.Net.Search.CachingCollector.EMPTY_INT32_ARRAY">
            <summary>
            NOTE: This was EMPTY_INT_ARRAY in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(System.Boolean,System.Boolean,System.Double)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Search.CachingCollector"/> which does not wrap another collector.
            The cached documents and scores can later be {@link #replay(Collector)
            replayed}.
            </summary>
            <param name="acceptDocsOutOfOrder">
                     whether documents are allowed to be collected out-of-order </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(Lucene.Net.Search.ICollector,System.Boolean,System.Double)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Search.CachingCollector"/> that wraps the given collector and
            caches documents and scores up to the specified RAM threshold.
            </summary>
            <param name="other">
                     the Collector to wrap and delegate calls to. </param>
            <param name="cacheScores">
                     whether to cache scores in addition to document IDs. Note that
                     this increases the RAM consumed per doc </param>
            <param name="maxRAMMB">
                     the maximum RAM in MB to consume for caching the documents and
                     scores. If the collector exceeds the threshold, no documents and
                     scores are cached. </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Create(Lucene.Net.Search.ICollector,System.Boolean,System.Int32)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Search.CachingCollector"/> that wraps the given collector and
            caches documents and scores up to the specified max docs threshold.
            </summary>
            <param name="other">
                     the Collector to wrap and delegate calls to. </param>
            <param name="cacheScores">
                     whether to cache scores in addition to document IDs. Note that
                     this increases the RAM consumed per doc </param>
            <param name="maxDocsToCache">
                     the maximum number of documents for caching the documents and
                     possible the scores. If the collector exceeds the threshold,
                     no documents and scores are cached. </param>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Called before successive calls to <see cref="M:Lucene.Net.Search.CachingCollector.Collect(System.Int32)"/>. Implementations
            that need the score of the current document (passed-in to
            <also cref="M:Lucene.Net.Search.CachingCollector.Collect(System.Int32)"/>), should save the passed-in <see cref="T:Lucene.Net.Search.Scorer"/> and call
            scorer.Score() when needed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Collect(System.Int32)">
            <summary>
            Called once for every document matching a query, with the unbased document
            number.
            <para/>Note: The collection of the current segment can be terminated by throwing
            a <see cref="T:Lucene.Net.Search.CollectionTerminatedException"/>. In this case, the last docs of the
            current <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> will be skipped and <see cref="T:Lucene.Net.Search.IndexSearcher"/>
            will swallow the exception and continue collection with the next leaf.
            <para/>
            Note: this is called in an inner search loop. For good search performance,
            implementations of this method should not call <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> on every hit.
            Doing so can slow searches by an order of magnitude or more.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.ReplayInit(Lucene.Net.Search.ICollector)">
            <summary>
            Reused by the specialized inner classes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingCollector.Replay(Lucene.Net.Search.ICollector)">
            <summary>
            Replays the cached doc IDs (and scores) to the given Collector. If this
            instance does not cache scores, then Scorer is not set on
            {@code other.setScorer} as well as scores are not replayed.
            </summary>
            <exception cref="T:System.InvalidOperationException">
                      if this collector is not cached (i.e., if the RAM limits were too
                      low for the number of documents + scores to cache). </exception>
            <exception cref="!:IllegalArgumentException">
                      if the given Collect's does not support out-of-order collection,
                      while the collector passed to the ctor does. </exception>
        </member>
        <member name="T:Lucene.Net.Search.CachingWrapperFilter">
            <summary>
            Wraps another <seealso cref="P:Lucene.Net.Search.CachingWrapperFilter.Filter"/>'s result and caches it.  The purpose is to allow
            filters to simply filter, and then wrap with this class
            to add caching.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.#ctor(Lucene.Net.Search.Filter)">
            <summary>
            Wraps another filter's result and caches it. </summary>
            <param name="filter"> Filter to cache results of </param>
        </member>
        <member name="P:Lucene.Net.Search.CachingWrapperFilter.Filter">
            <summary>
            Gets the contained filter. </summary>
            <returns> the contained filter. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.CachingWrapperFilter.DocIdSetToCache(Lucene.Net.Search.DocIdSet,Lucene.Net.Index.AtomicReader)" -->
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.CacheImpl(Lucene.Net.Search.DocIdSetIterator,Lucene.Net.Index.AtomicReader)">
            <summary>
            Default cache implementation: uses <seealso cref="T:Lucene.Net.Util.WAH8DocIdSet"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.CachingWrapperFilter.EMPTY_DOCIDSET">
            <summary>
            An empty {@code DocIdSet} instance </summary>
        </member>
        <member name="M:Lucene.Net.Search.CachingWrapperFilter.GetSizeInBytes">
            <summary>
            Returns total byte size used by cached filters. </summary>
        </member>
        <member name="T:Lucene.Net.Search.CollectionStatistics">
            <summary>
            Contains statistics for a collection (field)
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.CollectionStatistics.Field">
            <summary>
            returns the field name </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.CollectionStatistics.MaxDoc" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.CollectionStatistics.DocCount" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.CollectionStatistics.SumTotalTermFreq" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.CollectionStatistics.SumDocFreq" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.CollectionTerminatedException" -->
        <member name="M:Lucene.Net.Search.CollectionTerminatedException.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Search.CollectionTerminatedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ICollector" -->
        <member name="M:Lucene.Net.Search.ICollector.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Called before successive calls to <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>. Implementations
            that need the score of the current document (passed-in to
            <also cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>), should save the passed-in <see cref="T:Lucene.Net.Search.Scorer"/> and call
            scorer.Score() when needed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ICollector.Collect(System.Int32)">
            <summary>
            Called once for every document matching a query, with the unbased document
            number.
            <para/>Note: The collection of the current segment can be terminated by throwing
            a <see cref="T:Lucene.Net.Search.CollectionTerminatedException"/>. In this case, the last docs of the
            current <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> will be skipped and <see cref="T:Lucene.Net.Search.IndexSearcher"/>
            will swallow the exception and continue collection with the next leaf.
            <para/>
            Note: this is called in an inner search loop. For good search performance,
            implementations of this method should not call <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> on every hit.
            Doing so can slow searches by an order of magnitude or more.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ICollector.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
             <summary>
             Called before collecting from each <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All doc ids in
             <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/> will correspond to <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>.
            
             Add <see cref="!:AtomicReaderContext#docBase"/> to the current <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>'s
             internal document id to re-base ids in <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>.
             </summary>
             <param name="context">next atomic reader context </param>
        </member>
        <member name="P:Lucene.Net.Search.ICollector.AcceptsDocsOutOfOrder">
             <summary>
             Return <c>true</c> if this collector does not
             require the matching docIDs to be delivered in int sort
             order (smallest to largest) to <see cref="M:Lucene.Net.Search.ICollector.Collect(System.Int32)"/>.
            
             <para> Most Lucene Query implementations will visit
             matching docIDs in order.  However, some queries
             (currently limited to certain cases of <see cref="T:Lucene.Net.Search.BooleanQuery"/>) 
             can achieve faster searching if the
             <see cref="T:Lucene.Net.Search.ICollector"/> allows them to deliver the
             docIDs out of order.</para>
            
             <para> Many collectors don't mind getting docIDs out of
             order, so it's important to return <c>true</c>
             here.</para>
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.ComplexExplanation">
            <summary>
            Expert: Describes the score computation for document and query, and
            can distinguish a match independent of a positive value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ComplexExplanation.Match">
            <summary>
            The match status of this explanation node. </summary>
            <returns> May be null if match status is unknown </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.ComplexExplanation.IsMatch" -->
        <member name="T:Lucene.Net.Search.ConjunctionScorer">
            <summary>
            Scorer for conjunctions, sets of queries, all of which are required. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreAutoRewrite.TermCountCutoff">
            <summary>
            If the number of terms in this query is equal to or
             larger than this setting then {@link
             MultiTermQuery#CONSTANT_SCORE_FILTER_REWRITE} is used.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreAutoRewrite.DocCountPercent">
            <summary>
            If the number of documents to be visited in the
             postings exceeds this specified percentage of the
             maxDoc() for the index, then {@link
             MultiTermQuery#CONSTANT_SCORE_FILTER_REWRITE} is used. </summary>
             <param name="percent"> 0.0 to 100.0  </param>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreAutoRewrite.TermStateByteStart">
            <summary>
            Special implementation of BytesStartArray that keeps parallel arrays for <seealso cref="T:Lucene.Net.Index.TermContext"/> </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreQuery">
            <summary>
            A query that wraps another query or a filter and simply returns a constant score equal to the
            query boost for every document that matches the filter or query.
            For queries it therefore simply strips of all scores and returns a constant one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Strips off scores from the passed in Query. The hits will get a constant score
            dependent on the boost factor of this query.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ConstantScoreQuery.#ctor(Lucene.Net.Search.Filter)">
            <summary>
            Wraps a Filter as a Query. The hits will get a constant score
            dependent on the boost factor of this query.
            If you simply want to strip off scores from a Query, no longer use
            {@code new ConstantScoreQuery(new QueryWrapperFilter(query))}, instead
            use <seealso cref="!:#ConstantScoreQuery(Query)"/>!
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreQuery.Filter">
            <summary>
            Returns the encapsulated filter, returns {@code null} if a query is wrapped. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ConstantScoreQuery.Query">
            <summary>
            Returns the encapsulated query, returns {@code null} if a filter is wrapped. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ConstantScoreQuery.ConstantBulkScorer">
            <summary>
            We return this as our <seealso cref="F:Lucene.Net.Search.ConstantScoreQuery.ConstantBulkScorer.bulkScorer"/> so that if the CSQ
             wraps a query with its own optimized top-level
             scorer (e.g. BooleanScorer) we can use that
             top-level scorer.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1">
            <summary>
            Utility class that runs a thread to manage periodic
            reopens of a <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>, with methods to wait for a specific
            index changes to become visible.  To use this class you
            must first wrap your <see cref="T:Lucene.Net.Index.IndexWriter"/> with a
            <see cref="T:Lucene.Net.Index.TrackingIndexWriter"/> and always use it to make changes
            to the index, saving the returned generation.  Then,
            when a given search request needs to see a specific
            index change, call the <see cref="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64)"/> to wait for
            that change to be visible.  Note that this will only
            scale well if most searches do not need to wait for a
            specific index generation.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.#ctor(Lucene.Net.Index.TrackingIndexWriter,Lucene.Net.Search.ReferenceManager{`0},System.Double,System.Double)">
            <summary>
            Create <see cref="T:Lucene.Net.Search.ControlledRealTimeReopenThread`1"/>, to periodically
            reopen the a <see cref="T:Lucene.Net.Search.ReferenceManager`1"/>.
            </summary>
            <param name="targetMaxStaleSec"> Maximum time until a new
                   reader must be opened; this sets the upper bound
                   on how slowly reopens may occur, when no
                   caller is waiting for a specific generation to
                   become visible.
            </param>
            <param name="targetMinStaleSec"> Mininum time until a new
                   reader can be opened; this sets the lower bound
                   on how quickly reopens may occur, when a caller
                   is waiting for a specific generation to
                   become visible. </param>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64)">
            <summary>
            Waits for the target generation to become visible in
            the searcher.
            If the current searcher is older than the
            target generation, this method will block
            until the searcher is reopened, by another via
            <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/> or until the <see cref="T:Lucene.Net.Search.ReferenceManager`1"/> is closed.
            </summary>
            <param name="targetGen"> the generation to wait for </param>
        </member>
        <member name="M:Lucene.Net.Search.ControlledRealTimeReopenThread`1.WaitForGeneration(System.Int64,System.Int32)">
            <summary>
            Waits for the target generation to become visible in
            the searcher, up to a maximum specified milli-seconds.
            If the current searcher is older than the target
            generation, this method will block until the
            searcher has been reopened by another thread via
            <see cref="M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh"/>, the given waiting time has elapsed, or until
            the <seealso cref="T:Lucene.Net.Search.ReferenceManager`1"/> is closed.
            <para/>
            NOTE: if the waiting time elapses before the requested target generation is
            available the current <see cref="T:Lucene.Net.Search.SearcherManager"/> is returned instead.
            </summary>
            <param name="targetGen">
                     the generation to wait for </param>
            <param name="maxMS">
                     maximum milliseconds to wait, or -1 to wait indefinitely </param>
            <returns> true if the <paramref name="targetGen"/> is now available,
                    or false if <paramref name="maxMS"/> wait time was exceeded </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery">
            <summary>
            A query that generates the union of documents produced by its subqueries, and that scores each document with the maximum
            score for that document as produced by any subquery, plus a tie breaking increment for any additional matching subqueries.
            this is useful when searching for a word in multiple fields with different boost factors (so that the fields cannot be
            combined equivalently into a single search field).  We want the primary score to be the one associated with the highest boost,
            not the sum of the field scores (as BooleanQuery would give).
            If the query is "albino elephant" this ensures that "albino" matching one field and "elephant" matching
            another gets a higher score than "albino" matching both fields.
            To get this result, use both BooleanQuery and DisjunctionMaxQuery:  for each term a DisjunctionMaxQuery searches for it in
            each field, while the set of these DisjunctionMaxQuery's is combined into a BooleanQuery.
            The tie breaker capability allows results that include the same term in multiple fields to be judged better than results that
            include this term in only the best of those multiple fields, without confusing this with the better case of two different terms
            in the multiple fields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Single)">
            <summary>
            Creates a new empty DisjunctionMaxQuery.  Use add() to add the subqueries. </summary>
            <param name="tieBreakerMultiplier"> the score of each non-maximum disjunct for a document is multiplied by this weight
                   and added into the final score.  If non-zero, the value should be small, on the order of 0.1, which says that
                   10 occurrences of word in a lower-scored field that is also in a higher scored field is just as good as a unique
                   word in the lower scored field (i.e., one that is not in any higher scored field. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.#ctor(System.Collections.Generic.ICollection{Lucene.Net.Search.Query},System.Single)" -->
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Add(Lucene.Net.Search.Query)">
            <summary>
            Add a subquery to this disjunction </summary>
            <param name="query"> the disjunct added </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.Add(System.Collections.Generic.ICollection{Lucene.Net.Search.Query})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionMaxQuery.GetEnumerator" -->
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.Disjuncts">
            <returns> the disjuncts. </returns>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.TieBreakerMultiplier">
            <returns> tie breaker value for multiple matches. </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight">
             <summary>
             Expert: the Weight for DisjunctionMaxQuery, used to
             normalize, score and explain these queries.
            
             <p>NOTE: this API and implementation is subject to
             change suddenly in the next release.</p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.m_weights">
            <summary>
            The Weights for our subqueries, in 1-1 correspondence with disjuncts </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.#ctor(Lucene.Net.Search.DisjunctionMaxQuery,Lucene.Net.Search.IndexSearcher)">
            <summary>
            Construct the Weight for this Query searched by searcher.  Recursively construct subquery weights. </summary>
        </member>
        <member name="P:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Query">
            <summary>
            Return our associated DisjunctionMaxQuery </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Normalize(System.Single,System.Single)">
            <summary>
            Apply the computed normalization factor to our subqueries </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.GetScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Create the scorer used to score our associated DisjunctionMaxQuery </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.DisjunctionMaxWeight.Explain(Lucene.Net.Index.AtomicReaderContext,System.Int32)">
            <summary>
            Explain the score we computed for doc </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.CreateWeight(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Create the Weight used to score us </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Optimize our representation and our subqueries representations </summary>
            <param name="reader"> the IndexReader we query </param>
            <returns> an optimized copy of us (which may not be a copy if there is nothing to optimize)  </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Clone">
            <summary>
            Create a shallow copy of us -- used in rewriting if necessary </summary>
            <returns> a copy of us (but reuse, don't copy, our subqueries)  </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.ToString(System.String)">
            <summary>
            Prettyprint us. </summary>
            <param name="field"> the field to which we are applied </param>
            <returns> a string that shows what we do, of the form "(disjunct1 | disjunct2 | ... | disjunctn)^boost" </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.Equals(System.Object)">
            <summary>
            Return true iff we represent the same query as o </summary>
            <param name="o"> another object </param>
            <returns> true iff o is a DisjunctionMaxQuery with the same boost and the same subqueries, in the same order, as us </returns>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxQuery.GetHashCode">
            <summary>
            Compute a hash code for hashing us </summary>
            <returns> the hash code </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionMaxScorer">
            <summary>
            The Scorer for DisjunctionMaxQuery.  The union of all documents generated by the the subquery scorers
            is generated in document number order.  The score for each document is the maximum of the scores computed
            by the subquery scorers that generate that document, plus tieBreakerMultiplier times the sum of the scores
            for the other subqueries that generate the document.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.#ctor(Lucene.Net.Search.Weight,System.Single,Lucene.Net.Search.Scorer[])">
            <summary>
            Creates a new instance of DisjunctionMaxScorer
            </summary>
            <param name="weight">
                     The Weight to be used. </param>
            <param name="tieBreakerMultiplier">
                     Multiplier applied to non-maximum-scoring subqueries for a
                     document as they are summed into the result. </param>
            <param name="subScorers">
                     The sub scorers this Scorer should iterate on </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionMaxScorer.GetScore">
            <summary>
            Determine the current document score.  Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time. </summary>
            <returns> the score of the current generated document </returns>
        </member>
        <member name="T:Lucene.Net.Search.DisjunctionScorer">
            <summary>
            Base class for Scorers that score disjunctions.
            Currently this just provides helper methods to manage the heap.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionScorer.m_doc">
            <summary>
            The document number of the current match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.Heapify">
            <summary>
            Organize subScorers into a min heap with scorers generating the earliest document on top.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.HeapAdjust(System.Int32)">
            <summary>
            The subtree of subScorers at root is a min heap except possibly for its root element.
            Bubble the root down as required to make the subtree a heap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionScorer.HeapRemoveRoot">
            <summary>
            Remove the root Scorer from subScorers and re-establish it as a heap
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DisjunctionScorer.AfterNext" -->
        <member name="T:Lucene.Net.Search.DisjunctionSumScorer">
            <summary>
            A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
            this Scorer implements <seealso cref="!:Scorer#advance(int)"/> and uses advance() on the given Scorers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.DisjunctionSumScorer.m_nrMatchers">
            <summary>
            The number of subscorers that provide the current match. </summary>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Search.Scorer[],System.Single[])">
            <summary>
            Construct a <code>DisjunctionScorer</code>. </summary>
            <param name="weight"> The weight to be used. </param>
            <param name="subScorers"> Array of at least two subscorers. </param>
            <param name="coord"> Table of coordination factors </param>
        </member>
        <member name="M:Lucene.Net.Search.DisjunctionSumScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DocIdSet">
            <summary>
            A DocIdSet contains a set of doc ids. Implementing classes must
            only implement <seealso cref="!:#iterator"/> to provide access to the set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSet.GetIterator">
            <summary>
            Provides a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> to access the set.
            this implementation can return <code>null</code> if there
            are no docs that match.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocIdSet.Bits">
            <summary>
            Optionally provides a <seealso cref="!:GetBits"/> interface for random access
            to matching documents. </summary>
            <returns> {@code null}, if this {@code DocIdSet} does not support random access.
            In contrast to <see cref="M:Lucene.Net.Search.DocIdSet.GetIterator"/>, a return value of {@code null}
            <b>does not</b> imply that no documents match the filter!
            The default implementation does not provide random access, so you
            only need to implement this method if your DocIdSet can
            guarantee random access to every docid in O(1) time without
            external disk access (as <seealso cref="!:GetBits"/> interface cannot throw
            <seealso cref="!:IOException"/>). this is generally true for bit sets
            like <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>, which return
            itself if they are used as {@code DocIdSet}. </returns>
        </member>
        <member name="P:Lucene.Net.Search.DocIdSet.IsCacheable">
            <summary>
            this method is a hint for <seealso cref="T:Lucene.Net.Search.CachingWrapperFilter"/>, if this <code>DocIdSet</code>
            should be cached without copying it. The default is to return
            <code>false</code>. If you have an own <code>DocIdSet</code> implementation
            that does its iteration very effective and fast without doing disk I/O,
            override this method and return <code>true</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.DocIdSetIterator">
            <summary>
            this abstract class defines methods to iterate over a set of non-decreasing
            doc ids. Note that this class assumes it iterates on doc Ids, and therefore
            <seealso cref="!:#NO_MORE_DOCS"/> is set to {@value #NO_MORE_DOCS} in order to be used as
            a sentinel object. Implementations of this class are expected to consider
            <see cref="F:System.Int32.MaxValue"/> as an invalid value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocIdSetIterator.GetEmpty">
            <summary>
            An empty {@code DocIdSetIterator} instance </summary>
        </member>
        <member name="F:Lucene.Net.Search.DocIdSetIterator.NO_MORE_DOCS">
            <summary>
            When returned by <seealso cref="!:#nextDoc()"/>, <seealso cref="!:#advance(int)"/> and
            <seealso cref="!:#docID()"/> it means there are no more docs in the iterator.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.DocIdSetIterator.DocID" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DocIdSetIterator.NextDoc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DocIdSetIterator.Advance(System.Int32)" -->
        <member name="M:Lucene.Net.Search.DocIdSetIterator.SlowAdvance(System.Int32)">
            <summary>
            Slow (linear) implementation of <seealso cref="!:#advance"/> relying on
             <seealso cref="!:#nextDoc()"/> to advance beyond the target position.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.DocIdSetIterator.GetCost" -->
        <member name="T:Lucene.Net.Search.DocTermOrdsRangeFilter">
             <summary>
             A range filter built on top of a cached multi-valued term field (in <seealso cref="T:Lucene.Net.Search.IFieldCache"/>).
            
             <p>Like <seealso cref="T:Lucene.Net.Search.FieldCacheRangeFilter"/>, this is just a specialized range query versus
                using a TermRangeQuery with <seealso cref="T:Lucene.Net.Search.DocTermOrdsRewriteMethod"/>: it will only do
                two ordinal to term lookups.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            this method is implemented for each data type </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRangeFilter.NewBytesRefRange(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <summary>
            Creates a BytesRef range filter using <seealso cref="!:IFieldCache#getTermsIndex"/>. this works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.Field">
            <summary>
            Returns the field name for this filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.LowerVal">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRangeFilter.UpperVal">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.DocTermOrdsRewriteMethod" -->
        <member name="M:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.#ctor(Lucene.Net.Search.MultiTermQuery)">
            <summary>
            Wrap a <seealso cref="T:Lucene.Net.Search.MultiTermQuery"/> as a Filter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.DocTermOrdsRewriteMethod.MultiTermQueryDocTermOrdsWrapperFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Returns a DocIdSet with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Explanation">
            <summary>
            Expert: Describes the score computation for document and query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Explanation.IsMatch" -->
        <member name="P:Lucene.Net.Search.Explanation.Value">
            <summary>
            The value assigned to this explanation node. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Explanation.Description">
            <summary>
            A description of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetSummary">
            <summary>
            A short one line summary which should contain all high level
            information about this Explanation, without the "Details"
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.GetDetails">
            <summary>
            The sub-nodes of this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.AddDetail(Lucene.Net.Search.Explanation)">
            <summary>
            Adds a sub-node to this explanation node. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToString">
            <summary>
            Render an explanation as text. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Explanation.ToHtml">
            <summary>
            Render an explanation as HTML. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FakeScorer">
            <summary>
            Used by <seealso cref="T:Lucene.Net.Search.BulkScorer"/>s that need to pass a {@link
             Scorer} to <seealso cref="!:ICollector#setScorer"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IFieldCache" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetDocsWithField(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
             reads the terms in <code>field</code> and returns a bit set at the size of
             <code>reader.maxDoc()</code>, with turned on bits for each docid that
             does have a value for this field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as a single byte and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the single byte values. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="!:IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetBytes(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as bytes and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the bytes. </param>
            <param name="parser">  Computes byte for string values. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="!:IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is
            found, reads the terms in <code>field</code> as shorts and returns an array
            of size <code>reader.maxDoc()</code> of the value each document
            has in the given field. 
            <para/>
            NOTE: this was getShorts() in Lucene
            </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the shorts. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="!:IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found,
            reads the terms in <code>field</code> as shorts and returns an array of
            size <code>reader.maxDoc()</code> of the value each document has in the
            given field. 
            <para/>
            NOTE: this was getShorts() in Lucene
            </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the shorts. </param>
            <param name="parser">  Computes short for string values. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
            @deprecated (4.4) Index as a numeric field using <seealso cref="!:IntField"/> and then use <seealso cref="!:#getInts(AtomicReader, String, boolean)"/> instead.
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)">
            <summary>
            Returns an <seealso cref="T:Lucene.Net.Search.FieldCache.Int32s"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="!:NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as ints and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            <para/>
            NOTE: this was getInts() in Lucene
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the longs. </param>
            <param name="parser">
                     Computes int for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="!:NumericDocValuesField"/> or
                     <seealso cref="!:IntField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetSingles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Boolean)">
            <summary>
            Returns a <seealso cref="!:Floats"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="!:NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as floats and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            <para/>
            NOTE: this was getFloats() in Lucene
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the floats. </param>
            <param name="parser">
                     Computes float for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="!:NumericDocValuesField"/> or
                     <seealso cref="!:FloatField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)">
            <summary>
            Returns a <seealso cref="!:Longs"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="!:NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as longs and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            <para/>
            NOTE: this was getLongs() in Lucene
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the longs. </param>
            <param name="parser">
                     Computes long for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="!:NumericDocValuesField"/> or
                     <seealso cref="!:LongField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IFieldCache.GetDoubles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Boolean)">
            <summary>
            Returns a <seealso cref="!:Doubles"/> over the values found in documents in the given
            field. If the field was indexed as <seealso cref="!:NumericDocValuesField"/>, it simply
            uses <seealso cref="!:AtomicReader#getNumericDocValues(String)"/> to read the values.
            Otherwise, it checks the internal cache for an appropriate entry, and if
            none is found, reads the terms in <code>field</code> as doubles and returns
            an array of size <code>reader.maxDoc()</code> of the value each document
            has in the given field.
            </summary>
            <param name="reader">
                     Used to get field values. </param>
            <param name="field">
                     Which field contains the longs. </param>
            <param name="parser">
                     Computes double for string values. May be {@code null} if the
                     requested field was indexed as <seealso cref="!:NumericDocValuesField"/> or
                     <seealso cref="!:DoubleField"/>. </param>
            <param name="setDocsWithField">
                     If true then <seealso cref="!:#getDocsWithField"/> will also be computed and
                     stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">
                      If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTerms(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>field</code>
            and returns a <seealso cref="T:Lucene.Net.Index.BinaryDocValues"/> instance, providing a
            method to retrieve the term (as a BytesRef) per document. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the strings. </param>
            <param name="setDocsWithField">  If true then <seealso cref="!:#getDocsWithField"/> will
                   also be computed and stored in the FieldCache. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTerms(Lucene.Net.Index.AtomicReader,System.String,System.Boolean,System.Single)">
            <summary>
            Expert: just like <seealso cref="!:#getTerms(AtomicReader,String,boolean)"/>,
             but you can specify whether more RAM should be consumed in exchange for
             faster lookups (default is "true").  Note that the
             first call for a given reader and field "wins",
             subsequent calls will share the same cache entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none
            is found, reads the term values in <code>field</code>
            and returns a <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> instance,
            providing methods to retrieve sort ordinals and terms
            (as a ByteRef) per document. </summary>
            <param name="reader">  Used to get field values. </param>
            <param name="field">   Which field contains the strings. </param>
            <returns> The values in the given field for each document. </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetTermsIndex(Lucene.Net.Index.AtomicReader,System.String,System.Single)">
            <summary>
            Expert: just like {@link
             #getTermsIndex(AtomicReader,String)}, but you can specify
             whether more RAM should be consumed in exchange for
             faster lookups (default is "true").  Note that the
             first call for a given reader and field "wins",
             subsequent calls will share the same cache entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetDocTermOrds(Lucene.Net.Index.AtomicReader,System.String)">
            <summary>
            Checks the internal cache for an appropriate entry, and if none is found, reads the term values
            in <code>field</code> and returns a <seealso cref="!:DocTermOrds"/> instance, providing a method to retrieve
            the terms (as ords) per document.
            </summary>
            <param name="reader">  Used to build a <seealso cref="!:DocTermOrds"/> instance </param>
            <param name="field">   Which field contains the strings. </param>
            <returns> a <seealso cref="!:DocTermOrds"/> instance </returns>
            <exception cref="T:System.IO.IOException">  If any error occurs. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.GetCacheEntries">
            <summary>
            EXPERT: A unique Identifier/Description for each item in the FieldCache.
            Can be useful for logging/debugging.
            @lucene.experimental
            </summary>
            <summary>
            EXPERT: Generates an array of CacheEntry objects representing all items
            currently in the FieldCache.
            <p>
            NOTE: These CacheEntry objects maintain a strong reference to the
            Cached Values.  Maintaining references to a CacheEntry the AtomicIndexReader
            associated with it has garbage collected will prevent the Value itself
            from being garbage collected when the Cache drops the WeakReference.
            </p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.PurgeAllCaches">
            <summary>
            <p>
            EXPERT: Instructs the FieldCache to forcibly expunge all entries
            from the underlying caches.  this is intended only to be used for
            test methods as a way to ensure a known base state of the Cache
            (with out needing to rely on GC to free WeakReferences).
            It should not be relied on for "Cache maintenance" in general
            application code.
            </p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IFieldCache.PurgeByCacheKey(System.Object)">
            <summary>
            Expert: drops all cache entries associated with this
            reader <seealso cref="!:IndexReader#getCoreCacheKey"/>.  NOTE: this cache key must
            precisely match the reader that the cache entry is
            keyed on. If you pass a top-level reader, it usually
            will have no effect as Lucene now caches at the segment
            reader level.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IFieldCache.InfoStream">
            <summary>
            If non-null, FieldCacheImpl will warn whenever
            entries are created that are not sane according to
            <seealso cref="T:Lucene.Net.Util.FieldCacheSanityChecker"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int16s">
            <summary>
            NOTE: This was Shorts in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int16s.EmptyInt16s">
            <summary>
            NOTE: This was EmptyShorts in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int32s">
            <summary>
            NOTE: This was Ints in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int32s.EmptyInt32s">
            <summary>
            NOTE: This was EmptyInts in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int64s">
            <summary>
            NOTE: This was Longs in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Int64s.EmptyInt64s">
            <summary>
            NOTE: This was EmptyLongs in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Singles">
            <summary>
            NOTE: This was Floats in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.Singles.EmptySingles">
            <summary>
            NOTE: This was EmptySingles in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IInt16Parser">
            <summary>
            NOTE: This was ShortParser in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IInt16Parser.ParseInt16(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseShort() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IInt32Parser">
            <summary>
            NOTE: This was IntParser in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IInt32Parser.ParseInt32(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseInt() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.ISingleParser">
            <summary>
            NOTE: This was FloatParser in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.ISingleParser.ParseSingle(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseFloat() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCache.IInt64Parser">
            <summary>
            NOTE: This was LongParser in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.IInt64Parser.ParseInt64(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseLong() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_INT16_PARSER">
            <summary>
            NOTE: This was DEFAULT_SHORT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.AnonymousInt16Parser.ParseInt16(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseShort() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_INT32_PARSER">
            <summary>
            NOTE: This was DEFAULT_INT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.AnonymousInt32Parser.ParseInt32(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseInt() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_SINGLE_PARSER">
            <summary>
            NOTE: This was DEFAULT_FLOAT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.AnonymousSingleParser.ParseSingle(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseFloat() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.DEFAULT_INT64_PARSER">
            <summary>
            NOTE: This was DEFAULT_LONG_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.AnonymousInt64Parser.ParseInt64(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseLong() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.NUMERIC_UTILS_INT32_PARSER">
            <summary>
            NOTE: This was NUMERIC_UTILS_INT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.AnonymousNumericUtilsInt32Parser.ParseInt32(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseInt() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.NUMERIC_UTILS_SINGLE_PARSER">
            <summary>
            NOTE: This was NUMERIC_UTILS_FLOAT_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.AnonymousNumericUtilsSingleParser.ParseSingle(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseFloat() in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldCache.NUMERIC_UTILS_INT64_PARSER">
            <summary>
            NOTE: This was NUMERIC_UTILS_LONG_PARSER in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCache.AnonymousNumericUtilsInt64Parser.ParseInt64(Lucene.Net.Util.BytesRef)">
            <summary>
            NOTE: This was parseLong() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheDocIdSet">
            <summary>
            Base class for DocIdSet to be used with FieldCache. The implementation
            of its iterator is very stupid and slow if the implementation of the
            <seealso cref="!:#matchDoc"/> method is not optimized, as iterators simply increment
            the document id until {@code matchDoc(int)} returns true. Because of this
            {@code matchDoc(int)} must be as fast as possible and in no case do any
            I/O.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheDocIdSet.MatchDoc(System.Int32)">
            <summary>
            this method checks, if a doc is a hit
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheDocIdSet.IsCacheable">
            <summary>
            this DocIdSet is always cacheable (does not go back
            to the reader for iteration)
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl">
             <summary>
             Expert: The default cache implementation, storing all values in memory.
             A WeakHashMap is used for storage.
            
             @since   lucene 1.4
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Cache">
            <summary>
            Expert: Internal cache. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Cache.PurgeByCacheKey(System.Object)">
            <summary>
            Remove this reader from the cache, if present. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.Cache.Put(Lucene.Net.Index.AtomicReader,Lucene.Net.Search.FieldCacheImpl.CacheKey,System.Object)">
            <summary>
            Sets the key to the value for the provided reader;
             if the key is already set then this doesn't change it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.CacheKey">
            <summary>
            Expert: Every composite-key in the internal cache is of this type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.#ctor(System.String,System.Object)">
            <summary>
            Creates one of these objects for a custom comparer/parser. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.Equals(System.Object)">
            <summary>
            Two of these are equal iff they reference the same field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.CacheKey.GetHashCode">
            <summary>
            Composes a hashcode based on the field and type. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            NOTE: this was getShorts() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt16s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Boolean)">
            <summary>
            NOTE: this was getShorts() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int16sFromArray">
            <summary>
            NOTE: This was ShortsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int16Cache">
            <summary>
            NOTE: This was ShortCache in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            NOTE: this was getInts() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt32s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Boolean)">
            <summary>
            NOTE: this was getInts() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int32sFromArray">
            <summary>
            NOTE: This was IntsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int32Cache">
            <summary>
            NOTE: This was IntCache in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetSingles(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            NOTE: this was getFloats() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetSingles(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Boolean)">
            <summary>
            NOTE: this was getFloats() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.SinglesFromArray">
            <summary>
            NOTE: This was FloatsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.SingleCache">
            <summary>
            NOTE: This was FloatCache in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,System.Boolean)">
            <summary>
            NOTE: this was getLongs() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheImpl.GetInt64s(Lucene.Net.Index.AtomicReader,System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Boolean)">
            <summary>
            NOTE: this was getLongs() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int64sFromArray">
            <summary>
            NOTE: This was LongsFromArray in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheImpl.Int64Cache">
            <summary>
            NOTE: This was LongCache in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldCacheRangeFilter" -->
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Creates a string range filter using <seealso cref="!:IFieldCache#getTermsIndex"/>. this works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewBytesRefRange(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <summary>
            Creates a BytesRef range filter using <seealso cref="!:IFieldCache#getTermsIndex"/>. this works with all
            fields containing zero or one term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewByteRange(System.String,System.Nullable{System.SByte},System.Nullable{System.SByte},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getBytes(AtomicReader,String,boolean)"/>. this works with all
            byte fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewByteRange(System.String,Lucene.Net.Search.FieldCache.IByteParser,System.Nullable{System.SByte},System.Nullable{System.SByte},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getBytes(AtomicReader,String,FieldCache.ByteParser,boolean)"/>. this works with all
            byte fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt16Range(System.String,System.Nullable{System.Int16},System.Nullable{System.Int16},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getShorts(AtomicReader,String,boolean)"/>. this works with all
            short fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            <para/>
            NOTE: this was newShortRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt16Range(System.String,Lucene.Net.Search.FieldCache.IInt16Parser,System.Nullable{System.Int16},System.Nullable{System.Int16},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getShorts(AtomicReader,String,FieldCache.ShortParser,boolean)"/>. this works with all
            short fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            <para/>
            NOTE: this was newShortRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt32Range(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getInts(AtomicReader,String,boolean)"/>. this works with all
            int fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            <para/>
            NOTE: this was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt32Range(System.String,Lucene.Net.Search.FieldCache.IInt32Parser,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getInts(AtomicReader,String,FieldCache.IntParser,boolean)"/>. this works with all
            int fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            <para/>
            NOTE: this was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt64Range(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getLongs(AtomicReader,String,boolean)"/>. this works with all
            long fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewInt64Range(System.String,Lucene.Net.Search.FieldCache.IInt64Parser,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getLongs(AtomicReader,String,FieldCache.LongParser,boolean)"/>. this works with all
            long fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            <para/>
            NOTE: this was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewSingleRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getFloats(AtomicReader,String,boolean)"/>. this works with all
            float fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            <para/>
            NOTE: this was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewSingleRange(System.String,Lucene.Net.Search.FieldCache.ISingleParser,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getFloats(AtomicReader,String,FieldCache.FloatParser,boolean)"/>. this works with all
            float fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            <para/>
            NOTE: this was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getDoubles(AtomicReader,String,boolean)"/>. this works with all
            double fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter.NewDoubleRange(System.String,Lucene.Net.Search.FieldCache.IDoubleParser,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Creates a numeric range filter using <seealso cref="!:IFieldCache#getDoubles(AtomicReader,String,FieldCache.DoubleParser,boolean)"/>. this works with all
            double fields containing exactly one numeric term in the field. The range can be half-open by setting one
            of the values to <code>null</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRangeFilter`1.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            this method is implemented for each data type </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.Field">
            <summary>
            Returns the field name for this filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.LowerVal">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.UpperVal">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRangeFilter`1.Parser">
            <summary>
            Returns the current numeric parser ({@code null} for {@code T} is {@code String}} </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldCacheRewriteMethod" -->
        <member name="M:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.#ctor(Lucene.Net.Search.MultiTermQuery)">
            <summary>
            Wrap a <seealso cref="T:Lucene.Net.Search.MultiTermQuery"/> as a Filter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldCacheRewriteMethod.MultiTermQueryFieldCacheWrapperFilter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Returns a DocIdSet with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldCacheTermsFilter">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.Filter"/> that only accepts documents whose single
             term value in the specified field is contained in the
             provided set of allowed terms.
            
             <p/>
            
             this is the same functionality as TermsFilter (from
             queries/), except this filter requires that the
             field contains only a single term for all documents.
             Because of drastically different implementations, they
             also have different performance characteristics, as
             described below.
            
             <p/>
            
             The first invocation of this filter on a given field will
             be slower, since a <seealso cref="T:Lucene.Net.Index.SortedDocValues"/> must be
             created.  Subsequent invocations using the same field
             will re-use this cache.  However, as with all
             functionality based on <seealso cref="P:Lucene.Net.Search.FieldCacheTermsFilter.FieldCache"/>, persistent RAM
             is consumed to hold the cache, and is not freed until the
             <seealso cref="!:IndexReader"/> is closed.  In contrast, TermsFilter
             has no persistent RAM consumption.
            
            
             <p/>
            
             With each search, this filter translates the specified
             set of Terms into a private <seealso cref="T:Lucene.Net.Util.FixedBitSet"/> keyed by
             term number per unique <seealso cref="!:IndexReader"/> (normally one
             reader per segment).  Then, during matching, the term
             number for each docID is retrieved from the cache and
             then checked for inclusion using the <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>.
             Since all testing is done using RAM resident data
             structures, performance should be very fast, most likely
             fast enough to not require further caching of the
             DocIdSet for each possible combination of terms.
             However, because docIDs are simply scanned linearly, an
             index with a great many small documents may find this
             linear scan too costly.
            
             <p/>
            
             In contrast, TermsFilter builds up an <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>,
             keyed by docID, every time it's created, by enumerating
             through all matching docs using <seealso cref="!:DocsEnum"/> to seek
             and scan through each term's docID list.  While there is
             no linear scan of all docIDs, besides the allocation of
             the underlying array in the <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>, this
             approach requires a number of "disk seeks" in proportion
             to the number of terms, which can be exceptionally costly
             when there are cache misses in the OS's IO cache.
            
             <p/>
            
             Generally, this filter will be slower on the first
             invocation for a given field, but subsequent invocations,
             even if you change the allowed set of Terms, should be
             faster than TermsFilter, especially as the number of
             Terms being matched increases.  If you are matching only
             a very small number of terms, and those terms in turn
             match a very small number of documents, TermsFilter may
             perform faster.
            
             <p/>
            
             Which filter is best is very application dependent.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldComparer`1" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparer`1.Compare(System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Search.FieldComparer`1.SetBottom(System.Int32)">
            <summary>
            Set the bottom slot, ie the "weakest" (sorted last)
            entry in the queue.  When <seealso cref="!:#compareBottom"/> is
            called, you should compare against this slot.  this
            will always be called before <seealso cref="!:#compareBottom"/>.
            </summary>
            <param name="slot"> the currently weakest (sorted last) slot in the queue </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.SetTopValue(System.Object)">
            <summary>
            Record the top value, for future calls to {@link
            #compareTop}.  this is only called for searches that
            use searchAfter (deep paging), and is called before any
            calls to <seealso cref="!:#setNextReader"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparer`1.CompareBottom(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparer`1.CompareTop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.FieldComparer`1.Copy(System.Int32,System.Int32)">
            <summary>
            this method is called when a new hit is competitive.
            You should copy any state associated with this document
            that will be required for future comparisons, into the
            specified slot.
            </summary>
            <param name="slot"> which slot to copy the hit to </param>
            <param name="doc"> docID relative to current reader </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Set a new <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All subsequent docIDs are relative to
            the current reader (you must add docBase if you need to
            map it to a top-level docID).
            </summary>
            <param name="context"> current reader context </param>
            <returns> the comparer to use for this segment; most
              comparers can just return "this" to reuse the same
              comparer across segments </returns>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer`1.CompareValues(`0,`0)">
            <summary>
            Returns -1 if first is less than second.  Default
             impl to assume the type implements Comparable and
             invoke .compareTo; be sure to override this method if
             your FieldComparer's type isn't a Comparable or
             if your values may sometimes be null
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparer.Compare(System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Search.FieldComparer.SetBottom(System.Int32)">
            <summary>
            Set the bottom slot, ie the "weakest" (sorted last)
            entry in the queue.  When <seealso cref="!:#compareBottom"/> is
            called, you should compare against this slot.  this
            will always be called before <seealso cref="!:#compareBottom"/>.
            </summary>
            <param name="slot"> the currently weakest (sorted last) slot in the queue </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.SetTopValue(System.Object)">
            <summary>
            Record the top value, for future calls to {@link
            #compareTop}.  this is only called for searches that
            use searchAfter (deep paging), and is called before any
            calls to <seealso cref="!:#setNextReader"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparer.CompareBottom(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldComparer.CompareTop(System.Int32)" -->
        <member name="M:Lucene.Net.Search.FieldComparer.Copy(System.Int32,System.Int32)">
            <summary>
            this method is called when a new hit is competitive.
            You should copy any state associated with this document
            that will be required for future comparisons, into the
            specified slot.
            </summary>
            <param name="slot"> which slot to copy the hit to </param>
            <param name="doc"> docID relative to current reader </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Set a new <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All subsequent docIDs are relative to
            the current reader (you must add docBase if you need to
            map it to a top-level docID).
            </summary>
            <param name="context"> current reader context </param>
            <returns> the comparer to use for this segment; most
              comparers can just return "this" to reuse the same
              comparer across segments </returns>
            <exception cref="!:IOException"> if there is a low-level IO error </exception>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Sets the Scorer to use in case a document's score is
             needed.
            </summary>
            <param name="scorer"> Scorer instance that you should use to
            obtain the current hit's score, if necessary.  </param>
        </member>
        <member name="P:Lucene.Net.Search.FieldComparer.Item(System.Int32)">
            <summary>
            Return the actual value in the slot.
            LUCENENET NOTE: This was value(int) in Lucene.
            </summary>
            <param name="slot"> the value </param>
            <returns> value in this slot </returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.NumericComparer`1">
            <summary>
            Base FieldComparer class for numeric types
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.ByteComparer">
            <summary>
            Parses field's values as byte (using {@link
             FieldCache#getBytes} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.DoubleComparer">
            <summary>
            Parses field's values as double (using {@link
             FieldCache#getDoubles} and sorts by ascending value
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.SingleComparer">
            <summary>
            Parses field's values as float (using {@link
             FieldCache#getFloats} and sorts by ascending value
            <para/>
            NOTE: This was FloatComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.Int16Comparer">
            <summary>
            Parses field's values as short (using {@link
            FieldCache#getShorts} and sorts by ascending value
            <para/>
            NOTE: This was ShortComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.Int32Comparer">
            <summary>
            Parses field's values as int (using {@link
            FieldCache#getInts} and sorts by ascending value
            <para/>
            NOTE: This was IntComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.Int64Comparer">
            <summary>
            Parses field's values as long (using {@link
            FieldCache#getLongs} and sorts by ascending value
            <para/>
            NOTE: This was LongComparator in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.RelevanceComparer">
            <summary>
            Sorts by descending relevance.  NOTE: if you are
             sorting only by descending relevance and then
             secondarily by ascending docID, performance is faster
             using <seealso cref="T:Lucene.Net.Search.TopScoreDocCollector"/> directly (which {@link
             IndexSearcher#search} uses when no <seealso cref="T:Lucene.Net.Search.Sort"/> is
             specified).
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.DocComparer">
            <summary>
            Sorts by ascending docID </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.TermOrdValComparer">
            <summary>
            Sorts by field's natural Term sort order, using
             ordinals.  this is functionally equivalent to {@link
             Lucene.Net.Search.FieldComparer.TermValComparer}, but it first resolves the string
             to their relative ordinal positions (using the index
             returned by <seealso cref="!:IFieldCache#getTermsIndex"/>), and
             does most comparisons using the ordinals.  For medium
             to large results, this comparer will be much faster
             than <seealso cref="T:Lucene.Net.Search.FieldComparer.TermValComparer"/>.  For very small
             result sets it may be slower.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.topValue">
            <summary>
            Set by setTopValue. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.missingSortCmp">
            <summary>
            -1 if missing values are sorted first, 1 if they are
             sorted last
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FieldComparer.TermOrdValComparer.missingOrd">
            <summary>
            Which ordinal to use for a missing value. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermOrdValComparer.#ctor(System.Int32,System.String)">
            <summary>
            Creates this, sorting missing values first. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermOrdValComparer.#ctor(System.Int32,System.String,System.Boolean)">
            <summary>
            Creates this, with control over how missing values
             are sorted.  Pass sortMissingLast=true to put
             missing values at the end.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermOrdValComparer.GetSortedDocValues(Lucene.Net.Index.AtomicReaderContext,System.String)">
            <summary>
            Retrieves the SortedDocValues for the field in this segment </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparer.TermValComparer">
            <summary>
            Sorts by field's natural Term sort order.  All
             comparisons are done using BytesRef.compareTo, which is
             slow for medium to large result sets but possibly
             very fast for very small results sets.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparer.TermValComparer.#ctor(System.Int32,System.String)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldComparerSource">
             <summary>
             Provides a <seealso cref="T:Lucene.Net.Search.FieldComparer"/> for custom field sorting.
            
             @lucene.experimental
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldComparerSource.NewComparer(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Creates a comparer for the field in the given index.
            </summary>
            <param name="fieldname">
                     Name of the field to create comparer for. </param>
            <returns> FieldComparer. </returns>
            <exception cref="!:IOException">
                      If an error occurs reading the index. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldDoc" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.FieldDoc.Fields" -->
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single)">
            <summary>
            Expert: Creates one of these objects with empty sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.Object[])">
            <summary>
            Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldDoc.#ctor(System.Int32,System.Single,System.Object[],System.Int32)">
            <summary>
            Expert: Creates one of these objects with the given sort information. </summary>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueFilter">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Filter"/> that accepts all documents that have one or more values in a
            given field. this <seealso cref="T:Lucene.Net.Search.Filter"/> request <seealso cref="T:Lucene.Net.Util.IBits"/> from the
            <seealso cref="T:Lucene.Net.Search.IFieldCache"/> and build the bits if not present.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.#ctor(System.String)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Search.FieldValueFilter"/>
            </summary>
            <param name="field">
                     the field to filter </param>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueFilter.#ctor(System.String,System.Boolean)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Search.FieldValueFilter"/>
            </summary>
            <param name="field">
                     the field to filter </param>
            <param name="negate">
                     iff <code>true</code> all documents with no value in the given
                     field are accepted.
             </param>
        </member>
        <member name="P:Lucene.Net.Search.FieldValueFilter.Field">
            <summary>
            Returns the field this filter is applied on. </summary>
            <returns> the field this filter is applied on. </returns>
        </member>
        <member name="P:Lucene.Net.Search.FieldValueFilter.Negate">
            <summary>
            Returns <code>true</code> iff this filter is negated, otherwise <code>false</code> </summary>
            <returns> <code>true</code> iff this filter is negated, otherwise <code>false</code> </returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueHitQueue.OneComparerFieldValueHitQueue`1">
            <summary> An implementation of <see cref="T:Lucene.Net.Search.FieldValueHitQueue" /> which is optimized in case
            there is just one comparer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueHitQueue.OneComparerFieldValueHitQueue`1.LessThan(`0,`0)">
            <summary> Returns whether <c>a</c> is less relevant than <c>b</c>.</summary>
            <param name="hitA">ScoreDoc</param>
            <param name="hitB">ScoreDoc</param>
            <returns><c>true</c> if document <c>a</c> should be sorted after document <c>b</c>.</returns>
        </member>
        <member name="T:Lucene.Net.Search.FieldValueHitQueue.MultiComparersFieldValueHitQueue`1">
            <summary> An implementation of <see cref="T:Lucene.Net.Search.FieldValueHitQueue" /> which is optimized in case
            there is more than one comparer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FieldValueHitQueue.Create``1(Lucene.Net.Search.SortField[],System.Int32)">
             <summary> Creates a hit queue sorted by the given list of fields.
            
             <p/><b>NOTE</b>: The instances returned by this method
             pre-allocate a full array of length <c>numHits</c>.
            
             </summary>
             <param name="fields">SortField array we are sorting by in priority order (highest
             priority first); cannot be <c>null</c> or empty
             </param>
             <param name="size">The number of hits to retain. Must be greater than zero.
             </param>
             <throws>  IOException </throws>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FieldValueHitQueue`1" -->
        <member name="F:Lucene.Net.Search.FieldValueHitQueue`1.m_fields">
            <summary>
            Stores the sort criteria being used. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FieldValueHitQueue`1.FillFields(Lucene.Net.Search.FieldValueHitQueue.Entry)" -->
        <member name="P:Lucene.Net.Search.FieldValueHitQueue`1.Fields">
            <summary>
            Returns the SortFields being used by this hit queue. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Filter">
            <summary>
             Abstract base class for restricting which documents may
             be returned during searching.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Filter.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredDocIdSet" -->
        <member name="M:Lucene.Net.Search.FilteredDocIdSet.#ctor(Lucene.Net.Search.DocIdSet)">
            <summary>
            Constructor. </summary>
            <param name="innerSet"> Underlying DocIdSet </param>
        </member>
        <member name="P:Lucene.Net.Search.FilteredDocIdSet.IsCacheable">
            <summary>
            this DocIdSet implementation is cacheable if the inner set is cacheable. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSet.Match(System.Int32)">
            <summary>
            Validation method to determine whether a docid should be in the result set. </summary>
            <param name="docid"> docid to be tested </param>
            <returns> true if input docid should be in the result set, false otherwise. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredDocIdSet.GetIterator" -->
        <member name="T:Lucene.Net.Search.FilteredDocIdSetIterator">
            <summary>
            Abstract decorator class of a DocIdSetIterator
            implementation that provides on-demand filter/validation
            mechanism on an underlying DocIdSetIterator.  See {@link
            FilteredDocIdSet}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredDocIdSetIterator.#ctor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Constructor. </summary>
            <param name="innerIter"> Underlying DocIdSetIterator. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredDocIdSetIterator.Match(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FilteredQuery" -->
        <member name="M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>
            Constructs a new query which applies a filter to the results of the original query.
            <seealso cref="!:Filter#getDocIdSet"/> will be called every time this query is used in a search. </summary>
            <param name="query">  Query to be filtered, cannot be <code>null</code>. </param>
            <param name="filter"> Filter to apply to query results, cannot be <code>null</code>. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredQuery.#ctor(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.FilteredQuery.FilterStrategy)" -->
        <member name="M:Lucene.Net.Search.FilteredQuery.CreateWeight(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Returns a Weight that applies the filter to the enclosed query's Weight.
            this is accomplished by overriding the Scorer returned by the Weight.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.QueryFirstScorer">
            <summary>
            A scorer that consults the filter iff a document was matched by the
            delegate scorer. this is useful if the filter computation is more expensive
            than document scoring or if the filter has a linear running time to compute
            the next matching doc like exact geo distances.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.LeapFrogScorer">
            <summary>
            A Scorer that uses a "leap-frog" approach (also called "zig-zag join"). The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Rewrites the query. If the wrapped is an instance of
            <seealso cref="T:Lucene.Net.Search.MatchAllDocsQuery"/> it returns a <seealso cref="T:Lucene.Net.Search.ConstantScoreQuery"/>. Otherwise
            it returns a new {@code FilteredQuery} wrapping the rewritten query.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Query">
            <summary>
            Returns this FilteredQuery's (unfiltered) Query </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Filter">
            <summary>
            Returns this FilteredQuery's filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.FilteredQuery.Strategy">
            <summary>
            Returns this FilteredQuery's <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.RANDOM_ACCESS_FILTER_STRATEGY">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> that conditionally uses a random access filter if
             the given <seealso cref="T:Lucene.Net.Search.DocIdSet"/> supports random access (returns a non-null value
             from <seealso cref="!:DocIdSet#bits()"/>) and
             <seealso cref="!:RandomAccessFilterStrategy#useRandomAccess(Bits, int)"/> returns
             <code>true</code>. Otherwise this strategy falls back to a "zig-zag join" (
             <seealso cref="!:FilteredQuery#LEAP_FROG_FILTER_FIRST_STRATEGY"/>) strategy.
            
             <p>
             Note: this strategy is the default strategy in <seealso cref="T:Lucene.Net.Search.FilteredQuery"/>
             </p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_FILTER_FIRST_STRATEGY">
            <summary>
            A filter strategy that uses a "leap-frog" approach (also called "zig-zag join").
            The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            <p>
            Note: this strategy uses the filter to lead the iteration.
            </p>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.LEAP_FROG_QUERY_FIRST_STRATEGY">
            <summary>
            A filter strategy that uses a "leap-frog" approach (also called "zig-zag join").
            The scorer and the filter
            take turns trying to advance to each other's next matching document, often
            jumping past the target document. When both land on the same document, it's
            collected.
            <p>
            Note: this strategy uses the query to lead the iteration.
            </p>
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FilteredQuery.QUERY_FIRST_FILTER_STRATEGY">
            <summary>
            A filter strategy that advances the Query or rather its <seealso cref="T:Lucene.Net.Search.Scorer"/> first and consults the
            filter <seealso cref="T:Lucene.Net.Search.DocIdSet"/> for each matched document.
            <p>
            Note: this strategy requires a <seealso cref="!:DocIdSet#bits()"/> to return a non-null value. Otherwise
            this strategy falls back to <seealso cref="!:FilteredQuery#LEAP_FROG_QUERY_FIRST_STRATEGY"/>
            </p>
            <p>
            Use this strategy if the filter computation is more expensive than document
            scoring or if the filter has a linear running time to compute the next
            matching doc like exact geo distances.
            </p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.FilterStrategy">
            <summary>
            Abstract class that defines how the filter (<seealso cref="T:Lucene.Net.Search.DocIdSet"/>) applied during document collection. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.FilterStrategy.FilteredScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Search.Weight,Lucene.Net.Search.DocIdSet)">
            <summary>
            Returns a filtered <seealso cref="T:Lucene.Net.Search.Scorer"/> based on this strategy.
            </summary>
            <param name="context">
                     the <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <seealso cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="weight"> the <seealso cref="T:Lucene.Net.Search.FilteredQuery"/> <seealso cref="T:Lucene.Net.Search.Weight"/> to create the filtered scorer. </param>
            <param name="docIdSet"> the filter <seealso cref="T:Lucene.Net.Search.DocIdSet"/> to apply </param>
            <returns> a filtered scorer
            </returns>
            <exception cref="!:IOException"> if an <seealso cref="!:IOException"/> occurs </exception>
        </member>
        <member name="M:Lucene.Net.Search.FilteredQuery.FilterStrategy.FilteredBulkScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Search.Weight,System.Boolean,Lucene.Net.Search.DocIdSet)">
            <summary>
            Returns a filtered <seealso cref="T:Lucene.Net.Search.BulkScorer"/> based on this
            strategy.  this is an optional method: the default
            implementation just calls <seealso cref="!:#filteredScorer"/> and
            wraps that into a BulkScorer.
            </summary>
            <param name="context">
                     the <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <seealso cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="weight"> the <seealso cref="T:Lucene.Net.Search.FilteredQuery"/> <seealso cref="T:Lucene.Net.Search.Weight"/> to create the filtered scorer. </param>
            <param name="docIdSet"> the filter <seealso cref="T:Lucene.Net.Search.DocIdSet"/> to apply </param>
            <returns> a filtered top scorer </returns>
        </member>
        <member name="T:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.FilteredQuery.FilterStrategy"/> that conditionally uses a random access filter if
            the given <seealso cref="T:Lucene.Net.Search.DocIdSet"/> supports random access (returns a non-null value
            from <seealso cref="!:DocIdSet#bits()"/>) and
            <seealso cref="!:RandomAccessFilterStrategy#useRandomAccess(Bits, int)"/> returns
            <code>true</code>. Otherwise this strategy falls back to a "zig-zag join" (
            <seealso cref="!:FilteredQuery#LEAP_FROG_FILTER_FIRST_STRATEGY"/>) strategy .
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FilteredQuery.RandomAccessFilterStrategy.UseRandomAccess(Lucene.Net.Util.IBits,System.Int32)" -->
        <member name="T:Lucene.Net.Search.FilteredQuery.QueryFirstFilterStrategy">
            <summary>
            A filter strategy that advances the <seealso cref="T:Lucene.Net.Search.Scorer"/> first and consults the
            <seealso cref="T:Lucene.Net.Search.DocIdSet"/> for each matched document.
            <p>
            Note: this strategy requires a <seealso cref="!:DocIdSet#bits()"/> to return a non-null value. Otherwise
            this strategy falls back to <seealso cref="!:FilteredQuery#LEAP_FROG_QUERY_FIRST_STRATEGY"/>
            </p>
            <p>
            Use this strategy if the filter computation is more expensive than document
            scoring or if the filter has a linear running time to compute the next
            matching doc like exact geo distances.
            </p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyQuery" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32,System.Int32,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32,System.Int32)">
            <summary>
            Calls {@link #FuzzyQuery(Term, int, int, int, boolean)
            FuzzyQuery(term, maxEdits, prefixLength, defaultMaxExpansions, defaultTranspositions)}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Calls <seealso cref="!:#FuzzyQuery(Term, int, int) FuzzyQuery(term, maxEdits, defaultPrefixLength)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Calls <seealso cref="!:#FuzzyQuery(Term, int) FuzzyQuery(term, defaultMaxEdits)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.MaxEdits">
            <returns> the maximum number of edit distances allowed for this query to match. </returns>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.PrefixLength">
            <summary>
            Returns the non-fuzzy prefix length. this is the number of characters at the start
            of a term that must be identical (not fuzzy) to the query term if the query
            is to match that term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.Transpositions">
            <summary>
            Returns true if transpositions should be treated as a primitive edit operation.
            If this is false, comparisons will implement the classic Levenshtein algorithm.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyQuery.Term">
            <summary>
            Returns the pattern term.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.FuzzyQuery.DefaultMinSimilarity">
            @deprecated pass integer edit distances instead.
        </member>
        <member name="M:Lucene.Net.Search.FuzzyQuery.SingleToEdits(System.Single,System.Int32)">
            <summary>
            Helper function to convert from deprecated "minimumSimilarity" fractions
            to raw edit distances.
            <para/>
            NOTE: this was floatToEdits() in Lucene
            </summary>
            <param name="minimumSimilarity"> scaled similarity </param>
            <param name="termLen"> length (in unicode codepoints) of the term. </param>
            <returns> equivalent number of maxEdits </returns>
            @deprecated pass integer edit distances instead.
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum">
             <summary>
             Subclass of TermsEnum for enumerating all terms that are similar
             to the specified filter term.
            
             <p>Term enumerations are always ordered by
             <seealso cref="!:#getComparer"/>.  Each term in the enumeration is
             greater than all that precede it.</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.FuzzyTermsEnum.#ctor(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource,Lucene.Net.Index.Term,System.Single,System.Int32,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.GetAutomatonEnum(System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            return an automata-based enum for matching up to editDistance from
            lastTerm, if possible
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.InitAutomata(System.Int32)">
            <summary>
            initialize levenshtein DFAs up to maxDistance, if possible </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.SetEnum(Lucene.Net.Index.TermsEnum)">
            <summary>
            swap in a new actual enum to proxy to </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.BottomChanged(Lucene.Net.Util.BytesRef,System.Boolean)">
            <summary>
            fired when the max non-competitive boost has changed. this is the hook to
            swap in a smarter actualEnum
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum" -->
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum.Accept(Lucene.Net.Util.BytesRef)">
            <summary>
            finds the smallest Lev(n) DFA that accepts the term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.FuzzyTermsEnum.AutomatonFuzzyTermsEnum.Matches(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            returns true if term is within k edits of the query term </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyTermsEnum.MinSimilarity">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="P:Lucene.Net.Search.FuzzyTermsEnum.ScaleFactor">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum.ILevenshteinAutomataAttribute">
            <summary>
            reuses compiled automata across different segments,
            because they are independent of the index
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.FuzzyTermsEnum.LevenshteinAutomataAttribute">
            <summary>
            Stores compiled automata as a list (indexed by edit distance)
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.HitQueue.#ctor(System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute" -->
        <member name="P:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute.MaxNonCompetitiveBoost">
            <summary>
            this is the maximum boost that would not be competitive. </summary>
        </member>
        <member name="P:Lucene.Net.Search.IMaxNonCompetitiveBoostAttribute.CompetitiveTerm">
            <summary>
            this is the term or <code>null</code> of the term that triggered the boost change. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher" -->
        <member name="F:Lucene.Net.Search.IndexSearcher.m_leafSlices">
            <summary>
            used with executor - each slice holds a set of leafs executed within one thread </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.DefaultSimilarity">
            <summary>
            Expert: returns a default Similarity instance.
            In general, this method is only called to initialize searchers and writers.
            User code and query implementations should respect
            <seealso cref="!:IndexSearcher#getSimilarity()"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.IndexSearcher.similarity">
            <summary>
            The Similarity implementation used by this searcher. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader)">
            <summary>
            Creates a searcher searching the provided index. </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReader,System.Threading.Tasks.TaskScheduler)">
             <summary>
             Runs searches for each segment separately, using the
              provided ExecutorService.  IndexSearcher will not
              shutdown/awaitTermination this ExecutorService on
              close; you must do so, eventually, on your own.  NOTE:
              if you are using <seealso cref="!:NIOFSDirectory"/>, do not use
              the shutdownNow method of ExecutorService as this uses
              Thread.interrupt under-the-hood which can silently
              close file descriptors (see <a
              href="https://issues.apache.org/jira/browse/LUCENE-2239">LUCENE-2239</a>).
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReaderContext,System.Threading.Tasks.TaskScheduler)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.#ctor(Lucene.Net.Index.IndexReaderContext)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Slices(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext})">
            <summary>
            Expert: Creates an array of leaf slices each holding a subset of the given leaves.
            Each <seealso cref="T:Lucene.Net.Search.IndexSearcher.LeafSlice"/> is executed in a single thread. By default there
            will be one <seealso cref="T:Lucene.Net.Search.IndexSearcher.LeafSlice"/> per leaf (<seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/>).
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.IndexReader">
            <summary>
            Return the <seealso cref="P:Lucene.Net.Search.IndexSearcher.IndexReader"/> this searches. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32,Lucene.Net.Index.StoredFieldVisitor)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32,System.Collections.Generic.ISet{System.String})" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Document(System.Int32,System.Collections.Generic.ISet{System.String})">
            @deprecated Use <seealso cref="!:#doc(int, Set)"/> instead.
        </member>
        <member name="P:Lucene.Net.Search.IndexSearcher.Similarity">
             <summary>
             Expert: Set the Similarity implementation used by this IndexSearcher.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.WrapFilter(Lucene.Net.Search.Query,Lucene.Net.Search.Filter)">
            <summary>
            @lucene.internal </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32)">
            <summary>
            Finds the top <code>n</code>
            hits for <code>query</code>.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32)">
            <summary>
            Finds the top <code>n</code>
            hits for <code>query</code>, applying <code>filter</code> if non-null.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,Lucene.Net.Search.ICollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.ICollector)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)">
            <summary>
            Search implementation with arbitrary sorting, plus
            control over whether hit scores and max score
            should be computed.  Finds
            the top <code>n</code> hits for <code>query</code>, applying
            <code>filter</code> if non-null, and sorting the hits by the criteria in
            <code>sort</code>.  If <code>doDocScores</code> is <code>true</code>
            then the score of each hit will be computed and
            returned.  If <code>doMaxScore</code> is
            <code>true</code> then the maximum score over all
            collected hits will be computed.
            </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Query,System.Int32,Lucene.Net.Search.Sort)">
            <summary>
            Search implementation with arbitrary sorting and no filter. </summary>
            <param name="query"> The query to search for </param>
            <param name="n"> Return only the top n results </param>
            <param name="sort"> The <seealso cref="T:Lucene.Net.Search.Sort"/> object </param>
            <returns> The top docs, sorted according to the supplied <seealso cref="T:Lucene.Net.Search.Sort"/> instance </returns>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,System.Int32,Lucene.Net.Search.Sort)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.SearchAfter(Lucene.Net.Search.ScoreDoc,Lucene.Net.Search.Query,Lucene.Net.Search.Filter,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.ScoreDoc,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.ScoreDoc,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(Lucene.Net.Search.Weight,Lucene.Net.Search.FieldDoc,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Just like <seealso cref="!:#search(Weight, int, Sort, boolean, boolean)"/>, but you choose
            whether or not the fields in the returned <seealso cref="T:Lucene.Net.Search.FieldDoc"/> instances should
            be set by specifying fillFields.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.FieldDoc,System.Int32,Lucene.Net.Search.Sort,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Just like <seealso cref="!:#search(Weight, int, Sort, boolean, boolean)"/>, but you choose
            whether or not the fields in the returned <seealso cref="T:Lucene.Net.Search.FieldDoc"/> instances should
            be set by specifying fillFields.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Search(System.Collections.Generic.IList{Lucene.Net.Index.AtomicReaderContext},Lucene.Net.Search.Weight,Lucene.Net.Search.ICollector)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.Rewrite(Lucene.Net.Search.Query)">
            <summary>
            Expert: called to re-write queries into primitive queries. </summary>
            <exception cref="T:Lucene.Net.Search.BooleanQuery.TooManyClausesException"> If a query would exceed
                    <seealso cref="!:BooleanQuery#getMaxClauseCount()"/> clauses. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Query,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.IndexSearcher.Explain(Lucene.Net.Search.Weight,System.Int32)" -->
        <member name="M:Lucene.Net.Search.IndexSearcher.CreateNormalizedWeight(Lucene.Net.Search.Query)">
            <summary>
            Creates a normalized weight for a top-level <seealso cref="T:Lucene.Net.Search.Query"/>.
            The query is rewritten by this method and <seealso cref="!:Query#createWeight"/> called,
            afterwards the <seealso cref="T:Lucene.Net.Search.Weight"/> is normalized. The returned {@code Weight}
            can then directly be used to get a <seealso cref="T:Lucene.Net.Search.Scorer"/>.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.IndexSearcher.TopReaderContext" -->
        <member name="T:Lucene.Net.Search.IndexSearcher.SearcherCallableNoSort">
            <summary>
            A thread subclass for searching a single searchable
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.IndexSearcher.SearcherCallableWithSort">
            <summary>
            A thread subclass for searching a single searchable
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.IndexSearcher.ExecutionHelper`1" -->
        <member name="T:Lucene.Net.Search.IndexSearcher.LeafSlice">
             <summary>
             A class holding a subset of the <seealso cref="T:Lucene.Net.Search.IndexSearcher"/>s leaf contexts to be
             executed within a single thread.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.TermStatistics(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)">
             <summary>
             Returns <seealso cref="M:Lucene.Net.Search.IndexSearcher.TermStatistics(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)"/> for a term.
            
             this can be overridden for example, to return a term's statistics
             across a distributed collection.
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.IndexSearcher.CollectionStatistics(System.String)">
             <summary>
             Returns <seealso cref="M:Lucene.Net.Search.IndexSearcher.CollectionStatistics(System.String)"/> for a field.
            
             this can be overridden for example, to return a field's statistics
             across a distributed collection.
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.LiveFieldValues`2" -->
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Add(System.String,`1)">
            <summary>
            Call this after you've successfully added a document
             to the index, to record what value you just set the
             field to.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Delete(System.String)">
            <summary>
            Call this after you've successfully deleted a document
             from the index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.LiveFieldValues`2.Count">
            <summary>
            Returns the [approximate] number of id/value pairs
            buffered in RAM.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.LiveFieldValues`2.Get(System.String)">
            <summary>
            Returns the current value for this id, or null if the
             id isn't in the index or was deleted.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.LiveFieldValues`2.LookupFromSearcher(`0,System.String)" -->
        <member name="T:Lucene.Net.Search.MatchAllDocsQuery">
             <summary>
             A query that matches all documents.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.MaxNonCompetitiveBoostAttribute">
            <summary>
            Implementation class for <seealso cref="T:Lucene.Net.Search.MaxNonCompetitiveBoostAttribute"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MinShouldMatchSumScorer">
             <summary>
             A Scorer for OR like queries, counterpart of <code>ConjunctionScorer</code>.
             this Scorer implements <seealso cref="!:Scorer#advance(int)"/> and uses advance() on the given Scorers.
            
             this implementation uses the minimumMatch constraint actively to efficiently
             prune the number of candidates, it is hence a mixture between a pure DisjunctionScorer
             and a ConjunctionScorer.
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.numScorers">
            <summary>
            The overall number of non-finalized scorers </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.mm">
            <summary>
            The minimum number of scorers that should match </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.sortedSubScorers">
            <summary>
            A static array of all subscorers sorted by decreasing cost </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.sortedSubScorersIdx">
            <summary>
            A monotonically increasing index into the array pointing to the next subscorer that is to be excluded </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.mmStack">
            <summary>
            mmStack is supposed to contain the most costly subScorers that still did
             not run out of docs, sorted by increasing sparsity of docs returned by that subScorer.
             For now, the cost of subscorers is assumed to be inversely correlated with sparsity.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.doc">
            <summary>
            The document number of the current match. </summary>
        </member>
        <member name="F:Lucene.Net.Search.MinShouldMatchSumScorer.m_nrMatchers">
            <summary>
            The number of subscorers that provide the current match. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MinShouldMatchSumScorer.#ctor(Lucene.Net.Search.Weight,System.Collections.Generic.IList{Lucene.Net.Search.Scorer},System.Int32)" -->
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.#ctor(Lucene.Net.Search.Weight,System.Collections.Generic.IList{Lucene.Net.Search.Scorer})">
            <summary>
            Construct a <code>DisjunctionScorer</code>, using one as the minimum number
            of matching subscorers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query. Initially
            invalid, until <seealso cref="!:#nextDoc()"/> is called the first time.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MinShouldMatchSumScorer.Advance(System.Int32)" -->
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapHeapify">
            <summary>
            Organize subScorers into a min heap with scorers generating the earliest document on top.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapSiftDown(System.Int32)">
            <summary>
            The subtree of subScorers at root is a min heap except possibly for its root element.
            Bubble the root down as required to make the subtree a heap.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapRemoveRoot">
            <summary>
            Remove the root Scorer from subScorers and re-establish it as a heap
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MinShouldMatchSumScorer.MinheapRemove(Lucene.Net.Search.Scorer)">
            <summary>
            Removes a given Scorer from the heap by placing end of heap at that
            position and bubbling it either up or down
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.MultiCollector">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.ICollector"/> which allows running a search with several
            <seealso cref="T:Lucene.Net.Search.ICollector"/>s. It offers a static <seealso cref="!:#wrap"/> method which accepts a
            list of collectors and wraps them with <seealso cref="T:Lucene.Net.Search.MultiCollector"/>, while
            filtering out the <code>null</code> null ones.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiCollector.Wrap(Lucene.Net.Search.ICollector[])" -->
        <member name="T:Lucene.Net.Search.MultiPhraseQuery">
             <summary>
             MultiPhraseQuery is a generalized version of PhraseQuery, with an added
             method <seealso cref="!:#add(Term[])"/>.
             To use this class, to search for the phrase "Microsoft app*" first use
             add(Term) on the term "Microsoft", then find all terms that have "app" as
             prefix using IndexReader.terms(Term), and use MultiPhraseQuery.add(Term[]
             terms) to add them to the query.
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.MultiPhraseQuery.Slop" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiPhraseQuery.Add(Lucene.Net.Index.Term[],System.Int32)" -->
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetTermArrays">
            <summary>
            Returns a List of the terms in the multiphrase.
            Do not modify the List or its contents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetPositions">
            <summary>
            Returns the relative positions of terms in this phrase.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiPhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.UnionDocsAndPositionsEnum">
            <summary>
            Takes the logical union of multiple DocsEnum iterators.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.UnionDocsAndPositionsEnum.Int32Queue">
            <summary>
            NOTE: This was IntQueue in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery" -->
        <member name="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod">
            <summary>
            Abstract class that defines how the query is rewritten. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiTermQuery.RewriteMethod.GetTermsEnum(Lucene.Net.Search.MultiTermQuery,Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_FILTER_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.MultiTermQuery.SCORING_BOOLEAN_QUERY_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiTermQuery.TopTermsScoringBooleanQueryRewrite.#ctor(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.MultiTermQuery.TopTermsBoostOnlyBooleanQueryRewrite.#ctor(System.Int32)" -->
        <member name="T:Lucene.Net.Search.MultiTermQuery.ConstantScoreAutoRewrite">
            <summary>
            A rewrite method that tries to pick the best
             constant-score rewrite method based on term and
             document counts from the query.  If both the number of
             terms and documents is small enough, then {@link
             #CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE} is used.
             Otherwise, <seealso cref="!:#CONSTANT_SCORE_FILTER_REWRITE"/> is
             used.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.MultiTermQuery.CONSTANT_SCORE_AUTO_REWRITE_DEFAULT">
            <summary>
            Read-only default instance of {@link
             ConstantScoreAutoRewrite}, with {@link
             ConstantScoreAutoRewrite#setTermCountCutoff} set to
             {@link
             ConstantScoreAutoRewrite#DEFAULT_TERM_COUNT_CUTOFF}
             and {@link
             ConstantScoreAutoRewrite#setDocCountPercent} set to
             {@link
             ConstantScoreAutoRewrite#DEFAULT_DOC_COUNT_PERCENT}.
             Note that you cannot alter the configuration of this
             instance; you'll need to create a private instance
             instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.#ctor(System.String)">
            <summary>
            Constructs a query matching terms that cannot be represented with a single
            Term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQuery.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms,Lucene.Net.Util.AttributeSource)">
            <summary>
            Construct the enumeration to be used, expanding the
             pattern term.  this method should only be called if
             the field exists (ie, implementations can assume the
             field does exist).  this method should not return null
             (should instead return <seealso cref="!:TermsEnum#EMPTY"/> if no
             terms match).  The TermsEnum must already be
             positioned to the first matching term.
            The given <seealso cref="T:Lucene.Net.Util.AttributeSource"/> is passed by the <seealso cref="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod"/> to
            provide attributes, the rewrite method uses to inform about e.g. maximum competitive boosts.
            this is currently only used by <seealso cref="!:TopTermsRewrite"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.GetTermsEnum(Lucene.Net.Index.Terms)">
            <summary>
            Convenience method, if no attributes are needed:
            this simply passes empty attributes and is equal to:
            <code>getTermsEnum(terms, new AttributeSource())</code>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQuery.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            To rewrite to a simpler form, instead return a simpler
            enum from <seealso cref="!:#getTermsEnum(Terms, AttributeSource)"/>.  For example,
            to rewrite to a single term, return a <seealso cref="!:SingleTermsEnum"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQuery.MultiTermRewriteMethod">
            <summary>
            Gets or Sets the rewrite method to be used when executing the
            query.  You can use one of the four core methods, or
            implement your own subclass of <see cref="T:Lucene.Net.Search.MultiTermQuery.RewriteMethod"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.MultiTermQueryWrapperFilter`1" -->
        <member name="M:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.#ctor(`0)">
            <summary>
            Wrap a <seealso cref="T:Lucene.Net.Search.MultiTermQuery"/> as a Filter.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.Field">
            <summary>
            Returns the field name for this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.MultiTermQueryWrapperFilter`1.GetDocIdSet(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)">
            <summary>
            Returns a DocIdSet with documents that should be permitted in search
            results.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.NGramPhraseQuery">
             <summary>
             this is a <seealso cref="T:Lucene.Net.Search.PhraseQuery"/> which is optimized for n-gram phrase query.
             For example, when you query "ABCD" on a 2-gram field, you may want to use
             NGramPhraseQuery rather than <seealso cref="T:Lucene.Net.Search.PhraseQuery"/>, because NGramPhraseQuery
             will <seealso cref="!:#rewrite(IndexReader)"/> the query to "AB/0 CD/2", while <seealso cref="T:Lucene.Net.Search.PhraseQuery"/>
             will query "AB/0 BC/1 CD/2" (where term/position).
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.#ctor(System.Int32)">
            <summary>
            Constructor that takes gram size. </summary>
            <param name="n"> n-gram size </param>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.NGramPhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.NumericRangeFilter`1" -->
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.IncludesMin">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.IncludesMax">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.Min">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.Max">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeFilter`1.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt64Range(System.String,System.Int32,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>long</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt64Range(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>long</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt32Range(System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>int</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewInt32Range(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>int</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewDoubleRange(System.String,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>double</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>double</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewSingleRange(System.String,System.Int32,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that filters a <code>float</code>
            range using the given <a href="NumericRangeQuery.html#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeFilter.NewSingleRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeFilter</code>, that queries a <code>float</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.NumericRangeQuery`1" -->
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.IncludesMin">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.IncludesMax">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.Min">
            <summary>
            Returns the lower value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.Max">
            <summary>
            Returns the upper value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.NumericRangeQuery`1.PrecisionStep">
            <summary>
            Returns the precision step. </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT64_NEGATIVE_INFINITY">
            <summary>
            NOTE: This was LONG_NEGATIVE_INFINITY in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT64_POSITIVE_INFINITY">
            <summary>
            NOTE: This was LONG_NEGATIVE_INFINITY in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT32_NEGATIVE_INFINITY">
            <summary>
            NOTE: This was INT_NEGATIVE_INFINITY in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.NumericRangeQuery`1.INT32_POSITIVE_INFINITY">
            <summary>
            NOTE: This was INT_POSITIVE_INFINITY in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.NumericRangeQuery`1.NumericRangeTermsEnum" -->
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt64Range(System.String,System.Int32,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>long</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt64Range(System.String,System.Nullable{System.Int64},System.Nullable{System.Int64},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>long</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt32Range(System.String,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>int</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewInt32Range(System.String,System.Nullable{System.Int32},System.Nullable{System.Int32},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>int</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>. By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewDoubleRange(System.String,System.Int32,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>double</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewDoubleRange(System.String,System.Nullable{System.Double},System.Nullable{System.Double},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>double</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Double#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Double.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewSingleRange(System.String,System.Int32,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>float</code>
            range using the given <a href="#precisionStepDesc"><code>precisionStep</code></a>.
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.NumericRangeQuery.NewSingleRange(System.String,System.Nullable{System.Single},System.Nullable{System.Single},System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a <code>NumericRangeQuery</code>, that queries a <code>float</code>
            range using the default <code>precisionStep</code> <seealso cref="!:NumericUtils#PRECISION_STEP_DEFAULT"/> (4).
            You can have half-open ranges (which are in fact &lt;/&lt;= or &gt;/&gt;= queries)
            by setting the min or max value to <code>null</code>.
            <seealso cref="!:Float#NaN"/> will never match a half-open range, to hit {@code NaN} use a query
            with {@code min == max == Float.NaN}.  By setting inclusive to false, it will
            match all documents excluding the bounds, with inclusive on, the boundaries are hits, too.
            <para/>
            NOTE: This was newFloatRange() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.PhrasePositions">
            <summary>
            Position of a term in a document that takes into account the term offset within the phrase.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.NextPosition">
            <summary>
            Go to next location of this term current document, and set
            <code>position</code> as <code>location - offset</code>, so that a
            matching exact phrase is easily identified when all PhrasePositions
            have exactly the same <code>position</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhrasePositions.ToString">
            <summary>
            for debug purposes </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PhraseQuery" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.#ctor">
            <summary>
            Constructs an empty phrase query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.PhraseQuery.Slop" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term)">
            <summary>
            Adds a term to the end of the query phrase.
            The relative position of the term is the one immediately after the last term added.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Add(Lucene.Net.Index.Term,System.Int32)">
             <summary>
             Adds a term to the end of the query phrase.
             The relative position of the term within the phrase is specified explicitly.
             this allows e.g. phrases with more than one term at the same position
             or phrases with gaps (e.g. in connection with stopwords).
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetTerms">
            <summary>
            Returns the set of terms in this phrase. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetPositions">
            <summary>
            Returns the relative positions of terms in this phrase.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.PhraseQuery.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})" -->
        <member name="M:Lucene.Net.Search.PhraseQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PhraseQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PositiveScoresOnlyCollector">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.ICollector"/> implementation which wraps another
            <seealso cref="T:Lucene.Net.Search.ICollector"/> and makes sure only documents with
            scores &gt; 0 are collected.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixFilter">
            <summary>
            A Filter that restricts search results to values that have a matching prefix in a given
            field.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixFilter.ToString">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.PrefixQuery" -->
        <member name="M:Lucene.Net.Search.PrefixQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms starting with <code>prefix</code>. </summary>
        </member>
        <member name="P:Lucene.Net.Search.PrefixQuery.Prefix">
            <summary>
            Returns the prefix of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.PrefixQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.PrefixTermsEnum">
            <summary>
            Subclass of FilteredTermEnum for enumerating all terms that match the
            specified prefix filter term.
            <p>Term enumerations are always ordered by
            <seealso cref="!:#getComparer"/>.  Each term in the enumeration is
            greater than all that precede it.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Query" -->
        <member name="P:Lucene.Net.Search.Query.Boost">
            <summary>
            Sets the boost for this query clause to <code>b</code>.  Documents
            matching this clause will (in addition to the normal weightings) have
            their score multiplied by <code>b</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ToString(System.String)">
            <summary>
            Prints a query to a string, with <code>field</code> assumed to be the
            default field and omitted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ToString">
            <summary>
            Prints a query to a string. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Query.CreateWeight(Lucene.Net.Search.IndexSearcher)" -->
        <member name="M:Lucene.Net.Search.Query.Rewrite(Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: called to re-write queries into primitive queries. For example,
            a PrefixQuery will be rewritten into a BooleanQuery that consists
            of TermQuerys.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Query.ExtractTerms(System.Collections.Generic.ISet{Lucene.Net.Index.Term})">
            <summary>
            Expert: adds all terms occurring in this query to the terms set. Only
            works if this query is in its <seealso cref="!:#rewrite rewritten"/> form.
            </summary>
            <exception cref="T:System.InvalidOperationException"> if this query is not yet rewritten </exception>
        </member>
        <member name="M:Lucene.Net.Search.Query.Clone">
            <summary>
            Returns a clone of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.QueryRescorer">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.Rescorer"/> that uses a provided Query to assign
              scores to the first-pass hits.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Sole constructor, passing the 2nd pass query to
             assign scores to the 1st pass hits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.Combine(System.Single,System.Boolean,System.Single)">
            <summary>
            Implement this in a subclass to combine the first pass and
            second pass scores.  If secondPassMatches is false then
            the second pass query failed to match a hit from the
            first pass query, and you should ignore the
            secondPassScore.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.QueryRescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,Lucene.Net.Search.Query,System.Double,System.Int32)">
            <summary>
            Sugar API, calling {#rescore} using a simple linear
             combination of firstPassScore + weight * secondPassScore
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.QueryWrapperFilter" -->
        <member name="M:Lucene.Net.Search.QueryWrapperFilter.#ctor(Lucene.Net.Search.Query)">
            <summary>
            Constructs a filter which only matches documents matching
            <code>query</code>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.QueryWrapperFilter.Query">
            <summary>
            returns the inner Query </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReferenceManager`1" -->
        <member name="M:Lucene.Net.Search.ReferenceManager`1.DecRef(`0)">
            <summary>
            Decrement reference counting on the given reference. </summary>
            <exception cref="!:IOException"> if reference decrement on the given resource failed.
             </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.RefreshIfNeeded(`0)">
            <summary>
            Refresh the given reference if needed. Returns {@code null} if no refresh
            was needed, otherwise a new refreshed reference. </summary>
            <exception cref="T:System.ObjectDisposedException"> if the reference manager has been <seealso cref="!:#close() closed"/>. </exception>
            <exception cref="!:IOException"> if the refresh operation failed </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.TryIncRef(`0)">
            <summary>
            Try to increment reference counting on the given reference. Return true if
            the operation was successful. </summary>
            <exception cref="T:System.ObjectDisposedException"> if the reference manager has been <seealso cref="!:#close() closed"/>.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Acquire">
            <summary>
            Obtain the current reference. You must match every call to acquire with one
            call to <seealso cref="!:#release"/>; it's best to do so in a finally clause, and set
            the reference to {@code null} to prevent accidental usage after it has been
            released. </summary>
            <exception cref="T:System.ObjectDisposedException"> if the reference manager has been <seealso cref="!:#close() closed"/>.  </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.Dispose">
            <summary>
            <p>
            Closes this ReferenceManager to prevent future <seealso cref="!:#acquire() acquiring"/>. A
            reference manager should be closed if the reference to the managed resource
            should be disposed or the application using the <seealso cref="T:Lucene.Net.Search.ReferenceManager"/>
            is shutting down. The managed resource might not be released immediately,
            if the <seealso cref="T:Lucene.Net.Search.ReferenceManager"/> user is holding on to a previously
            <seealso cref="!:#acquire() acquired"/> reference. The resource will be released once
            when the last reference is <seealso cref="!:#release(Object) released"/>. Those
            references can still be used as if the manager was still active.
            </p>
            <p>
            Applications should not <seealso cref="!:#acquire() acquire"/> new references from this
            manager once this method has been called. <seealso cref="!:#acquire() Acquiring"/> a
            resource on a closed <seealso cref="T:Lucene.Net.Search.ReferenceManager"/> will throw an
            <seealso cref="T:System.ObjectDisposedException"/>.
            </p>
            </summary>
            <exception cref="!:IOException">
                      if the underlying reader of the current reference could not be closed </exception>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.GetRefCount(`0)">
            <summary>
            Returns the current reference count of the given reference.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AfterClose">
            <summary>
             Called after close(), so subclass can free any resources. </summary>
             <exception cref="!:IOException"> if the after close operation in a sub-class throws an <seealso cref="!:IOException"/>
             </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReferenceManager`1.MaybeRefresh" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReferenceManager`1.MaybeRefreshBlocking" -->
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AfterMaybeRefresh">
            <summary>
            Called after a refresh was attempted, regardless of
             whether a new reference was in fact created. </summary>
             <exception cref="!:IOException"> if a low level I/O exception occurs
             </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReferenceManager`1.Release(`0)" -->
        <member name="M:Lucene.Net.Search.ReferenceManager`1.AddListener(Lucene.Net.Search.ReferenceManager.IRefreshListener)">
            <summary>
            Adds a listener, to be notified when a reference is refreshed/swapped.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager`1.RemoveListener(Lucene.Net.Search.ReferenceManager.IRefreshListener)">
            <summary>
            Remove a listener added with <seealso cref="!:#addListener(RefreshListener)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ReferenceManager.IRefreshListener">
            <summary>
            Use to receive notification when a refresh has
             finished.  See <seealso cref="!:#addListener"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager.IRefreshListener.BeforeRefresh">
            <summary>
            Called right before a refresh attempt starts. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReferenceManager.IRefreshListener.AfterRefresh(System.Boolean)">
            <summary>
            Called after the attempted refresh; if the refresh
            did open a new reference then didRefresh will be true
            and <seealso cref="!:#acquire()"/> is guaranteed to return the new
            reference.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.RegexpQuery" -->
        <member name="F:Lucene.Net.Search.RegexpQuery.defaultProvider">
            <summary>
            A provider that provides no named automata
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            <p>
            By default, all regular expression features are enabled.
            </p>
            </summary>
            <param name="term"> regular expression. </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Util.Automaton.RegExpSyntax)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            </summary>
            <param name="term"> regular expression. </param>
            <param name="flags"> optional RegExp features from <see cref="T:Lucene.Net.Util.Automaton.RegExpSyntax"/> </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Util.Automaton.RegExpSyntax,Lucene.Net.Util.Automaton.IAutomatonProvider)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            </summary>
            <param name="term"> regular expression. </param>
            <param name="flags"> optional RegExp features from <see cref="T:Lucene.Net.Util.Automaton.RegExpSyntax"/> </param>
            <param name="provider"> custom AutomatonProvider for named automata </param>
        </member>
        <member name="M:Lucene.Net.Search.RegexpQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqExclScorer" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Construct a <code>ReqExclScorer</code>. </summary>
            <param name="reqScorer"> The scorer that must match, except where </param>
            <param name="exclDisi"> indicates exclusion. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.ReqExclScorer.ToNonExcluded" -->
        <member name="M:Lucene.Net.Search.ReqExclScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time. </summary>
            <returns> The score of the required scorer. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ReqOptSumScorer" -->
        <member name="F:Lucene.Net.Search.ReqOptSumScorer.reqScorer">
            <summary>
            The scorers passed from the constructor.
            These are set to null as soon as their next() or skipTo() returns false.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.#ctor(Lucene.Net.Search.Scorer,Lucene.Net.Search.Scorer)">
            <summary>
            Construct a <code>ReqOptScorer</code>. </summary>
            <param name="reqScorer"> The required scorer. this must match. </param>
            <param name="optScorer"> The optional scorer. this is used for scoring only. </param>
        </member>
        <member name="M:Lucene.Net.Search.ReqOptSumScorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> is called the first time. </summary>
            <returns> The score of the required scorer, eventually increased by the score
            of the optional scorer when it also matches the current document. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Rescorer" -->
        <member name="M:Lucene.Net.Search.Rescorer.Rescore(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.TopDocs,System.Int32)">
            <summary>
            Rescore an initial first-pass <seealso cref="T:Lucene.Net.Search.TopDocs"/>.
            </summary>
            <param name="searcher"> <seealso cref="T:Lucene.Net.Search.IndexSearcher"/> used to produce the
              first pass topDocs </param>
            <param name="firstPassTopDocs"> Hits from the first pass
              search.  It's very important that these hits were
              produced by the provided searcher; otherwise the doc
              IDs will not match! </param>
            <param name="topN"> How many re-scored hits to return </param>
        </member>
        <member name="M:Lucene.Net.Search.Rescorer.Explain(Lucene.Net.Search.IndexSearcher,Lucene.Net.Search.Explanation,System.Int32)">
            <summary>
            Explains how the score for the specified document was
            computed.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ScoreCachingWrappingScorer" -->
        <member name="M:Lucene.Net.Search.ScoreCachingWrappingScorer.#ctor(Lucene.Net.Search.Scorer)">
            <summary>
            Creates a new instance by wrapping the given scorer. </summary>
        </member>
        <member name="T:Lucene.Net.Search.ScoreDoc">
            <summary>
            Holds one hit in <seealso cref="T:Lucene.Net.Search.TopDocs"/>. </summary>
        </member>
        <member name="P:Lucene.Net.Search.ScoreDoc.Score">
            <summary>
            The score of this document for the query. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.ScoreDoc.Doc" -->
        <member name="P:Lucene.Net.Search.ScoreDoc.ShardIndex">
            <summary>
            Only set by <seealso cref="!:TopDocs#merge"/> </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single)">
            <summary>
            Constructs a ScoreDoc. </summary>
        </member>
        <member name="M:Lucene.Net.Search.ScoreDoc.#ctor(System.Int32,System.Single,System.Int32)">
            <summary>
            Constructs a ScoreDoc. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Scorer" -->
        <member name="F:Lucene.Net.Search.Scorer.m_weight">
            <summary>
            the Scorer's parent Weight. in some cases this may be null </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.#ctor(Lucene.Net.Search.Weight)">
            <summary>
            Constructs a Scorer </summary>
            <param name="weight"> The scorers <code>Weight</code>. </param>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetScore">
            <summary>
            Returns the score of the current document matching the query.
            Initially invalid, until <seealso cref="!:#nextDoc()"/> or <seealso cref="!:#advance(int)"/>
            is called the first time, or when called from within
            <seealso cref="!:ICollector#collect"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.Weight">
            <summary>
            returns parent Weight
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Scorer.GetChildren">
            <summary>
            Returns child sub-scorers
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Scorer.ChildScorer">
            <summary>
            A child Scorer and its relationship to its parent.
            the meaning of the relationship depends upon the parent query.
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.ChildScorer.Child">
            <summary>
            Child Scorer. (note this is typically a direct child, and may
            itself also have children).
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Scorer.ChildScorer.Relationship">
            <summary>
            An arbitrary string relating this scorer to the parent.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Scorer.ChildScorer.#ctor(Lucene.Net.Search.Scorer,System.String)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.ScoringRewrite`1" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.ScoringRewrite`1.SCORING_BOOLEAN_QUERY_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.ScoringRewrite`1.CONSTANT_SCORE_BOOLEAN_QUERY_REWRITE" -->
        <member name="M:Lucene.Net.Search.ScoringRewrite`1.CheckMaxClauseCount(System.Int32)">
            <summary>
            this method is called after every new term to check if the number of max clauses
            (e.g. in BooleanQuery) is not exceeded. Throws the corresponding <seealso cref="!:RuntimeException"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.ScoringRewrite`1.TermFreqBoostByteStart">
            <summary>
            Special implementation of BytesStartArray that keeps parallel arrays for boost and docFreq </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SearcherFactory" -->
        <member name="M:Lucene.Net.Search.SearcherFactory.NewSearcher(Lucene.Net.Index.IndexReader)">
            <summary>
            Returns a new IndexSearcher over the given reader.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager">
             <summary>
             Keeps track of current plus old IndexSearchers, closing
             the old ones once they have timed out.
            
             Use it like this:
            
             <pre class="prettyprint">
               SearcherLifetimeManager mgr = new SearcherLifetimeManager();
             </pre>
            
             Per search-request, if it's a "new" search request, then
             obtain the latest searcher you have (for example, by
             using <seealso cref="T:Lucene.Net.Search.SearcherManager"/>), and then record this
             searcher:
            
             <pre class="prettyprint">
               // Record the current searcher, and save the returend
               // token into user's search results (eg as a  hidden
               // HTML form field):
               long token = mgr.record(searcher);
             </pre>
            
             When a follow-up search arrives, for example the user
             clicks next page, drills down/up, etc., take the token
             that you saved from the previous search and:
            
             <pre class="prettyprint">
               // If possible, obtain the same searcher as the last
               // search:
               IndexSearcher searcher = mgr.acquire(token);
               if (searcher != null) {
                 // Searcher is still here
                 try {
                   // do searching...
                 } finally {
                   mgr.release(searcher);
                   // Do not use searcher after this!
                   searcher = null;
                 }
               } else {
                 // Searcher was pruned -- notify user session timed
                 // out, or, pull fresh searcher again
               }
             </pre>
            
             Finally, in a separate thread, ideally the same thread
             that's periodically reopening your searchers, you should
             periodically prune old searchers:
            
             <pre class="prettyprint">
               mgr.prune(new PruneByAge(600.0));
             </pre>
            
             <p><b>NOTE</b>: keeping many searchers around means
             you'll use more resources (open files, RAM) than a single
             searcher.  However, as long as you are using {@link
             DirectoryReader#openIfChanged(DirectoryReader)}, the searchers
             will usually share almost all segments and the added resource usage
             is contained.  When a large merge has completed, and
             you reopen, because that is a large change, the new
             searcher will use higher additional RAM than other
             searchers; but large merges don't complete very often and
             it's unlikely you'll hit two of them in your expiration
             window.  Still you should budget plenty of heap in the
             JVM to have a good safety margin.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Record(Lucene.Net.Search.IndexSearcher)">
             <summary>
             Records that you are now using this IndexSearcher.
              Always call this when you've obtained a possibly new
              <seealso cref="T:Lucene.Net.Search.IndexSearcher"/>, for example from {@link
              SearcherManager}.  It's fine if you already passed the
              same searcher to this method before.
            
              <p>this returns the long token that you can later pass
              to <seealso cref="!:#acquire"/> to retrieve the same IndexSearcher.
              You should record this long token in the search results
              sent to your user, such that if the user performs a
              follow-on action (clicks next page, drills down, etc.)
              the token is returned.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.Acquire(System.Int64)">
             <summary>
             Retrieve a previously recorded <seealso cref="T:Lucene.Net.Search.IndexSearcher"/>, if it
              has not yet been closed
            
              <p><b>NOTE</b>: this may return null when the
              requested searcher has already timed out.  When this
              happens you should notify your user that their session
              timed out and that they'll have to restart their
              search.</p>
            
              <p>If this returns a non-null result, you must match
              later call <seealso cref="!:#release"/> on this searcher, best
              from a finally clause.</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SearcherLifetimeManager.Release(Lucene.Net.Search.IndexSearcher)" -->
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager.IPruner">
            <summary>
            See <seealso cref="!:#prune"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.SearcherLifetimeManager.IPruner.DoPrune(System.Double,Lucene.Net.Search.IndexSearcher)">
            <summary>
            Return true if this searcher should be removed. </summary>
             <param name="ageSec"> how much time has passed since this
                    searcher was the current (live) searcher </param>
             <param name="searcher"> Searcher
             </param>
        </member>
        <member name="T:Lucene.Net.Search.SearcherLifetimeManager.PruneByAge">
            <summary>
            Simple pruner that drops any searcher older by
             more than the specified seconds, than the newest
             searcher.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SearcherLifetimeManager.Prune(Lucene.Net.Search.SearcherLifetimeManager.IPruner)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SearcherLifetimeManager.Dispose" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SearcherManager" -->
        <member name="M:Lucene.Net.Search.SearcherManager.#ctor(Lucene.Net.Index.IndexWriter,System.Boolean,Lucene.Net.Search.SearcherFactory)">
            <summary>
            Creates and returns a new SearcherManager from the given
            <seealso cref="T:Lucene.Net.Index.IndexWriter"/>.
            </summary>
            <param name="writer">
                     the IndexWriter to open the IndexReader from. </param>
            <param name="applyAllDeletes">
                     If <code>true</code>, all buffered deletes will be applied (made
                     visible) in the <seealso cref="T:Lucene.Net.Search.IndexSearcher"/> / <seealso cref="T:Lucene.Net.Index.DirectoryReader"/>.
                     If <code>false</code>, the deletes may or may not be applied, but
                     remain buffered (in IndexWriter) so that they will be applied in
                     the future. Applying deletes can be costly, so if your app can
                     tolerate deleted documents being returned you might gain some
                     performance by passing <code>false</code>. See
                     <seealso cref="!:DirectoryReader#openIfChanged(DirectoryReader, IndexWriter, boolean)"/>. </param>
            <param name="searcherFactory">
                     An optional <see cref="T:Lucene.Net.Search.SearcherFactory"/>. Pass <code>null</code> if you
                     don't require the searcher to be warmed before going live or other
                     custom behavior.
            </param>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Search.SearcherManager.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Search.SearcherFactory)">
            <summary>
            Creates and returns a new SearcherManager from the given <seealso cref="T:Lucene.Net.Store.Directory"/>. </summary>
            <param name="dir"> the directory to open the DirectoryReader on. </param>
            <param name="searcherFactory"> An optional <see cref="T:Lucene.Net.Search.SearcherFactory"/>. Pass
                   <code>null</code> if you don't require the searcher to be warmed
                   before going live or other custom behavior.
            </param>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SearcherManager.IsSearcherCurrent" -->
        <member name="M:Lucene.Net.Search.SearcherManager.GetSearcher(Lucene.Net.Search.SearcherFactory,Lucene.Net.Index.IndexReader)">
            <summary>
            Expert: creates a searcher from the provided {@link
             IndexReader} using the provided {@link
             SearcherFactory}.  NOTE: this decRefs incoming reader
            on throwing an exception.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.PhraseFreq" -->
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.AdvancePP(Lucene.Net.Search.PhrasePositions)">
            <summary>
            advance a PhrasePosition and update 'end', return false if exhausted </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.AdvanceRpts(Lucene.Net.Search.PhrasePositions)">
            <summary>
            pp was just advanced. If that caused a repeater collision, resolve by advancing the lesser
            of the two colliding pps. Note that there can only be one collision, as by the initialization
            there were no collisions before pp was advanced.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.Lesser(Lucene.Net.Search.PhrasePositions,Lucene.Net.Search.PhrasePositions)">
            <summary>
            compare two pps, but only by position and offset </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.Collide(Lucene.Net.Search.PhrasePositions)">
            <summary>
            index of a pp2 colliding with pp, or -1 if none </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.InitPhrasePositions" -->
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitSimple">
            <summary>
            no repeats: simplest case, and most common. It is important to keep this piece of the code simple and efficient </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.InitComplex">
            <summary>
            with repeats: not so simple. </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.PlaceFirstPositions">
            <summary>
            move all PPs to their first position </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.FillQueue">
            <summary>
            Fill the queue (all pps are already placed </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.AdvanceRepeatGroups" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.SloppyPhraseScorer.InitFirstTime" -->
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.SortRptGroups(System.Collections.Generic.IList{System.Collections.Generic.IList{Lucene.Net.Search.PhrasePositions}})">
            <summary>
            sort each repetition group by (query) offset.
            Done only once (at first doc) and allows to initialize faster for each doc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.GatherRptGroups(Lucene.Net.Support.LinkedHashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            Detect repetition groups. Done once - for first doc </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.TpPos(Lucene.Net.Search.PhrasePositions)">
            <summary>
            Actual position in doc of a PhrasePosition, relies on that position = tpPos - offset) </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.RepeatingTerms">
            <summary>
            find repeating terms and assign them ordinal values </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.RepeatingPPs(Lucene.Net.Support.HashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            find repeating pps, and for each, if has multi-terms, update this.hasMultiTermRpts </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.PpTermsBitSets(Lucene.Net.Search.PhrasePositions[],Lucene.Net.Support.HashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}})">
            <summary>
            bit-sets - for each repeating pp, for each of its repeating terms, the term ordinal values is set </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.UnionTermGroups(System.Collections.Generic.IList{Lucene.Net.Util.FixedBitSet})">
            <summary>
            union (term group) bit-sets until they are disjoint (O(n^^2)), and each group have different terms </summary>
        </member>
        <member name="M:Lucene.Net.Search.SloppyPhraseScorer.TermGroups(Lucene.Net.Support.LinkedHashMap{Lucene.Net.Index.Term,System.Nullable{System.Int32}},System.Collections.Generic.IList{Lucene.Net.Util.FixedBitSet})">
            <summary>
            map each term to the single group that contains it </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Sort" -->
        <member name="F:Lucene.Net.Search.Sort.RELEVANCE">
            <summary>
            Represents sorting by computed relevance. Using this sort criteria returns
            the same results as calling
            <seealso cref="!:IndexSearcher#search(Query,int) IndexSearcher#search()"/>without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Sort.INDEXORDER">
            <summary>
            Represents sorting by index order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor">
            <summary>
            Sorts by computed relevance. this is the same sort criteria as calling
            <seealso cref="!:IndexSearcher#search(Query,int) IndexSearcher#search()"/>without a sort criteria,
            only with slightly more overhead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField)">
            <summary>
            Sorts by the criteria in the given SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.#ctor(Lucene.Net.Search.SortField[])">
            <summary>
            Sorts in succession by the criteria in each SortField. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField)">
            <summary>Sets the sort to the given criteria. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.SetSort(Lucene.Net.Search.SortField[])">
            <summary>Sets the sort to the given criteria in succession. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetSort">
            <summary> Representation of the sort criteria.</summary>
            <returns> Array of SortField objects used in this sort criteria
            </returns>
        </member>
        <member name="M:Lucene.Net.Search.Sort.Rewrite(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Rewrites the SortFields in this Sort, returning a new Sort if any of the fields
            changes during their rewriting.
            </summary>
            <param name="searcher"> IndexSearcher to use in the rewriting </param>
            <returns> {@code this} if the Sort/Fields have not changed, or a new Sort if there
                   is a change </returns>
            <exception cref="!:IOException"> Can be thrown by the rewriting
            @lucene.experimental </exception>
        </member>
        <member name="M:Lucene.Net.Search.Sort.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Sort.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Sort.NeedsScores">
            <summary>
            Returns true if the relevance score is needed to sort documents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.SortField" -->
        <member name="F:Lucene.Net.Search.SortField.FIELD_SCORE">
            <summary>
            Represents sorting by document score (relevance). </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.FIELD_DOC">
            <summary>
            Represents sorting by document number (index order). </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortFieldType)">
            <summary>
            Creates a sort by terms in the given field with the type of term
            values explicitly given. </summary>
            <param name="field">  Name of field to sort by.  Can be <code>null</code> if
                          <code>type</code> is SCORE or DOC. </param>
            <param name="type">   Type of values in the terms. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.SortFieldType,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, by terms in the given field with the
            type of term values explicitly given. </summary>
            <param name="field">  Name of field to sort by.  Can be <code>null</code> if
                          <code>type</code> is SCORE or DOC. </param>
            <param name="type">   Type of values in the terms. </param>
            <param name="reverse"> True if natural order should be reversed. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldCache.IParser)">
            <summary>
            Creates a sort by terms in the given field, parsed
            to numeric values using a custom <seealso cref="!:IFieldCache.Parser"/>. </summary>
            <param name="field">  Name of field to sort by.  Must not be null. </param>
            <param name="parser"> Instance of a <seealso cref="!:IFieldCache.Parser"/>,
             which must subclass one of the existing numeric
             parsers from <seealso cref="T:Lucene.Net.Search.IFieldCache"/>. Sort type is inferred
             by testing which numeric parser the parser subclasses. </param>
            <exception cref="!:IllegalArgumentException"> if the parser fails to
             subclass an existing numeric parser, or field is null </exception>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldCache.IParser,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, by terms in the given field, parsed
            to numeric values using a custom <seealso cref="!:IFieldCache.Parser"/>. </summary>
            <param name="field">  Name of field to sort by.  Must not be null. </param>
            <param name="parser"> Instance of a <seealso cref="!:IFieldCache.Parser"/>,
             which must subclass one of the existing numeric
             parsers from <seealso cref="T:Lucene.Net.Search.IFieldCache"/>. Sort type is inferred
             by testing which numeric parser the parser subclasses. </param>
            <param name="reverse"> True if natural order should be reversed. </param>
            <exception cref="!:IllegalArgumentException"> if the parser fails to
             subclass an existing numeric parser, or field is null </exception>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING_FIRST">
            <summary>
            Pass this to <seealso cref="!:#setMissingValue"/> to have missing
             string values sort first.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortField.STRING_LAST">
            <summary>
            Pass this to <seealso cref="!:#setMissingValue"/> to have missing
             string values sort last.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldComparerSource)">
            <summary>
            Creates a sort with a custom comparison function. </summary>
            <param name="field"> Name of field to sort by; cannot be <code>null</code>. </param>
            <param name="comparer"> Returns a comparer for sorting hits. </param>
        </member>
        <member name="M:Lucene.Net.Search.SortField.#ctor(System.String,Lucene.Net.Search.FieldComparerSource,System.Boolean)">
            <summary>
            Creates a sort, possibly in reverse, with a custom comparison function. </summary>
            <param name="field"> Name of field to sort by; cannot be <code>null</code>. </param>
            <param name="comparer"> Returns a comparer for sorting hits. </param>
            <param name="reverse"> True if natural order should be reversed. </param>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Field">
            <summary>
            Returns the name of the field.  Could return <code>null</code>
            if the sort is by SCORE or DOC. </summary>
            <returns> Name of field, possibly <code>null</code>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Type">
            <summary>
            Returns the type of contents in the field. </summary>
            <returns> One of <see cref="F:Lucene.Net.Search.SortFieldType.SCORE"/>, <see cref="F:Lucene.Net.Search.SortFieldType.DOC"/>, 
            <see cref="F:Lucene.Net.Search.SortFieldType.STRING"/>, <see cref="F:Lucene.Net.Search.SortFieldType.INT32"/> or <see cref="F:Lucene.Net.Search.SortFieldType.SINGLE"/>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.Parser">
            <summary>
            Returns the instance of a <seealso cref="T:Lucene.Net.Search.IFieldCache"/> parser that fits to the given sort type.
            May return <code>null</code> if no parser was specified. Sorting is using the default parser then. </summary>
            <returns> An instance of a <seealso cref="T:Lucene.Net.Search.IFieldCache"/> parser, or <code>null</code>. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.IsReverse">
            <summary>
            Returns whether the sort should be reversed. </summary>
            <returns>  True if natural order should be reversed. </returns>
        </member>
        <member name="P:Lucene.Net.Search.SortField.ComparerSource">
            <summary>
            Returns the <seealso cref="T:Lucene.Net.Search.FieldComparerSource"/> used for
            custom sorting
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.Equals(System.Object)">
            <summary>
            Returns true if <code>o</code> is equal to this.  If a
             <seealso cref="T:Lucene.Net.Search.FieldComparerSource"/> or {@link
             FieldCache.Parser} was provided, it must properly
             implement equals (unless a singleton is always used).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetHashCode">
            <summary>
            Returns true if <code>o</code> is equal to this.  If a
             <seealso cref="T:Lucene.Net.Search.FieldComparerSource"/> or {@link
             FieldCache.Parser} was provided, it must properly
             implement hashCode (unless a singleton is always
             used).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortField.GetComparer(System.Int32,System.Int32)">
             <summary>
             Returns the <seealso cref="T:Lucene.Net.Search.FieldComparer"/> to use for
             sorting.
            
             @lucene.experimental
             </summary>
             <param name="numHits"> number of top hits the queue will store </param>
             <param name="sortPos"> position of this SortField within {@link
               Sort}.  The comparer is primary if sortPos==0,
               secondary if sortPos==1, etc.  Some comparers can
               optimize themselves when they are the primary sort. </param>
             <returns> <seealso cref="T:Lucene.Net.Search.FieldComparer"/> to use when sorting </returns>
        </member>
        <member name="M:Lucene.Net.Search.SortField.Rewrite(Lucene.Net.Search.IndexSearcher)">
            <summary>
            Rewrites this SortField, returning a new SortField if a change is made.
            Subclasses should override this define their rewriting behavior when this
            SortField is of type <seealso cref="!:SortField.Type#REWRITEABLE"/>
            </summary>
            <param name="searcher"> IndexSearcher to use during rewriting </param>
            <returns> New rewritten SortField, or {@code this} if nothing has changed. </returns>
            <exception cref="!:IOException"> Can be thrown by the rewriting
            @lucene.experimental </exception>
        </member>
        <member name="P:Lucene.Net.Search.SortField.NeedsScores">
            <summary>
            Whether the relevance score is needed to sort documents. </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortFieldType">
            <summary>
            Specifies the type of the terms to be sorted, or special types such as CUSTOM
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.SCORE">
            <summary>
            Sort by document score (relevance).  Sort values are Float and higher
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.DOC">
            <summary>
            Sort by document number (index order).  Sort values are Integer and lower
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.STRING">
            <summary>
            Sort using term values as Strings.  Sort values are String and lower
            values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.INT32">
            <summary>
            Sort using term values as encoded Integers.  Sort values are Integer and
            lower values are at the front.
            <para/>
            NOTE: This was INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.SINGLE">
            <summary>
            Sort using term values as encoded Floats.  Sort values are Float and
            lower values are at the front.
            <para/>
            NOTE: This was FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.INT64">
            <summary>
            Sort using term values as encoded Longs.  Sort values are Long and
            lower values are at the front.
            <para/>
            NOTE: This was LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.DOUBLE">
            <summary>
            Sort using term values as encoded Doubles.  Sort values are Double and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.INT16">
            <summary>
            Sort using term values as encoded Shorts.  Sort values are Short and
            lower values are at the front.
            <para/>
            NOTE: This was SHORT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.CUSTOM">
            <summary>
            Sort using a custom Comparer.  Sort values are any Comparable and
            sorting is done according to natural order.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.BYTE">
            <summary>
            Sort using term values as encoded Bytes.  Sort values are Byte and
            lower values are at the front.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.STRING_VAL">
            <summary>
            Sort using term values as Strings, but comparing by
            value (using String.compareTo) for all comparisons.
            this is typically slower than <seealso cref="!:#STRING"/>, which
            uses ordinals to do the sorting.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.BYTES">
            <summary>
            Sort use byte[] index values. </summary>
        </member>
        <member name="F:Lucene.Net.Search.SortFieldType.REWRITEABLE">
            <summary>
            Force rewriting of SortField using <seealso cref="!:SortField#rewrite(IndexSearcher)"/>
            before it can be used for sorting
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.SortRescorer">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.Rescorer"/> that re-sorts according to a provided
            Sort.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.SortRescorer.#ctor(Lucene.Net.Search.Sort)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.GetTopLevelQuery">
            <summary>
            Return a suitable top-level Query for holding all expanded terms. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.AddClause(`0,Lucene.Net.Index.Term,System.Int32,System.Single)">
            <summary>
            Add a MultiTermQuery term to the top-level query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.Attributes">
            <summary>
            attributes used for communication with the enum </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.Collect(Lucene.Net.Util.BytesRef)">
            <summary>
            return false to stop collecting </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermCollectingRewrite`1.TermCollector.SetNextEnum(Lucene.Net.Index.TermsEnum)">
            <summary>
            the next segment's <seealso cref="T:Lucene.Net.Index.TermsEnum"/> that is used to collect terms </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermQuery">
            <summary>
            A Query that matches documents containing a term.
             this may be combined with other terms with a <seealso cref="T:Lucene.Net.Search.BooleanQuery"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.TermWeight.GetTermsEnum(Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Index.TermsEnum"/> positioned at this weights Term or null if
            the term does not exist in the given context
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for the term <code>t</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term,System.Int32)">
            <summary>
            Expert: constructs a TermQuery that will use the
             provided docFreq instead of looking up the docFreq
             against the searcher.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.#ctor(Lucene.Net.Index.Term,Lucene.Net.Index.TermContext)">
            <summary>
            Expert: constructs a TermQuery that will use the
             provided docFreq instead of looking up the docFreq
             against the searcher.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermQuery.Term">
            <summary>
            Returns the term of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermQuery.GetHashCode">
            <summary>
            Returns a hash code value for this object. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TermRangeFilter" -->
        <member name="M:Lucene.Net.Search.TermRangeFilter.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
            <param name="fieldName"> The field this range applies to </param>
            <param name="lowerTerm"> The lower bound on this range </param>
            <param name="upperTerm"> The upper bound on this range </param>
            <param name="includeLower"> Does this range include the lower bound? </param>
            <param name="includeUpper"> Does this range include the upper bound? </param>
            <exception cref="!:IllegalArgumentException"> if both terms are null or if
             lowerTerm is null and includeLower is true (similar for upperTerm
             and includeUpper) </exception>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a new TermRangeFilter using Strings for term text.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.Less(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Constructs a filter for field <code>fieldName</code> matching
            less than or equal to <code>upperTerm</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeFilter.More(System.String,Lucene.Net.Util.BytesRef)">
            <summary>
            Constructs a filter for field <code>fieldName</code> matching
            greater than or equal to <code>lowerTerm</code>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.LowerTerm">
            <summary>
            Returns the lower value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.UpperTerm">
            <summary>
            Returns the upper value of this range filter </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeFilter.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TermRangeQuery" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermRangeQuery.#ctor(System.String,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)" -->
        <member name="M:Lucene.Net.Search.TermRangeQuery.NewStringRange(System.String,System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Factory that creates a new TermRangeQuery using Strings for term text.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.LowerTerm">
            <summary>
            Returns the lower value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.UpperTerm">
            <summary>
            Returns the upper value of this range query </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.IncludesLower">
            <summary>
            Returns <code>true</code> if the lower endpoint is inclusive </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermRangeQuery.IncludesUpper">
            <summary>
            Returns <code>true</code> if the upper endpoint is inclusive </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermRangeTermsEnum">
            <summary>
            Subclass of FilteredTermEnum for enumerating all terms that match the
            specified range parameters.
            <p>Term enumerations are always ordered by
            <seealso cref="!:#getComparer"/>.  Each term in the enumeration is
            greater than all that precede it.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TermRangeTermsEnum.#ctor(Lucene.Net.Index.TermsEnum,Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef,System.Boolean,System.Boolean)">
             <summary>
             Enumerates all terms greater/equal than <code>lowerTerm</code>
             but less/equal than <code>upperTerm</code>.
            
             If an endpoint is null, it is said to be "open". Either or both
             endpoints may be open.  Open endpoints may not be exclusive
             (you can't select all but the first or last term without
             explicitly specifying the term to exclude.)
             </summary>
             <param name="tenum">
                      TermsEnum to filter </param>
             <param name="lowerTerm">
                      The term text at the lower end of the range </param>
             <param name="upperTerm">
                      The term text at the upper end of the range </param>
             <param name="includeLower">
                      If true, the <code>lowerTerm</code> is included in the range. </param>
             <param name="includeUpper">
                      If true, the <code>upperTerm</code> is included in the range. </param>
        </member>
        <member name="T:Lucene.Net.Search.TermScorer">
            <summary>
            Expert: A <code>Scorer</code> for documents matching a <code>Term</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.#ctor(Lucene.Net.Search.Weight,Lucene.Net.Index.DocsEnum,Lucene.Net.Search.Similarities.Similarity.SimScorer)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.NextDoc" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TermScorer.Advance(System.Int32)" -->
        <member name="M:Lucene.Net.Search.TermScorer.ToString">
            <summary>
            Returns a string representation of this <code>TermScorer</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Search.TermStatistics">
            <summary>
            Contains statistics for a specific term
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TermStatistics.Term">
            <summary>
            returns the term text </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.TermStatistics.DocFreq" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.TermStatistics.TotalTermFreq" -->
        <member name="T:Lucene.Net.Search.TimeLimitingCollector">
            <summary>
            The <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector"/> is used to timeout search requests that
            take longer than the maximum allowed search time limit. After this time is
            exceeded, the search thread is stopped by throwing a
            <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException">
            <summary>
            Thrown when elapsed search time exceeds allowed search time. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.TimeAllowed">
            <summary>
            Returns allowed time (milliseconds). </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.TimeElapsed">
            <summary>
            Returns elapsed time (milliseconds). </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException.LastDocCollected">
            <summary>
            Returns last doc (absolute doc id) that was collected when the search time exceeded. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.#ctor(Lucene.Net.Search.ICollector,Lucene.Net.Util.Counter,System.Int64)">
            <summary>
            Create a TimeLimitedCollector wrapper over another <seealso cref="T:Lucene.Net.Search.ICollector"/> with a specified timeout. </summary>
            <param name="collector"> the wrapped <seealso cref="T:Lucene.Net.Search.ICollector"/> </param>
            <param name="clock"> the timer clock </param>
            <param name="ticksAllowed"> max time allowed for collecting
            hits after which <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException"/> is thrown </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TimeLimitingCollector.SetBaseline(System.Int64)" -->
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.SetBaseline">
            <summary>
            Syntactic sugar for <seealso cref="!:#setBaseline(long)"/> using <seealso cref="!:Counter#get()"/>
            on the clock passed to the constructor.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.TimeLimitingCollector.IsGreedy" -->
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.Collect(System.Int32)">
            <summary>
            Calls <seealso cref="!:ICollector#collect(int)"/> on the decorated <seealso cref="T:Lucene.Net.Search.ICollector"/>
            unless the allowed time has passed, in which case it throws an exception.
            </summary>
            <exception cref="T:Lucene.Net.Search.TimeLimitingCollector.TimeExceededException">
                      if the time allowed has exceeded. </exception>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.SetCollector(Lucene.Net.Search.ICollector)">
            <summary>
            this is so the same timer can be used with a multi-phase search process such as grouping.
            We don't want to create a new TimeLimitingCollector for each phase because that would
            reset the timer for each phase.  Once time is up subsequent phases need to timeout quickly.
            </summary>
            <param name="collector"> The actual collector performing search functionality </param>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.GlobalCounter">
            <summary>
            Returns the global TimerThreads <seealso cref="T:Lucene.Net.Util.Counter"/>
            <p>
            Invoking this creates may create a new instance of <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> iff
            the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> has never been accessed before. The thread
            returned from this method is started on creation and will be alive unless
            you stop the <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> via <seealso cref="!:TimerThread#stopTimer()"/>.
            </p> </summary>
            <returns> the global TimerThreads <seealso cref="T:Lucene.Net.Util.Counter"/>
            @lucene.experimental </returns>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.GlobalTimerThread">
            <summary>
            Returns the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/>.
            <p>
            Invoking this creates may create a new instance of <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> iff
            the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> has never been accessed before. The thread
            returned from this method is started on creation and will be alive unless
            you stop the <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/> via <seealso cref="!:TimerThread#stopTimer()"/>.
            </p>
            </summary>
            <returns> the global <seealso cref="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread"/>
            @lucene.experimental </returns>
        </member>
        <member name="T:Lucene.Net.Search.TimeLimitingCollector.TimerThread">
            <summary>
            Thread used to timeout search requests.
            Can be stopped completely with <seealso cref="!:TimerThread#stopTimer()"/>
            @lucene.experimental
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TimeLimitingCollector.TimerThread.Milliseconds">
            <summary>
            Get the timer value in milliseconds.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TimeLimitingCollector.TimerThread.StopTimer">
            <summary>
            Stops the timer thread
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.TimeLimitingCollector.TimerThread.Resolution" -->
        <member name="T:Lucene.Net.Search.TopDocs">
            <summary>
            Represents hits returned by {@link
            IndexSearcher#search(Query,Filter,int)} and {@link
            IndexSearcher#search(Query,int)}.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocs.TotalHits">
            <summary>
            The total number of hits for the query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocs.ScoreDocs">
            <summary>
            The top hits for the query. </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocs.maxScore">
            <summary>
            Stores the maximum score value encountered, needed for normalizing. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocs.MaxScore">
            <summary>
            Returns the maximum score value encountered. Note that in case
            scores are not tracked, this returns <seealso cref="!:Float#NaN"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[])">
            <summary>
            Constructs a TopDocs with a default maxScore=Float.NaN. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,Lucene.Net.Search.TopDocs[])" -->
        <member name="M:Lucene.Net.Search.TopDocs.Merge(Lucene.Net.Search.Sort,System.Int32,System.Int32,Lucene.Net.Search.TopDocs[])">
            <summary>
            Same as <seealso cref="!:#merge(Sort, int, TopDocs[])"/> but also slices the result at the same time based
            on the provided start and size. The return TopDocs will always have a scoreDocs with length of at most size.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopDocsCollector`1" -->
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.EMPTY_TOPDOCS">
            <summary>
            this is used in case topDocs() is called with illegal parameters, or there
             simply aren't (enough) results.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.m_pq">
            <summary>
            The priority queue which holds the top documents. Note that different
            implementations of PriorityQueue give different meaning to 'top documents'.
            HitQueue for example aggregates the top scoring documents, while other PQ
            implementations may hold documents sorted by other criteria.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopDocsCollector`1.m_totalHits">
            <summary>
            The total number of documents that the collector encountered. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.PopulateResults(Lucene.Net.Search.ScoreDoc[],System.Int32)">
            <summary>
            Populates the results array with the ScoreDoc instances. this can be
            overridden in case a different ScoreDoc type should be returned.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.NewTopDocs(Lucene.Net.Search.ScoreDoc[],System.Int32)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Search.TopDocs"/> instance containing the given results. If
            <code>results</code> is null it means there are no results to return,
            either because there were 0 calls to collect() or because the arguments to
            topDocs were invalid.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocsCollector`1.TotalHits">
            <summary>
            The total number of documents that matched this query. </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopDocsCollector`1.TopDocsCount">
            <summary>
            The number of valid PQ entries 
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs">
            <summary>
            Returns the top docs that were collected by this collector. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopDocsCollector`1.GetTopDocs(System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.SetScorer(Lucene.Net.Search.Scorer)">
            <summary>
            Called before successive calls to <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>. Implementations
            that need the score of the current document (passed-in to
            <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>), should save the passed-in <see cref="T:Lucene.Net.Search.Scorer"/> and call
            scorer.Score() when needed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)">
            <summary>
            Called once for every document matching a query, with the unbased document
            number.
            <para/>Note: The collection of the current segment can be terminated by throwing
            a <see cref="T:Lucene.Net.Search.CollectionTerminatedException"/>. In this case, the last docs of the
            current <see cref="T:Lucene.Net.Index.AtomicReaderContext"/> will be skipped and <see cref="T:Lucene.Net.Search.IndexSearcher"/>
            will swallow the exception and continue collection with the next leaf.
            <para/>
            Note: this is called in an inner search loop. For good search performance,
            implementations of this method should not call <see cref="M:Lucene.Net.Search.IndexSearcher.Doc(System.Int32)"/> or
            <see cref="M:Lucene.Net.Index.IndexReader.Document(System.Int32)"/> on every hit.
            Doing so can slow searches by an order of magnitude or more.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopDocsCollector`1.SetNextReader(Lucene.Net.Index.AtomicReaderContext)">
             <summary>
             Called before collecting from each <see cref="T:Lucene.Net.Index.AtomicReaderContext"/>. All doc ids in
             <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/> will correspond to <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>.
            
             Add <see cref="!:AtomicReaderContext#docBase"/> to the current <see cref="P:Lucene.Net.Index.IndexReaderContext.Reader"/>'s
             internal document id to re-base ids in <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>.
             </summary>
             <param name="context">next atomic reader context </param>
        </member>
        <member name="P:Lucene.Net.Search.TopDocsCollector`1.AcceptsDocsOutOfOrder">
             <summary>
             Return <c>true</c> if this collector does not
             require the matching docIDs to be delivered in int sort
             order (smallest to largest) to <see cref="M:Lucene.Net.Search.TopDocsCollector`1.Collect(System.Int32)"/>.
            
             <para> Most Lucene Query implementations will visit
             matching docIDs in order.  However, some queries
             (currently limited to certain cases of <see cref="T:Lucene.Net.Search.BooleanQuery"/>) 
             can achieve faster searching if the
             <see cref="T:Lucene.Net.Search.ICollector"/> allows them to deliver the
             docIDs out of order.</para>
            
             <para> Many collectors don't mind getting docIDs out of
             order, so it's important to return <c>true</c>
             here.</para>
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.ITopDocsCollector">
            <summary>
            LUCENENET specific interface used to reference <see cref="T:Lucene.Net.Search.TopDocsCollector`1"/>
            without referencing its generic type.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.TopFieldCollector">
             <summary>
             A <seealso cref="T:Lucene.Net.Search.ICollector"/> that sorts by <seealso cref="T:Lucene.Net.Search.SortField"/> using
             <seealso cref="T:Lucene.Net.Search.FieldComparer"/>s.
             <p/>
             See the <seealso cref="!:#create(Lucene.Net.Search.Sort, int, boolean, boolean, boolean, boolean)"/> method
             for instantiating a TopFieldCollector.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.TopFieldCollector.maxScore">
            <summary>
            Stores the maximum score value encountered, needed for normalizing. If
            document scores are not tracked, this value is initialized to NaN.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopFieldCollector.Create(Lucene.Net.Search.Sort,System.Int32,Lucene.Net.Search.FieldDoc,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" -->
        <member name="T:Lucene.Net.Search.TopFieldDocs">
            <summary>
            Represents hits returned by {@link
            IndexSearcher#search(Query,Filter,int,Sort)}.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopFieldDocs.Fields">
            <summary>
            The fields which were used to sort results by. </summary>
        </member>
        <member name="M:Lucene.Net.Search.TopFieldDocs.#ctor(System.Int32,Lucene.Net.Search.ScoreDoc[],Lucene.Net.Search.SortField[],System.Single)">
            <summary>
            Creates one of these objects. </summary>
            <param name="totalHits">  Total number of hits for the query. </param>
            <param name="scoreDocs">  The top hits for the query. </param>
            <param name="fields">     The sort criteria used to find the top hits. </param>
            <param name="maxScore">   The maximum score encountered. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.TopScoreDocCollector" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopScoreDocCollector.Create(System.Int32,System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopScoreDocCollector.Create(System.Int32,Lucene.Net.Search.ScoreDoc,System.Boolean)" -->
        <member name="T:Lucene.Net.Search.TopTermsRewrite`1">
            <summary>
            Base rewrite method for collecting only the top terms
            via a priority queue.
            @lucene.internal Only public to be accessible by spans package.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.TopTermsRewrite`1.#ctor(System.Int32)" -->
        <member name="P:Lucene.Net.Search.TopTermsRewrite`1.Count">
            <summary>
            return the maximum priority queue size.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TopTermsRewrite`1.MaxSize">
            <summary>
            return the maximum size of the priority queue (for boolean rewrites this is BooleanQuery#getMaxClauseCount). </summary>
        </member>
        <member name="T:Lucene.Net.Search.TotalHitCountCollector">
            <summary>
            Just counts the total number of hits.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.TotalHitCountCollector.TotalHits">
            <summary>
            Returns how many hits matched the search. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Weight" -->
        <member name="M:Lucene.Net.Search.Weight.Explain(Lucene.Net.Index.AtomicReaderContext,System.Int32)">
            <summary>
            An explanation of the score computation for the named document.
            </summary>
            <param name="context"> the readers context to create the <seealso cref="T:Lucene.Net.Search.Explanation"/> for. </param>
            <param name="doc"> the document's id relative to the given context's reader </param>
            <returns> an Explanation for the score </returns>
            <exception cref="!:IOException"> if an <seealso cref="!:IOException"/> occurs </exception>
        </member>
        <member name="P:Lucene.Net.Search.Weight.Query">
            <summary>
            The query that this concerns. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.GetValueForNormalization">
            <summary>
            The value for normalization of contained query clauses (e.g. sum of squared weights). </summary>
        </member>
        <member name="M:Lucene.Net.Search.Weight.Normalize(System.Single,System.Single)">
            <summary>
            Assigns the query normalization factor and boost from parent queries to this. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Weight.GetScorer(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits)" -->
        <member name="M:Lucene.Net.Search.Weight.GetBulkScorer(Lucene.Net.Index.AtomicReaderContext,System.Boolean,Lucene.Net.Util.IBits)">
            <summary>
            Optional method, to return a <seealso cref="T:Lucene.Net.Search.BulkScorer"/> to
            score the query and send hits to a <seealso cref="T:Lucene.Net.Search.ICollector"/>.
            Only queries that have a different top-level approach
            need to override this; the default implementation
            pulls a normal <seealso cref="T:Lucene.Net.Search.Scorer"/> and iterates and
            collects the resulting hits.
            </summary>
            <param name="context">
                     the <seealso cref="T:Lucene.Net.Index.AtomicReaderContext"/> for which to return the <seealso cref="T:Lucene.Net.Search.Scorer"/>. </param>
            <param name="scoreDocsInOrder">
                     specifies whether in-order scoring of documents is required. Note
                     that if set to false (i.e., out-of-order scoring is required),
                     this method can return whatever scoring mode it supports, as every
                     in-order scorer is also an out-of-order one. However, an
                     out-of-order scorer may not support <seealso cref="!:Scorer#nextDoc()"/>
                     and/or <seealso cref="!:Scorer#advance(int)"/>, therefore it is recommended to
                     request an in-order scorer if use of these
                     methods is required. </param>
            <param name="acceptDocs">
                     Bits that represent the allowable docs to match (typically deleted docs
                     but possibly filtering other documents)
            </param>
            <returns> a <seealso cref="T:Lucene.Net.Search.BulkScorer"/> which scores documents and
            passes them to a collector. </returns>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Search.Weight.DefaultBulkScorer">
            <summary>
            Just wraps a Scorer and performs top scoring using it. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Weight.ScoresDocsOutOfOrder" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.WildcardQuery" -->
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_STRING">
            <summary>
            String equality with support for wildcards </summary>
        </member>
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_CHAR">
            <summary>
            Char equality with support for wildcards </summary>
        </member>
        <member name="F:Lucene.Net.Search.WildcardQuery.WILDCARD_ESCAPE">
            <summary>
            Escape character </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Constructs a query for terms matching <code>term</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.ToAutomaton(Lucene.Net.Index.Term)">
            <summary>
            Convert Lucene wildcard syntax into an automaton.
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.WildcardQuery.Term">
            <summary>
            Returns the pattern term.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.WildcardQuery.ToString(System.String)">
            <summary>
            Prints a user-readable version of this query. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.AveragePayloadFunction">
             <summary>
             Calculate the final score as the average score of all payloads seen.
             <p/>
             Is thread safe and completely reusable.
            
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.MaxPayloadFunction">
             <summary>
             Returns the maximum payload score seen, else 1 if there are no payloads on the doc.
             <p/>
             Is thread safe and completely reusable.
            
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Payloads.MinPayloadFunction">
             <summary>
             Calculates the minimum payload seen
            
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.PayloadFunction" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Payloads.PayloadFunction.CurrentScore(System.Int32,System.String,System.Int32,System.Int32,System.Int32,System.Single,System.Single)" -->
        <member name="M:Lucene.Net.Search.Payloads.PayloadFunction.DocScore(System.Int32,System.String,System.Int32,System.Single)">
            <summary>
            Calculate the final score for all the payloads seen so far for this doc/field </summary>
            <param name="docId"> The current doc </param>
            <param name="field"> The current field </param>
            <param name="numPayloadsSeen"> The total number of payloads seen on this document </param>
            <param name="payloadScore"> The raw score for those payloads </param>
            <returns> The final score for the payloads </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.PayloadNearQuery" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Payloads.PayloadNearQuery.PayloadNearSpanScorer.ProcessPayloads(System.Collections.Generic.ICollection{System.Byte[]},System.Int32,System.Int32)" -->
        <member name="T:Lucene.Net.Search.Payloads.PayloadSpanUtil">
             <summary>
             Experimental class to get set of payloads for most standard Lucene queries.
             Operates like Highlighter - IndexReader should only contain doc of interest,
             best to use MemoryIndex.
            
             @lucene.experimental
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Payloads.PayloadSpanUtil.#ctor(Lucene.Net.Index.IndexReaderContext)" -->
        <member name="M:Lucene.Net.Search.Payloads.PayloadSpanUtil.GetPayloadsForQuery(Lucene.Net.Search.Query)">
            <summary>
            Query should be rewritten for wild/fuzzy support.
            </summary>
            <param name="query"> rewritten query </param>
            <returns> payloads Collection </returns>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Payloads.PayloadTermQuery" -->
        <member name="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetScore">
            
             <returns> <seealso cref="!:#getSpanScore()"/> * <seealso cref="!:#getPayloadScore()"/> </returns>
             <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetSpanScore" -->
        <member name="M:Lucene.Net.Search.Payloads.PayloadTermQuery.PayloadTermWeight.PayloadTermSpanScorer.GetPayloadScore">
            <summary>
            The score for the payload
            </summary>
            <returns> The score, as calculated by
                    <seealso cref="!:PayloadFunction#docScore(int, String, int, float)"/> </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.AfterEffect" -->
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns the aftereffect score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns an explanation for the score. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect">
            <summary>
            Implementation used when there is no aftereffect. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.NoAfterEffect.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffect.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            after effect formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffectB">
            <summary>
            Model of the information gain based on the ratio of two Bernoulli processes.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffectB.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.AfterEffectL">
            <summary>
            Model of the information gain based on Laplace's law of succession.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.AfterEffectL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.BasicModel" -->
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns the informative content score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single)">
            <summary>
            Returns an explanation for the score.
            <p>Most basic models use the number of documents and the total term
            frequency to compute Inf<sub>1</sub>. this method provides a generic
            explanation for such models. Subclasses that use other statistics must
            override this method.</p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModel.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            basic model formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelBE">
            <summary>
            Limiting form of the Bose-Einstein model. The formula used in Lucene differs
            slightly from the one in the original paper: {@code F} is increased by {@code tfn+1}
            and {@code N} is increased by {@code F}
            @lucene.experimental
            NOTE: in some corner cases this model may give poor performance with Normalizations that
            return large values for {@code tfn} such as NormalizationH3. Consider using the
            geometric approximation (<seealso cref="T:Lucene.Net.Search.Similarities.BasicModelG"/>) instead, which provides the same relevance
            but with less practical problems.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelBE.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelBE.f(System.Double,System.Double)">
            <summary>
            The <em>f</em> helper function defined for <em>B<sub>E</sub></em>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.BasicModelD" -->
        <member name="M:Lucene.Net.Search.Similarities.BasicModelD.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelG">
            <summary>
            Geometric as limiting form of the Bose-Einstein model.  The formula used in Lucene differs
            slightly from the one in the original paper: {@code F} is increased by {@code 1}
            and {@code N} is increased by {@code F}.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelG.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIF">
            <summary>
            An approximation of the <em>I(n<sub>e</sub>)</em> model.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIn">
            <summary>
            The basic tf-idf model of randomness.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIn.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicModelIne">
            <summary>
            Tf-idf model of randomness, based on a mixture of Poisson and inverse
            document frequency.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelIne.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.BasicModelP" -->
        <member name="F:Lucene.Net.Search.Similarities.BasicModelP.LOG2_E">
            <summary>
            {@code log2(Math.E)}, precomputed. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicModelP.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BasicStats">
            <summary>
            Stores all statistics commonly used ranking methods.
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_numberOfDocuments">
            <summary>
            The number of documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_numberOfFieldTokens">
            <summary>
            The total number of tokens in the field. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_avgFieldLength">
            <summary>
            The average field length. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_docFreq">
            <summary>
            The document frequency. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_totalTermFreq">
            <summary>
            The total number of occurrences of this term across all documents. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_queryBoost">
            <summary>
            Query's inner boost. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_topLevelBoost">
            <summary>
            Any outer query's boost. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BasicStats.m_totalBoost">
            <summary>
            For most Similarities, the immediate and the top level query boosts are
            not handled differently. Hence, this field is just the product of the
            other two.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.#ctor(System.String,System.Single)">
            <summary>
            Constructor. Sets the query boost. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.NumberOfDocuments">
            <summary>
            Returns the number of documents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.BasicStats.NumberOfFieldTokens" -->
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.AvgFieldLength">
            <summary>
            Returns the average field length. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.DocFreq">
            <summary>
            Returns the document frequency. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.TotalTermFreq">
            <summary>
            Returns the total number of occurrences of this term across all documents. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.BasicStats.GetValueForNormalization" -->
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.RawNormalizationValue">
            <summary>
            Computes the raw normalization value. this basic implementation returns
            the query boost. Subclasses may override this method to include other
            factors (such as idf), or to save the value for inclusion in
            <seealso cref="!:#normalize(float, float)"/>, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BasicStats.Normalize(System.Single,System.Single)">
            <summary>
            No normalization is done. {@code topLevelBoost} is saved in the object,
            however.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BasicStats.TotalBoost">
            <summary>
            Returns the total boost. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.BM25Similarity">
            <summary>
            BM25 Similarity. Introduced in Stephen E. Robertson, Steve Walker,
            Susan Jones, Micheline Hancock-Beaulieu, and Mike Gatford. Okapi at TREC-3.
            In Proceedings of the Third <b>T</b>ext <b>RE</b>trieval <b>C</b>onference (TREC 1994).
            Gaithersburg, USA, November 1994.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor(System.Single,System.Single)">
            <summary>
            BM25 with the supplied parameter values. </summary>
            <param name="k1"> Controls non-linear term frequency normalization (saturation). </param>
            <param name="b"> Controls to what degree document length normalizes tf values. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.BM25Similarity.#ctor" -->
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.Idf(System.Int64,System.Int64)">
            <summary>
            Implemented as <code>log(1 + (numDocs - docFreq + 0.5)/(docFreq + 0.5))</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.SloppyFreq(System.Int32)">
            <summary>
            Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            The default implementation returns <code>1</code> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.AvgFieldLength(Lucene.Net.Search.CollectionStatistics)">
            <summary>
            The default implementation computes the average as <code>sumTotalTermFreq / maxDoc</code>,
            or returns <code>1</code> if the index does not store sumTotalTermFreq (Lucene 3.x indexes
            or any field that omits frequency information).
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.EncodeNormValue(System.Single,System.Int32)">
            <summary>
            The default implementation encodes <code>boost / sqrt(length)</code>
            with <seealso cref="!:SmallSingle#floatToByte315(float)"/>.  this is compatible with
            Lucene's default implementation.  If you change this, then you should
            change <seealso cref="!:#decodeNormValue(byte)"/> to match.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.BM25Similarity.DecodeNormValue(System.Byte)">
            <summary>
            The default implementation returns <code>1 / f<sup>2</sup></code>
            where <code>f</code> is <seealso cref="!:SmallSingle#byte315ToFloat(byte)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.discountOverlaps">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.DiscountOverlaps">
            <summary>
            Sets whether overlap tokens (Tokens with 0 position increment) are
             ignored when computing norm.  By default this is true, meaning overlap
             tokens do not count when computing norms.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.BM25Similarity.NORM_TABLE">
            <summary>
            Cache of decoded bytes. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.BM25Similarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.BM25Similarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])" -->
        <member name="T:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats">
            <summary>
            Collection statistics for the BM25 model. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Idf">
            <summary>
            BM25's idf </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Avgdl">
            <summary>
            The average document length. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.QueryBoost">
            <summary>
            query's inner boost </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.TopLevelBoost">
            <summary>
            query's outer boost (only for explain) </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Weight">
            <summary>
            weight (idf * boost) </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Field">
            <summary>
            field name, for pulling norms </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.BM25Similarity.BM25Stats.Cache">
            <summary>
            precomputed norm[256] with k1 * ((1 - b) + b * dl / avgdl) </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.BM25Similarity.K1" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.BM25Similarity.B" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.DefaultSimilarity" -->
        <member name="F:Lucene.Net.Search.Similarities.DefaultSimilarity.NORM_TABLE">
            <summary>
            Cache of decoded bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Coord(System.Int32,System.Int32)">
            <summary>
            Implemented as <code>overlap / maxOverlap</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.QueryNorm(System.Single)">
            <summary>
            Implemented as <code>1/sqrt(sumOfSquaredWeights)</code>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.DefaultSimilarity.EncodeNormValue(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.DefaultSimilarity.DecodeNormValue(System.Int64)" -->
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.LengthNorm(Lucene.Net.Index.FieldInvertState)">
             <summary>
             Implemented as
              <code>state.getBoost()*lengthNorm(numTerms)</code>, where
              <code>numTerms</code> is <seealso cref="!:FieldInvertState#getLength()"/> if {@link
              #setDiscountOverlaps} is false, else it's {@link
              FieldInvertState#getLength()} - {@link
              FieldInvertState#getNumOverlap()}.
            
              @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Tf(System.Single)">
            <summary>
            Implemented as <code>sqrt(freq)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.SloppyFreq(System.Int32)">
            <summary>
            Implemented as <code>1 / (distance + 1)</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            The default implementation returns <code>1</code> </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DefaultSimilarity.Idf(System.Int64,System.Int64)">
            <summary>
            Implemented as <code>log(numDocs/(docFreq+1)) + 1</code>. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DefaultSimilarity.m_discountOverlaps">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.DefaultSimilarity.DiscountOverlaps" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.DFRSimilarity" -->
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.m_basicModel">
            <summary>
            The basic model for information content. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.m_afterEffect">
            <summary>
            The first normalization of the information content. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.DFRSimilarity.m_normalization">
            <summary>
            The term frequency normalization. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.DFRSimilarity.#ctor(Lucene.Net.Search.Similarities.BasicModel,Lucene.Net.Search.Similarities.AfterEffect,Lucene.Net.Search.Similarities.Normalization)" -->
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.BasicModel">
            <summary>
            Returns the basic model of information content
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.AfterEffect">
            <summary>
            Returns the first normalization
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.DFRSimilarity.Normalization">
            <summary>
            Returns the second normalization
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Distribution" -->
        <member name="M:Lucene.Net.Search.Similarities.Distribution.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Computes the score. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Explains the score. Returns the name of the model only, since
            both {@code tfn} and {@code lambda} are explained elsewhere.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Distribution.ToString">
            <summary>
            Subclasses must override this method to return the name of the
            distribution.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DistributionLL">
            <summary>
            Log-logistic distribution.
            <p>Unlike for DFR, the natural logarithm is used, as
            it is faster to compute and the original paper does not express any
            preference to a specific base.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DistributionLL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.DistributionSPL">
            <summary>
            The smoothed power-law (SPL) distribution for the information-based framework
            that is described in the original paper.
            <p>Unlike for DFR, the natural logarithm is used, as
            it is faster to compute and the original paper does not express any
            preference to a specific base.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.DistributionSPL.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.IBSimilarity" -->
        <member name="F:Lucene.Net.Search.Similarities.IBSimilarity.m_distribution">
            <summary>
            The probabilistic distribution used to model term occurrence. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Similarities.IBSimilarity.m_lambda" -->
        <member name="F:Lucene.Net.Search.Similarities.IBSimilarity.m_normalization">
            <summary>
            The term frequency normalization. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.IBSimilarity.#ctor(Lucene.Net.Search.Similarities.Distribution,Lucene.Net.Search.Similarities.Lambda,Lucene.Net.Search.Similarities.Normalization)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.IBSimilarity.ToString" -->
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Distribution">
            <summary>
            Returns the distribution
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Lambda">
            <summary>
            Returns the distribution's lambda parameter
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.IBSimilarity.Normalization">
            <summary>
            Returns the term frequency normalization
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Lambda" -->
        <member name="M:Lucene.Net.Search.Similarities.Lambda.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.CalculateLambda(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Computes the lambda parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.Explain(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Explains the lambda parameter. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Lambda.ToString">
            <summary>
            Subclasses must override this method to return the code of the lambda
            formula. Since the original paper is not very clear on this matter, and
            also uses the DFR naming scheme incorrectly, the codes here were chosen
            arbitrarily.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LambdaDF">
            <summary>
            Computes lambda as {@code docFreq+1 / numberOfDocuments+1}.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LambdaDF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LambdaTTF">
            <summary>
            Computes lambda as {@code totalTermFreq+1 / numberOfDocuments+1}.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LambdaTTF.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMDirichletSimilarity">
             <summary>
             Bayesian smoothing using Dirichlet priors. From Chengxiang Zhai and John
             Lafferty. 2001. A study of smoothing methods for language models applied to
             Ad Hoc information retrieval. In Proceedings of the 24th annual international
             ACM SIGIR conference on Research and development in information retrieval
             (SIGIR '01). ACM, New York, NY, USA, 334-342.
             <p>
             The formula as defined the paper assigns a negative score to documents that
             contain the term, but with fewer occurrences than predicted by the collection
             language model. The Lucene implementation returns {@code 0} for such
             documents.
             </p>
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Similarities.LMDirichletSimilarity.mu" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMDirichletSimilarity.#ctor" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.LMDirichletSimilarity.Mu" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.lambda" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.#ctor(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.LMJelinekMercerSimilarity.Lambda" -->
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity">
             <summary>
             Abstract superclass for language modeling Similarities. The following inner
             types are introduced:
             <ul>
               <li><seealso cref="T:Lucene.Net.Search.Similarities.LMSimilarity.LMStats"/>, which defines a new statistic, the probability that
               the collection language model generates the current term;</li>
               <li><seealso cref="T:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel"/>, which is a strategy interface for object that
               compute the collection language model {@code p(w|C)};</li>
               <li><seealso cref="T:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel"/>, an implementation of the former, that
               computes the term probability as the number of occurrences of the term in the
               collection, divided by the total number of tokens.</li>
             </ul>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMSimilarity.m_collectionModel">
            <summary>
            The collection model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.#ctor(Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel)">
            <summary>
            Creates a new instance with the specified collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.#ctor">
            <summary>
            Creates a new instance with the default collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.FillBasicStats(Lucene.Net.Search.Similarities.BasicStats,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
            <summary>
            Computes the collection probability of the current term in addition to the
            usual statistics.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.GetName">
            <summary>
            Returns the name of the LM method. The values of the parameters should be
            included as well.
            <p>Used in <seealso cref="!:#toString()"/></p>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.LMSimilarity.ToString" -->
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.LMStats">
            <summary>
            Stores the collection distribution of the current term. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.collectionProbability">
            <summary>
            The probability that the current term is generated by the collection. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.#ctor(System.String,System.Single)">
            <summary>
            Creates LMStats for the provided field and query-time boost
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.LMSimilarity.LMStats.CollectionProbability">
            <summary>
            Returns the probability that the current term is generated by the
            collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel">
            <summary>
            A strategy for computing the collection language model. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel.ComputeProbability(Lucene.Net.Search.Similarities.BasicStats)">
            <summary>
            Computes the probability {@code p(w|C)} according to the language model
            strategy for the current term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.LMSimilarity.ICollectionModel.Name">
            <summary>
            The name of the collection model strategy. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel">
            <summary>
            Models {@code p(w|C)} as the number of occurrences of the term in the
            collection, divided by the total number of tokens {@code + 1}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.LMSimilarity.DefaultCollectionModel.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.MultiSimilarity">
            <summary>
            Implements the CombSUM method for combining evidence from multiple
            similarity values described in: Joseph A. Shaw, Edward A. Fox.
            In Text REtrieval Conference (1993), pp. 243-252
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.MultiSimilarity.m_sims">
            <summary>
            the sub-similarities used to create the combined score </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.MultiSimilarity.#ctor(Lucene.Net.Search.Similarities.Similarity[])">
            <summary>
            Creates a MultiSimilarity which will sum the scores
            of the provided <code>sims</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Normalization" -->
        <member name="M:Lucene.Net.Search.Similarities.Normalization.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.Tfn(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Returns the normalized term frequency. </summary>
            <param name="len"> the field length.  </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Returns an explanation for the normalized term frequency.
            <p>The default normalization methods use the field length of the document
            and the average field length to compute the normalized term frequency.
            this method provides a generic explanation for such methods.
            Subclasses that use other statistics must override this method.</p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Normalization.NoNormalization">
            <summary>
            Implementation used when there is no normalization. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.NoNormalization.#ctor">
            <summary>
            Sole constructor: parameter-free </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Normalization.ToString">
            <summary>
            Subclasses must override this method to return the code of the
            normalization formula. Refer to the original paper for the list.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH1">
            <summary>
            Normalization model that assumes a uniform distribution of the term frequency.
            <p>While this model is parameterless in the
            <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.742">
            original article</a>, <a href="http://dl.acm.org/citation.cfm?id=1835490">
            information-based models</a> (see <seealso cref="T:Lucene.Net.Search.Similarities.IBSimilarity"/>) introduced a
            multiplying factor.
            The default value for the {@code c} parameter is {@code 1}.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH1.#ctor(System.Single)">
            <summary>
            Creates NormalizationH1 with the supplied parameter <code>c</code>. </summary>
            <param name="c"> hyper-parameter that controls the term frequency
            normalization with respect to the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH1.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationH1(float) NormalizationH1(1)"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationH1.C" -->
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH2">
            <summary>
            Normalization model in which the term frequency is inversely related to the
            length.
            <p>While this model is parameterless in the
            <a href="http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.101.742">
            original article</a>, the <a href="http://theses.gla.ac.uk/1570/">thesis</a>
            introduces the parameterized variant.
            The default value for the {@code c} parameter is {@code 1}.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH2.#ctor(System.Single)">
            <summary>
            Creates NormalizationH2 with the supplied parameter <code>c</code>. </summary>
            <param name="c"> hyper-parameter that controls the term frequency
            normalization with respect to the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH2.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationH2(float) NormalizationH2(1)"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationH2.C" -->
        <member name="T:Lucene.Net.Search.Similarities.NormalizationH3">
            <summary>
            Dirichlet Priors normalization
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationH3.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationH3(float) NormalizationH3(800)"/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.NormalizationH3.#ctor(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationH3.Mu" -->
        <member name="T:Lucene.Net.Search.Similarities.NormalizationZ">
            <summary>
            Pareto-Zipf Normalization
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationZ.#ctor">
            <summary>
            Calls <seealso cref="!:#NormalizationZ(float) NormalizationZ(0.3)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.NormalizationZ.#ctor(System.Single)">
            <summary>
            Creates NormalizationZ with the supplied parameter <code>z</code>. </summary>
            <param name="z"> represents <code>A/(A+1)</code> where <code>A</code>
                     measures the specificity of the language. </param>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.NormalizationZ.Z" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper" -->
        <member name="M:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.PerFieldSimilarityWrapper.Get(System.String)">
            <summary>
            Returns a <seealso cref="T:Lucene.Net.Search.Similarities.Similarity"/> for scoring a field.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Similarity" -->
        <member name="M:Lucene.Net.Search.Similarities.Similarity.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.Coord(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.ComputeNorm(Lucene.Net.Index.FieldInvertState)" -->
        <member name="M:Lucene.Net.Search.Similarities.Similarity.ComputeWeight(System.Single,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])">
            <summary>
            Compute any collection-level weight (e.g. IDF, average document length, etc) needed for scoring a query.
            </summary>
            <param name="queryBoost"> the query-time boost. </param>
            <param name="collectionStats"> collection-level statistics, such as the number of tokens in the collection. </param>
            <param name="termStats"> term-level statistics, such as the document frequency of a term across the collection. </param>
            <returns> SimWeight object with the information this Similarity needs to score a query. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.GetSimScorer(Lucene.Net.Search.Similarities.Similarity.SimWeight,Lucene.Net.Index.AtomicReaderContext)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Search.Similarities.Similarity.SimScorer"/> to score matching documents from a segment of the inverted index. </summary>
            <param name="weight"> collection information from <seealso cref="!:#computeWeight(float, CollectionStatistics, TermStatistics...)"/> </param>
            <param name="context"> segment of the inverted index to be scored. </param>
            <returns> SloppySimScorer for scoring documents across <code>context</code> </returns>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.Similarity.SimScorer" -->
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.Score(System.Int32,System.Single)">
            <summary>
            Score a single document </summary>
            <param name="doc"> document id within the inverted index segment </param>
            <param name="freq"> sloppy term frequency </param>
            <returns> document's score </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputeSlopFactor(System.Int32)">
            <summary>
            Computes the amount of a sloppy phrase match, based on an edit distance. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.ComputePayloadFactor(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Calculate a scoring factor based on the data in the payload. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimScorer.Explain(System.Int32,Lucene.Net.Search.Explanation)">
            <summary>
            Explain the score for a single document </summary>
            <param name="doc"> document id within the inverted index segment </param>
            <param name="freq"> Explanation of how the sloppy term frequency was computed </param>
            <returns> document's score </returns>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.Similarity.SimWeight">
            <summary>
            Stores the weight for a query across the indexed collection. this abstract
            implementation is empty; descendants of {@code Similarity} should
            subclass {@code SimWeight} and define the statistics they require in the
            subclass. Examples include idf, average field length, etc.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.Similarity.SimWeight.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.SimWeight.GetValueForNormalization" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.Similarity.SimWeight.Normalize(System.Single,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.SimilarityBase" -->
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.LOG_2">
            <summary>
            For <seealso cref="!:#log2(double)"/>. Precomputed for efficiency reasons. </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.discountOverlaps">
            <summary>
            True if overlap tokens (tokens with a position of increment of zero) are
            discounted from the document's length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Similarities.SimilarityBase.DiscountOverlaps" -->
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.NewStats(System.String,System.Single)">
            <summary>
            Factory method to return a custom stats object </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.FillBasicStats(Lucene.Net.Search.Similarities.BasicStats,Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)">
            <summary>
            Fills all member fields defined in {@code BasicStats} in {@code stats}.
             Subclasses can override this method to fill additional stats.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Score(Lucene.Net.Search.Similarities.BasicStats,System.Single,System.Single)">
            <summary>
            Scores the document {@code doc}.
            <p>Subclasses must apply their scoring formula in this class.</p> </summary>
            <param name="stats"> the corpus level statistics. </param>
            <param name="freq"> the term frequency. </param>
            <param name="docLen"> the document length. </param>
            <returns> the score. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Explanation,Lucene.Net.Search.Similarities.BasicStats,System.Int32,System.Single,System.Single)">
            <summary>
            Subclasses should implement this method to explain the score. {@code expl}
            already contains the score, the name of the class and the doc id, as well
            as the term frequency and its explanation; subclasses can add additional
            clauses to explain details of their scoring formulae.
            <p>The default implementation does nothing.</p>
            </summary>
            <param name="expl"> the explanation to extend with details. </param>
            <param name="stats"> the corpus level statistics. </param>
            <param name="doc"> the document id. </param>
            <param name="freq"> the term frequency. </param>
            <param name="docLen"> the document length. </param>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Explain(Lucene.Net.Search.Similarities.BasicStats,System.Int32,Lucene.Net.Search.Explanation,System.Single)">
            <summary>
            Explains the score. The implementation here provides a basic explanation
            in the format <em>score(name-of-similarity, doc=doc-id,
            freq=term-frequency), computed from:</em>, and
            attaches the score (computed via the <seealso cref="!:#score(BasicStats, float, float)"/>
            method) and the explanation for the term frequency. Subclasses content with
            this format may add additional details in
            <seealso cref="!:#explain(Explanation, BasicStats, int, float, float)"/>.
            </summary>
            <param name="stats"> the corpus level statistics. </param>
            <param name="doc"> the document id. </param>
            <param name="freq"> the term frequency and its explanation. </param>
            <param name="docLen"> the document length. </param>
            <returns> the explanation. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.ToString">
            <summary>
            Subclasses must override this method to return the name of the Similarity
            and preferably the values of parameters (if any) as well.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Similarities.SimilarityBase.NORM_TABLE">
            <summary>
            Norm -> document length map. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.ComputeNorm(Lucene.Net.Index.FieldInvertState)">
            <summary>
            Encodes the document length in the same way as <seealso cref="T:Lucene.Net.Search.Similarities.TFIDFSimilarity"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.SimilarityBase.DecodeNormValue(System.Byte)" -->
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.EncodeNormValue(System.Single,System.Single)">
            <summary>
            Encodes the length to a byte via SmallFloat. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Similarities.SimilarityBase.Log2(System.Double)">
            <summary>
            Returns the base two logarithm of {@code x}. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.SimilarityBase.BasicSimScorer">
            <summary>
            Delegates the <seealso cref="!:#score(int, float)"/> and
            <seealso cref="!:#explain(int, Explanation)"/> methods to
            <seealso cref="!:SimilarityBase#score(BasicStats, float, float)"/> and
            <seealso cref="!:SimilarityBase#explain(BasicStats, int, Explanation, float)"/>,
            respectively.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Similarities.TFIDFSimilarity" -->
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.#ctor">
            <summary>
            Sole constructor. (For invocation by subclass
            constructors, typically implicit.)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Coord(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.QueryNorm(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Tf(System.Single)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.IdfExplain(Lucene.Net.Search.CollectionStatistics,Lucene.Net.Search.TermStatistics[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.Idf(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.LengthNorm(Lucene.Net.Index.FieldInvertState)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.DecodeNormValue(System.Int64)" -->
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.EncodeNormValue(System.Single)">
            <summary>
            Encodes a normalization factor for storage in an index. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Similarities.TFIDFSimilarity.SloppyFreq(System.Int32)" -->
        <member name="M:Lucene.Net.Search.Similarities.TFIDFSimilarity.ScorePayload(System.Int32,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Calculate a scoring factor based on the data in the payload.  Implementations
            are responsible for interpreting what is in the payload.  Lucene makes no assumptions about
            what is in the byte array.
            </summary>
            <param name="doc"> The docId currently being scored. </param>
            <param name="start"> The start position of the payload </param>
            <param name="end"> The end position of the payload </param>
            <param name="payload"> The payload byte array to be scored </param>
            <returns> An implementation dependent float to be used as a scoring factor </returns>
        </member>
        <member name="T:Lucene.Net.Search.Similarities.TFIDFSimilarity.IDFStats">
            <summary>
            Collection statistics for the TF-IDF model. The only statistic of interest
            to this model is idf.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Similarities.TFIDFSimilarity.IDFStats.Idf">
            <summary>
            The idf and its explanation </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.FieldMaskingSpanQuery">
             <summary>
             <p>Wrapper to allow <seealso cref="T:Lucene.Net.Search.Spans.SpanQuery"/> objects participate in composite
             single-field SpanQueries by 'lying' about their search field. That is,
             the masked SpanQuery will function as normal,
             but <seealso cref="!:SpanQuery#getField()"/> simply hands back the value supplied
             in this class's constructor.</p>
            
             <p>this can be used to support Queries like <seealso cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/> or
             <seealso cref="T:Lucene.Net.Search.Spans.SpanOrQuery"/> across different fields, which is not ordinarily
             permitted.</p>
            
             <p>this can be useful for denormalized relational data: for example, when
             indexing a document with conceptually many 'children': </p>
            
             <pre>
              teacherid: 1
              studentfirstname: james
              studentsurname: jones
            
              teacherid: 2
              studenfirstname: james
              studentsurname: smith
              studentfirstname: sally
              studentsurname: jones
             </pre>
            
             <p>a SpanNearQuery with a slop of 0 can be applied across two
             <seealso cref="T:Lucene.Net.Search.Spans.SpanTermQuery"/> objects as follows:
             <pre class="prettyprint">
                SpanQuery q1  = new SpanTermQuery(new Term("studentfirstname", "james"));
                SpanQuery q2  = new SpanTermQuery(new Term("studentsurname", "jones"));
                SpanQuery q2m = new FieldMaskingSpanQuery(q2, "studentfirstname");
                Query q = new SpanNearQuery(new SpanQuery[]{q1, q2m}, -1, false);
             </pre>
             to search for 'studentfirstname:james studentsurname:jones' and find
             teacherid 1 without matching teacherid 2 (which has a 'james' in position 0
             and 'jones' in position 1). </p>
            
             <p>Note: as <seealso cref="!:#getField()"/> returns the masked field, scoring will be
             done using the Similarity and collection statistics of the field name supplied,
             but with the term statistics of the real field. this may lead to exceptions,
             poor performance, and unexpected scoring behaviour.</p>
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.NearSpansOrdered" -->
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.subSpans">
            <summary>
            The spans in the same order as the SpanNearQuery </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.NearSpansOrdered.inSameDoc">
            <summary>
            Indicates that all subSpans have same doc() </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.AdvanceAfterOrdered">
            <summary>
            Advances the subSpans to just after an ordered match with a minimum slop
            that is smaller than the slop allowed by the SpanNearQuery. </summary>
            <returns> true iff there is such a match. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ToSameDoc">
            <summary>
            Advance the subSpans to the same document </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(Lucene.Net.Search.Spans.Spans,Lucene.Net.Search.Spans.Spans)">
            <summary>
            Check whether two Spans in the same document are ordered. </summary>
            <returns> true iff spans1 starts before spans2
                         or the spans start at the same position,
                         and spans1 ends before spans2. </returns>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.DocSpansOrdered(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Like <seealso cref="!:#docSpansOrdered(Spans,Spans)"/>, but use the spans
            starts and ends as parameters.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.StretchToOrder">
            <summary>
            Order the subSpans within the same document by advancing all later spans
            after the previous one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.NearSpansOrdered.ShrinkToAfterShortestMatch">
            <summary>
            The subSpans are ordered in the same doc, so there is a possible match.
            Compute the slop while making the match as short as possible by advancing
            all subSpans except the last one in reverse order.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered">
             <summary>
             Similar to <seealso cref="T:Lucene.Net.Search.Spans.NearSpansOrdered"/>, but for the unordered case.
            
             Expert:
             Only public for subclassing.  Most implementations should not need this class
             </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.NearSpansUnordered.SpansCell">
            <summary>
            Wraps a Spans, and can be used to form a linked list. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.NearSpansUnordered.End">
            <summary>
            WARNING: The List is not necessarily in order of the the positions </summary>
            <returns> Collection of <code>byte[]</code> payloads </returns>
            <exception cref="!:IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanFirstQuery">
             <summary>
             Matches spans near the beginning of a field.
             <p/>
             this class is a simple extension of <seealso cref="T:Lucene.Net.Search.Spans.SpanPositionRangeQuery"/> in that it assumes the
             start to be zero and only checks the end boundary.
            
            
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanFirstQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>
            Construct a SpanFirstQuery matching spans in <code>match</code> whose end
            position is less than or equal to <code>end</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.#ctor(`0)" -->
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.MultiTermRewriteMethod">
            <summary>
            Expert: returns the rewriteMethod
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.WrappedQuery">
            <summary>
            Returns the wrapped query </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.SCORING_SPAN_QUERY_REWRITE" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite" -->
        <member name="M:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite.#ctor(System.Int32)">
            <summary>
            Create a TopTermsSpanBooleanQueryRewrite for
            at most <code>size</code> terms.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanMultiTermQueryWrapper`1.TopTermsSpanBooleanQueryRewrite.Count">
            <summary>
            return the maximum priority queue size.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanRewriteMethod">
            <summary>
            Abstract class that defines how the query is rewritten. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.ISpanMultiTermQueryWrapper">
            <summary>
            LUCENENET specific interface for referring to/identifying a SpanMultipTermQueryWrapper without
            referring to its generic closing type.
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery">
             <summary>
             Only return those matches that have a specific payload at
             the given position.
             <p/>
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery.#ctor(Lucene.Net.Search.Spans.SpanNearQuery,System.Collections.Generic.ICollection{System.Byte[]})">
            <param name="match">          The underlying <see cref="T:Lucene.Net.Search.Spans.SpanQuery"/> to check </param>
            <param name="payloadToMatch"> The <see cref="T:ICollection{byte[]}"/> of payloads to match.
            IMPORTANT: If the type provided does not implement <see cref="T:System.Collections.Generic.IList`1"/> (including arrays), 
            <see cref="T:System.Collections.Generic.ISet`1"/>, or <see cref="T:System.Collections.Generic.IDictionary`2"/>, it should provide an 
            <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/> implementation 
            that compares the values of the byte arrays to ensure they are the same. </param>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNearQuery">
            <summary>
            Matches spans which are near one another.  One can specify <i>slop</i>, the
            maximum number of intervening unmatched positions, as well as whether
            matches are required to be in-order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[],System.Int32,System.Boolean)">
            <summary>
            Construct a SpanNearQuery.  Matches spans matching a span from each
            clause, with up to <code>slop</code> total unmatched positions between
            them.  * When <code>inOrder</code> is true, the spans from each clause
            must be * ordered as in <code>clauses</code>. </summary>
            <param name="clauses"> the clauses to find near each other </param>
            <param name="slop"> The slop value </param>
            <param name="inOrder"> true if order is important
             </param>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.GetClauses">
            <summary>
            Return the clauses whose spans are matched. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNearQuery.Slop">
            <summary>
            Return the maximum number of intervening unmatched positions permitted. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNearQuery.IsInOrder">
            <summary>
            Return true if matches are required to be in-order. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNearQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanNotQuery">
            <summary>
            Removes matches which overlap with another SpanQuery or
            within a x tokens before or y tokens after another SpanQuery.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery,System.Int32)">
            <summary>
            Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code> within
            <code>dist</code> tokens of <code>include</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,Lucene.Net.Search.Spans.SpanQuery,System.Int32,System.Int32)">
            <summary>
            Construct a SpanNotQuery matching spans from <code>include</code> which
            have no overlap with spans from <code>exclude</code> within
            <code>pre</code> tokens before or <code>post</code> tokens of <code>include</code>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNotQuery.Include">
            <summary>
            Return the SpanQuery whose matches are filtered. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanNotQuery.Exclude">
            <summary>
            Return the SpanQuery whose matches must not overlap those returned. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanNotQuery.Equals(System.Object)">
            <summary>
            Returns true iff <code>o</code> is equal to this. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanOrQuery">
            <summary>
            Matches the union of its clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery[])">
            <summary>
            Construct a SpanOrQuery merging the provided clauses. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.AddClause(Lucene.Net.Search.Spans.SpanQuery)">
            <summary>
            Adds a clause to this query </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanOrQuery.GetClauses">
            <summary>
            Return the clauses whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPayloadCheckQuery">
             <summary>
               Only return those matches that have a specific payload at
              the given position.
             <p/>
             Do not use this with an SpanQuery that contains a <seealso cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.  Instead, use
             <seealso cref="T:Lucene.Net.Search.Spans.SpanNearPayloadCheckQuery"/> since it properly handles the fact that payloads
             aren't ordered by <seealso cref="T:Lucene.Net.Search.Spans.SpanNearQuery"/>.
            
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.SpanPayloadCheckQuery.#ctor(Lucene.Net.Search.Spans.SpanQuery,System.Collections.Generic.ICollection{System.Byte[]})" -->
        <member name="T:Lucene.Net.Search.Spans.SpanPositionCheckQuery">
             <summary>
             Base class for filtering a SpanQuery based on the position of a match.
            
             </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanPositionCheckQuery.Match">
             <returns> the SpanQuery whose matches are filtered.
            
              </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus">
            <summary>
            Return value for <seealso cref="!:SpanPositionCheckQuery#acceptPosition(Spans)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.YES">
            <summary>
            Indicates the match should be accepted </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.NO">
            <summary>
            Indicates the match should be rejected </summary>
        </member>
        <member name="F:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptStatus.NO_AND_ADVANCE">
            <summary>
            Indicates the match should be rejected, and the enumeration should advance
            to the next document.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.SpanPositionCheckQuery.AcceptPosition(Lucene.Net.Search.Spans.Spans)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Search.Spans.SpanPositionRangeQuery" -->
        <member name="P:Lucene.Net.Search.Spans.SpanPositionRangeQuery.Start">
            <returns> The minimum position permitted in a match </returns>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanPositionRangeQuery.End">
            <returns> the maximum end position permitted in a match. </returns>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanQuery">
            <summary>
            Base class for span-based queries. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanQuery.GetSpans(Lucene.Net.Index.AtomicReaderContext,Lucene.Net.Util.IBits,System.Collections.Generic.IDictionary{Lucene.Net.Index.Term,Lucene.Net.Index.TermContext})">
            <summary>
            Expert: Returns the matches for this query in an index.  Used internally
            to search for spans.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Search.Spans.SpanQuery.Field" -->
        <member name="T:Lucene.Net.Search.Spans.Spans">
            <summary>
            Expert: an enumeration of span matches.  Used to implement span searching.
            Each span represents a range of term positions within a document.  Matches
            are enumerated in order, by increasing document number, within that by
            increasing start position and finally by increasing end position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.Spans.Next">
            <summary>
            Move to the next match, returning true iff any such exists. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.SkipTo(System.Int32)" -->
        <member name="P:Lucene.Net.Search.Spans.Spans.Doc">
            <summary>
            Returns the document number of the current match.  Initially invalid. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.Spans.Start">
            <summary>
            Returns the start position of the current match.  Initially invalid. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.Spans.End">
            <summary>
            Returns the end position of the current match.  Initially invalid. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.GetPayload" -->
        <member name="P:Lucene.Net.Search.Spans.Spans.IsPayloadAvailable">
            <summary>
            Checks if a payload can be loaded at this position.
            <p/>
            Payloads can only be loaded once per call to
            <seealso cref="!:#next()"/>.
            </summary>
            <returns> true if there is a payload available at this position that can be loaded </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Search.Spans.Spans.GetCost" -->
        <member name="T:Lucene.Net.Search.Spans.SpanScorer">
            <summary>
            Public for extension only.
            </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanScorer.SloppyFreq">
            <summary>
            Returns the intermediate "sloppy freq" adjusted for edit distance
             @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanTermQuery">
            <summary>
            Matches spans containing a term. </summary>
        </member>
        <member name="M:Lucene.Net.Search.Spans.SpanTermQuery.#ctor(Lucene.Net.Index.Term)">
            <summary>
            Construct a SpanTermQuery matching the named term's spans. </summary>
        </member>
        <member name="P:Lucene.Net.Search.Spans.SpanTermQuery.Term">
            <summary>
            Return the term whose spans are matched. </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.SpanWeight">
            <summary>
            Expert-only.  Public for use by other weight implementations
            </summary>
        </member>
        <member name="T:Lucene.Net.Search.Spans.TermSpans">
            <summary>
            Expert:
            Public for extension only
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.BaseDirectory">
            <summary>
            Base implementation for a concrete <see cref="T:Lucene.Net.Store.Directory"/>.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.BaseDirectory.m_lockFactory">
            <summary>
            Holds the LockFactory instance (implements locking for
            this <see cref="T:Lucene.Net.Store.Directory"/> instance).
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BaseDirectory.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedChecksum">
            <summary>
            Wraps another <see cref="T:Lucene.Net.Support.IChecksum"/> with an internal buffer
            to speed up checksum calculations.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedChecksum.DEFAULT_BUFFERSIZE">
            <summary>
            Default buffer size: 256 </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksum.#ctor(Lucene.Net.Support.IChecksum)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.BufferedChecksum"/> with <see cref="F:Lucene.Net.Store.BufferedChecksum.DEFAULT_BUFFERSIZE"/> </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksum.#ctor(Lucene.Net.Support.IChecksum,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.BufferedChecksum"/> with the specified <paramref name="bufferSize"/> </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedChecksumIndexInput">
            <summary>
            Simple implementation of <see cref="T:Lucene.Net.Store.ChecksumIndexInput"/> that wraps
            another input and delegates calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedChecksumIndexInput.#ctor(Lucene.Net.Store.IndexInput)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.BufferedChecksumIndexInput"/> </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexInput">
            <summary>
            Base implementation class for buffered <see cref="T:Lucene.Net.Store.IndexInput"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.BUFFER_SIZE">
            <summary>
            Default buffer size set to <see cref="F:Lucene.Net.Store.BufferedIndexInput.BUFFER_SIZE"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexInput.MERGE_BUFFER_SIZE">
            <summary>
            A buffer size for merges set to <see cref="F:Lucene.Net.Store.BufferedIndexInput.MERGE_BUFFER_SIZE"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.#ctor(System.String,System.Int32)">
            <summary>
            Inits <see cref="T:Lucene.Net.Store.BufferedIndexInput"/> with a specific <paramref name="bufferSize"/> </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SetBufferSize(System.Int32)">
            <summary>
            Change the buffer size used by this <see cref="T:Lucene.Net.Store.IndexInput"/> </summary>
        </member>
        <member name="P:Lucene.Net.Store.BufferedIndexInput.BufferSize">
            <summary>
            Returns buffer size.
            </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexInput.SetBufferSize(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInt16">
            <summary>
            NOTE: this was readShort() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInt32">
            <summary>
            NOTE: this was readInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInt64">
            <summary>
            NOTE: this was readLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadVInt32">
            <summary>
            NOTE: this was readVInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadVInt64">
            <summary>
            NOTE: this was readVLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer refill.  Reads bytes from the current position
            in the input. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="length"> the number of bytes to read </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.SeekInternal(System.Int64)">
            <summary>
            Expert: implements seek.  Sets current position in this file, where the
            next <see cref="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/> will occur. </summary>
            <seealso cref="M:Lucene.Net.Store.BufferedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.FlushBuffer(Lucene.Net.Store.IndexOutput,System.Int64)">
            <summary>
            Flushes the in-memory buffer to the given output, copying at most
            <paramref name="numBytes"/>.
            <para/>
            <b>NOTE:</b> this method does not refill the buffer, however it does
            advance the buffer position.
            </summary>
            <returns> the number of bytes actually flushed from the in-memory buffer. </returns>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexInput.GetBufferSize(Lucene.Net.Store.IOContext)">
            <summary>
            Returns default buffer sizes for the given <see cref="T:Lucene.Net.Store.IOContext"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.BufferedIndexOutput">
            <summary>
            Base implementation class for buffered <see cref="T:Lucene.Net.Store.IndexOutput"/>. </summary>
        </member>
        <member name="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE">
            <summary>
            The default buffer size in bytes (<see cref="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE"/>). </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.#ctor">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.BufferedIndexOutput"/> with the default buffer size
            (<see cref="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE"/> bytes see <see cref="F:Lucene.Net.Store.BufferedIndexOutput.DEFAULT_BUFFER_SIZE"/>)
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.#ctor(System.Int32)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.BufferedIndexOutput"/> with the given buffer size. </summary>
            <param name="bufferSize"> the buffer size in bytes used to buffer writes internally. </param>
            <exception cref="T:System.ArgumentException"> if the given buffer size is less or equal to <c>0</c> </exception>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32)">
            <summary>
            Expert: implements buffer write.  Writes bytes at the current position in
            the output. </summary>
            <param name="b"> the bytes to write </param>
            <param name="len"> the number of bytes to write </param>
        </member>
        <member name="M:Lucene.Net.Store.BufferedIndexOutput.FlushBuffer(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer write.  Writes bytes at the current position in
            the output. </summary>
            <param name="b"> the bytes to write </param>
            <param name="offset"> the offset in the byte array </param>
            <param name="len"> the number of bytes to write </param>
        </member>
        <member name="P:Lucene.Net.Store.BufferedIndexOutput.BufferSize">
             <summary>
             Returns size of the used output buffer in bytes.
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteArrayDataInput">
            <summary>
            DataInput backed by a byte array.
            <b>WARNING:</b> this class omits all low-level checks.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.Rewind">
            <summary>
            NOTE: sets pos to 0, which is not right if you had
            called reset w/ non-zero offset!!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadInt16">
            <summary>
            LUCENENET NOTE: Important - always cast to ushort (System.UInt16) before using to ensure
            the value is positive!
            <para/>
            NOTE: this was readShort() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadInt32">
            <summary>
            NOTE: this was readInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadInt64">
            <summary>
            NOTE: this was readLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadVInt32">
            <summary>
            NOTE: this was readVInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteArrayDataInput.ReadVInt64">
            <summary>
            NOTE: this was readVLong() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteArrayDataOutput">
            <summary>
            DataOutput backed by a byte array.
            <b>WARNING:</b> this class omits most low-level checks,
            so be sure to test heavily with assertions enabled.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ByteBufferIndexInput">
            <summary>
            Base <see cref="T:Lucene.Net.Store.IndexInput"/> implementation that uses an array
            of <see cref="T:Lucene.Net.Support.IO.ByteBuffer"/>s to represent a file.
            <para/>
            Because Java's <see cref="T:Lucene.Net.Support.IO.ByteBuffer"/> uses an <see cref="T:System.Int32"/> to address the
            values, it's necessary to access a file greater
            <see cref="F:System.Int32.MaxValue"/> in size using multiple byte buffers.
            <para/>
            For efficiency, this class requires that the buffers
            are a power-of-two (<c>chunkSizePower</c>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.ReadInt16">
            <summary>
            NOTE: this was readShort() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.ReadInt32">
            <summary>
            NOTE: this was readInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.ReadInt64">
            <summary>
            NOTE: this was readLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.Slice(System.String,System.Int64,System.Int64)">
            <summary>
            Creates a slice of this index input, with the given description, offset, and length. The slice is seeked to the beginning.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.BuildSlice(Lucene.Net.Support.IO.ByteBuffer[],System.Int64,System.Int64)">
            <summary>
            Returns a sliced view from a set of already-existing buffers:
            the last buffer's <see cref="!:Support.Buffer.Limit"/> will be correct, but
            you must deal with <paramref name="offset"/> separately (the first buffer will not be adjusted)
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ByteBufferIndexInput.FreeBuffer(Lucene.Net.Support.IO.ByteBuffer)">
            <summary>
            Called when the contents of a buffer will be no longer needed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.ChecksumIndexInput">
            <summary>
            Extension of <see cref="T:Lucene.Net.Store.IndexInput"/>, computing checksum as it goes.
            Callers can retrieve the checksum via <see cref="P:Lucene.Net.Store.ChecksumIndexInput.Checksum"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexInput.#ctor(System.String)">
            <summary>
            <paramref name="resourceDescription"/> should be a non-null, opaque string
            describing this resource; it's returned from
            <see cref="M:System.Object.ToString"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.ChecksumIndexInput.Checksum">
            <summary>
            Returns the current checksum value </summary>
        </member>
        <member name="M:Lucene.Net.Store.ChecksumIndexInput.Seek(System.Int64)">
            <summary>
            Sets current position in this file, where the next read will occur. 
            <para/>
            <see cref="T:Lucene.Net.Store.ChecksumIndexInput"/> can only seek forward and seeks are expensive
            since they imply to read bytes in-between the current position and the
            target position in order to update the checksum.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.CompoundFileDirectory">
            <summary>
            Class for accessing a compound stream.
            This class implements a directory, but is limited to only read operations.
            Directory methods that would normally modify data throw an exception.
            <para/>
            All files belonging to a segment have the same name with varying extensions.
            The extensions correspond to the different file formats used by the <see cref="T:Lucene.Net.Codecs.Codec"/>.
            When using the Compound File format these files are collapsed into a
            single <c>.cfs</c> file (except for the <see cref="T:Lucene.Net.Codecs.LiveDocsFormat"/>, with a
            corresponding <c>.cfe</c> file indexing its sub-files.
            <para/>
            Files:
            <list type="bullet">
                <item><c>.cfs</c>: An optional "virtual" file consisting of all the other
                    index files for systems that frequently run out of file handles.</item>
                <item><c>.cfe</c>: The "virtual" compound file's entry table holding all
                    entries in the corresponding .cfs file.</item>
            </list>
            <para>Description:</para>
            <list type="bullet">
                <item>Compound (.cfs) --&gt; Header, FileData <sup>FileCount</sup></item>
                <item>Compound Entry Table (.cfe) --&gt; Header, FileCount, &lt;FileName,
                    DataOffset, DataLength&gt; <sup>FileCount</sup>, Footer</item>
                <item>Header --&gt; <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteHeader(Lucene.Net.Store.DataOutput,System.String,System.Int32)"/></item>
                <item>FileCount --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/></item>
                <item>DataOffset,DataLength --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/></item>
                <item>FileName --&gt; <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/></item>
                <item>FileData --&gt; raw file data</item>
                <item>Footer --&gt; <see cref="M:Lucene.Net.Codecs.CodecUtil.WriteFooter(Lucene.Net.Store.IndexOutput)"/></item>
            </list>
            <para>Notes:</para>
            <list type="bullet">
              <item>FileCount indicates how many files are contained in this compound file.
                    The entry table that follows has that many entries.</item>
              <item>Each directory entry contains a long pointer to the start of this file's data
                    section, the files length, and a <see cref="T:System.String"/> with that file's name.</item>
            </list>
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.CompoundFileDirectory.FileEntry">
            <summary>
            Offset/Length for a slice inside of a compound file </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.#ctor(Lucene.Net.Store.Directory,System.String,Lucene.Net.Store.IOContext,System.Boolean)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.ReadEntries(Lucene.Net.Store.Directory.IndexInputSlicer,Lucene.Net.Store.Directory,System.String)">
            <summary>
            Helper method that reads CFS entries from an input stream </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.ListAll">
            <summary>
            Returns an array of strings, one for each file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.FileExists(System.String)">
            <summary>
            Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.DeleteFile(System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="T:System.NotSupportedException"> always: not supported by CFS  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.RenameFile(System.String,System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="T:System.NotSupportedException"> always: not supported by CFS  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.FileLength(System.String)">
            <summary>
            Returns the length of a file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist  </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileDirectory.MakeLock(System.String)">
            <summary>
            Not implemented </summary>
            <exception cref="T:System.NotSupportedException"> always: not supported by CFS  </exception>
        </member>
        <member name="T:Lucene.Net.Store.CompoundFileWriter">
            <summary>
            Combines multiple files into a single compound file.
            <para/>
            @lucene.internal 
            </summary>
            <seealso cref="T:Lucene.Net.Store.CompoundFileDirectory"/>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.FileEntry.File">
            <summary>
            source file </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.FileEntry.Offset">
            <summary>
            temporary holder for the start of this file's data section </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.FileEntry.Dir">
            <summary>
            the directory which contains the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.#ctor(Lucene.Net.Store.Directory,System.String)">
            <summary>
            Create the compound stream in the specified file. The file name is the
            entire name (no extensions are added).
            </summary>
            <exception cref="T:System.ArgumentNullException">
                      if <paramref name="dir"/> or <paramref name="name"/> is <c>null</c> </exception>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.Directory">
            <summary>
            Returns the directory of the compound file. </summary>
        </member>
        <member name="P:Lucene.Net.Store.CompoundFileWriter.Name">
            <summary>
            Returns the name of the compound file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.Dispose">
            <summary>
            Disposes all resources and writes the entry table
            </summary>
            <exception cref="T:System.InvalidOperationException">
                      if <see cref="M:Lucene.Net.Store.CompoundFileWriter.Dispose"/> had been called before or if no file has been added to
                      this object </exception>
        </member>
        <member name="M:Lucene.Net.Store.CompoundFileWriter.CopyFileEntry(Lucene.Net.Store.IndexOutput,Lucene.Net.Store.CompoundFileWriter.FileEntry)">
            <summary>
            Copy the contents of the file with specified extension into the provided
            output stream.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.DataInput">
             <summary>
             Abstract base class for performing read operations of Lucene's low-level
             data types.
            
             <para/><see cref="T:Lucene.Net.Store.DataInput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position). To allow
             multithreaded use, every <see cref="T:Lucene.Net.Store.DataInput"/> instance must be cloned before
             used in another thread. Subclasses must therefore implement <see cref="M:Lucene.Net.Store.DataInput.Clone"/>,
             returning a new <see cref="T:Lucene.Net.Store.DataInput"/> which operates on the same underlying
             resource, but positioned independently.
             </summary>
        </member>
        <member name="F:Lucene.Net.Store.DataInput.skipBuffer">
            <summary>
            This buffer is used to skip over bytes with the default implementation of
            skipBytes. The reason why we need to use an instance member instead of
            sharing a single instance across threads is that some delegating
            implementations of DataInput might want to reuse the provided buffer in
            order to eg.update the checksum. If we shared the same buffer across
            threads, then another thread might update the buffer while the checksum is
            being computed, making it invalid. See LUCENE-5583 for more information.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadByte">
            <summary>
            Reads and returns a single byte. </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads a specified number of bytes into an array at the specified offset. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="len"> the number of bytes to read </param>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>
            Reads a specified number of bytes into an array at the
            specified offset with control over whether the read
            should be buffered (callers who have their own buffer
            should pass in "false" for <paramref name="useBuffer"/>).  Currently only
            <see cref="T:Lucene.Net.Store.BufferedIndexInput"/> respects this parameter. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="len"> the number of bytes to read </param>
            <param name="useBuffer"> set to false if the caller will handle
            buffering. </param>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadInt16">
            <summary>
            Reads two bytes and returns a <see cref="T:System.Int16"/>. 
            <para/>
            LUCENENET NOTE: Important - always cast to ushort (System.UInt16) before using to ensure
            the value is positive!
            <para/>
            NOTE: this was readShort() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteInt16(System.Int16)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadInt32">
            <summary>
            Reads four bytes and returns an <see cref="T:System.Int32"/>. 
            <para/>
            NOTE: this was readInt() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadVInt32">
            <summary>
            Reads an <see cref="T:System.Int32"/> stored in variable-length format.  Reads between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            <para/>
            The format is described further in <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>.
            <para/>
            NOTE: this was readVInt() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadInt64">
            <summary>
            Reads eight bytes and returns a <see cref="T:System.Int64"/>. 
            <para/>
            NOTE: this was readLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadVInt64">
            <summary>
            Reads a <see cref="T:System.Int64"/> stored in variable-length format.  Reads between one and
            nine bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            <para/>
            The format is described further in <seealso cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>.
            <para/>
            NOTE: this was readVLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadString">
            <summary>
            Reads a <see cref="T:System.String"/>. </summary>
            <seealso cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.Clone">
             <summary>
             Returns a clone of this stream.
            
             <para/>Clones of a stream access the same data, and are positioned at the same
             point as the stream they were cloned from.
            
             <para/>Expert: Subclasses must ensure that clones may be positioned at
             different points in the input from each other and from the stream they
             were cloned from.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadStringStringMap">
            <summary>
            Reads a IDictionary&lt;string,string&gt; previously written
             with <see cref="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.ReadStringSet">
            <summary>
            Reads a ISet&lt;string&gt; previously written
            with <see cref="M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataInput.SkipBytes(System.Int64)">
            <summary>
            Skip over <paramref name="numBytes"/> bytes. The contract on this method is that it
            should have the same behavior as reading the same number of bytes into a
            buffer and discarding its content. Negative values of <paramref name="numBytes"/>
            are not supported.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.DataOutput">
             <summary>
             Abstract base class for performing write operations of Lucene's low-level
             data types.
            
             <para/><see cref="T:Lucene.Net.Store.DataOutput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position).
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteByte(System.Byte)">
            <summary>
            Writes a single byte.
            <para/>
            The most primitive data type is an eight-bit byte. Files are
            accessed as sequences of bytes. All other data types are defined
            as sequences of bytes, so file formats are byte-order independent.
            </summary>
            <seealso cref="!:IndexInput.ReadByte()"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32)">
            <summary>
            Writes an array of bytes.
            </summary>
            <param name="b">the bytes to write</param>
            <param name="length">the number of bytes to write</param>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes an array of bytes. </summary>
            <param name="b"> the bytes to write </param>
            <param name="offset"> the offset in the byte array </param>
            <param name="length"> the number of bytes to write </param>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadBytes(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> as four bytes.
            <para/>
            32-bit unsigned integer written as four bytes, high-order bytes first.
            <para/>
            NOTE: this was writeInt() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadInt32"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteInt16(System.Int16)">
            <summary>
            Writes a short as two bytes. 
            <para/>
            NOTE: this was writeShort() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadInt16"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> in a variable-length format.  Writes between one and
            five bytes.  Smaller values take fewer bytes.  Negative numbers are
            supported, but should be avoided.
            <para>VByte is a variable-length format for positive integers is defined where the
            high-order bit of each byte indicates whether more bytes remain to be read. The
            low-order seven bits are appended as increasingly more significant bits in the
            resulting integer value. Thus values from zero to 127 may be stored in a single
            byte, values from 128 to 16,383 may be stored in two bytes, and so on.</para>
            <para>VByte Encoding Example</para>
            <list type="table">
                <listheader>
                    <term>Value</term>
                    <term>Byte 1</term>
                    <term>Byte 2</term>
                    <term>Byte 3</term>
                </listheader>
                <item>
                    <term>0</term>
                    <term>00000000</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>1</term>
                    <term>00000001</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>2</term>
                    <term>00000010</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>...</term>
                    <term></term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>127</term>
                    <term>01111111</term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>128</term>
                    <term>10000000</term>
                    <term>00000001</term>
                    <term></term>
                </item>
                <item>
                    <term>129</term>
                    <term>10000001</term>
                    <term>00000001</term>
                    <term></term>
                </item>
                <item>
                    <term>130</term>
                    <term>10000010</term>
                    <term>00000001</term>
                    <term></term>
                </item>
                <item>
                    <term>...</term>
                    <term></term>
                    <term></term>
                    <term></term>
                </item>
                <item>
                    <term>16,383</term>
                    <term>11111111</term>
                    <term>01111111</term>
                    <term></term>
                </item>
                <item>
                    <term>16,384</term>
                    <term>10000000</term>
                    <term>10000000</term>
                    <term>00000001</term>
                </item>
                <item>
                    <term>16,385</term>
                    <term>10000001</term>
                    <term>10000000</term>
                    <term>00000001</term>
                </item>
                <item>
                    <term>...</term>
                    <term></term>
                    <term></term>
                    <term></term>
                </item>
            </list>
            
            <para>this provides compression while still being efficient to decode.</para>
            <para/>
            NOTE: this was writeVInt() in Lucene
            </summary>
            <param name="i"> Smaller values take fewer bytes.  Negative numbers are
            supported, but should be avoided. </param>
            <exception cref="T:System.IO.IOException"> If there is an I/O error writing to the underlying medium. </exception>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadVInt32"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteInt64(System.Int64)">
            <summary>
            Writes a <see cref="T:System.Int64"/> as eight bytes.
            <para/>
            64-bit unsigned integer written as eight bytes, high-order bytes first.
            <para/>
            NOTE: this was writeLong() in Lucene
            </summary>
            <seealso cref="!:DataInput.ReadLong()"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteVInt64(System.Int64)">
            <summary>
            Writes an <see cref="T:System.Int64"/> in a variable-length format.  Writes between one and nine
            bytes.  Smaller values take fewer bytes.  Negative numbers are not
            supported.
            <para/>
            The format is described further in <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>. 
            <para/>
            NOTE: this was writeVLong() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadVInt64"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteString(System.String)">
            <summary>
            Writes a string.
            <para/>
            Writes strings as UTF-8 encoded bytes. First the length, in bytes, is
            written as a <see cref="M:Lucene.Net.Store.DataOutput.WriteVInt32(System.Int32)"/>, followed by the bytes.
            </summary>
            <seealso cref="M:Lucene.Net.Store.DataInput.ReadString"/>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.CopyBytes(Lucene.Net.Store.DataInput,System.Int64)">
            <summary>
            Copy numBytes bytes from input to ourself. </summary>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteStringStringMap(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>
            Writes a <see cref="T:IDictionary{string, string}"/>.
            <para/>
            First the size is written as an <see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>,
            followed by each key-value pair written as two consecutive
            <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>s.
            </summary>
            <param name="map"> Input <see cref="T:IDictionary{string, string}"/>. May be <c>null</c> (equivalent to an empty dictionary) </param>
        </member>
        <member name="M:Lucene.Net.Store.DataOutput.WriteStringSet(System.Collections.Generic.ISet{System.String})">
            <summary>
            Writes a <see cref="T:System.String"/> set.
            <para/>
            First the size is written as an <see cref="M:Lucene.Net.Store.DataOutput.WriteInt32(System.Int32)"/>,
            followed by each value written as a
            <see cref="M:Lucene.Net.Store.DataOutput.WriteString(System.String)"/>.
            </summary>
            <param name="set"> Input <see cref="T:ISet{string}"/>. May be <c>null</c> (equivalent to an empty set) </param>
        </member>
        <member name="T:Lucene.Net.Store.Directory">
            <summary>
            A <see cref="T:Lucene.Net.Store.Directory"/> is a flat list of files.  Files may be written once, when they
            are created.  Once a file is created it may only be opened for read, or
            deleted.  Random access is permitted both when reading and writing.
            <para/>
            .NET's i/o APIs not used directly, but rather all i/o is
            through this API.  This permits things such as: 
            <list type="bullet">
                <item> implementation of RAM-based indices;</item>
                <item> implementation indices stored in a database;</item>
                <item> implementation of an index as a single file;</item>
            </list>
            <para/>
            Directory locking is implemented by an instance of
            <see cref="T:Lucene.Net.Store.LockFactory"/>, and can be changed for each <see cref="T:Lucene.Net.Store.Directory"/>
            instance using <see cref="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ListAll">
            <summary>
            Returns an array of strings, one for each file in the directory.
            </summary>
            <exception cref="T:System.IO.DirectoryNotFoundException"> if the directory is not prepared for any
                    write operations (such as <see cref="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)"/>). </exception>
            <exception cref="T:System.IO.IOException"> in case of other IO errors </exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileExists(System.String)">
            <summary>
            Returns <c>true</c> iff a file with the given name exists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.FileLength(System.String)">
            <summary>
            Returns the length of a file in the directory. this method follows the
            following contract:
            <list>
                <item>Throws <see cref="T:System.IO.FileNotFoundException"/>
                    if the file does not exist.</item>
                <item>Returns a value &gt;=0 if the file exists, which specifies its length.</item>
            </list>
            </summary>
            <param name="name"> the name of the file for which to return the length. </param>
            <exception cref="T:System.IO.IOException"> if there was an IO error while retrieving the file's
                    length. </exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates a new, empty file in the directory with the given name.
            Returns a stream writing this file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Sync(System.Collections.Generic.ICollection{System.String})">
            <summary>
            Ensure that any writes to these files are moved to
            stable storage.  Lucene uses this to properly commit
            changes to the index, to prevent a machine/OS crash
            from corrupting the index.<br/>
            <br/>
            NOTE: Clients may call this method for same files over
            and over again, so some impls might optimize for that.
            For other impls the operation can be a noop, for various
            reasons.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file, with the
            specified read buffer size.  The particular <see cref="T:Lucene.Net.Store.Directory"/>
            implementation may ignore the buffer size.  Currently
            the only <see cref="T:Lucene.Net.Store.Directory"/> implementations that respect this
            parameter are <see cref="T:Lucene.Net.Store.FSDirectory"/> and 
            <see cref="T:Lucene.Net.Store.CompoundFileDirectory"/>.
            <para/>Throws <see cref="T:System.IO.FileNotFoundException"/>
            if the file does not exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.OpenChecksumInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file, computing checksum as it reads </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.MakeLock(System.String)">
            <summary>
            Construct a <see cref="T:Lucene.Net.Store.Lock"/>. </summary>
            <param name="name"> the name of the lock file </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.ClearLock(System.String)">
            <summary>
            Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use. </summary>
            <param name="name"> name of the lock to be cleared. </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Dispose">
            <summary>
            Disposes the store. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Dispose(System.Boolean)">
            <summary>
            Disposes the store. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)">
            <summary>
            Set the <see cref="T:Lucene.Net.Store.LockFactory"/> that this <see cref="T:Lucene.Net.Store.Directory"/> instance should
            use for its locking implementation.  Each * instance of
            <see cref="T:Lucene.Net.Store.LockFactory"/> should only be used for one directory (ie,
            do not share a single instance across multiple
            Directories).
            </summary>
            <param name="lockFactory"> instance of <see cref="T:Lucene.Net.Store.LockFactory"/>. </param>
        </member>
        <member name="P:Lucene.Net.Store.Directory.LockFactory">
            <summary>
            Get the <see cref="T:Lucene.Net.Store.LockFactory"/> that this <see cref="T:Lucene.Net.Store.Directory"/> instance is
            using for its locking implementation.  Note that this
            may be null for <see cref="T:Lucene.Net.Store.Directory"/> implementations that provide
            their own locking implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.GetLockID">
            <summary>
            Return a string identifier that uniquely differentiates
            this <see cref="T:Lucene.Net.Store.Directory"/> instance from other <see cref="T:Lucene.Net.Store.Directory"/> instances.
            This ID should be the same if two <see cref="T:Lucene.Net.Store.Directory"/> instances
            (even in different AppDomains and/or on different machines)
            are considered "the same index".  This is how locking
            "scopes" to the right index.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.Copy(Lucene.Net.Store.Directory,System.String,System.String,Lucene.Net.Store.IOContext)">
             <summary>
             Copies the file <paramref name="src"/> to <seealso cref="T:Lucene.Net.Store.Directory"/> <paramref name="to"/> under the new
             file name <paramref name="dest"/>.
             <para/>
             If you want to copy the entire source directory to the destination one, you
             can do so like this:
            
             <code>
             Directory to; // the directory to copy to
             foreach (string file in dir.ListAll()) {
                 dir.Copy(to, file, newFile, IOContext.DEFAULT); // newFile can be either file, or a new name
             }
             </code>
             <para/>
             <b>NOTE:</b> this method does not check whether <paramref name="dest"/> exist and will
             overwrite it if it does.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.CreateSlicer(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.Directory.IndexInputSlicer"/> for the given file name.
            <see cref="T:Lucene.Net.Store.Directory.IndexInputSlicer"/> allows other <see cref="T:Lucene.Net.Store.Directory"/> implementations to
            efficiently open one or more sliced <see cref="T:Lucene.Net.Store.IndexInput"/> instances from a
            single file handle. The underlying file handle is kept open until the
            <see cref="T:Lucene.Net.Store.Directory.IndexInputSlicer"/> is closed.
            <para/>Throws <see cref="T:System.IO.FileNotFoundException"/>
            if the file does not exist.
            <para/>
            @lucene.internal
            @lucene.experimental
            </summary>
            <exception cref="T:System.IO.IOException">
                      if an <seealso cref="T:System.IO.IOException"/> occurs</exception>
        </member>
        <member name="M:Lucene.Net.Store.Directory.EnsureOpen">
            <exception cref="T:System.ObjectDisposedException"> if this Directory is closed </exception>
        </member>
        <member name="T:Lucene.Net.Store.Directory.IndexInputSlicer">
            <summary>
            Allows to create one or more sliced <see cref="T:Lucene.Net.Store.IndexInput"/> instances from a single
            file handle. Some <see cref="T:Lucene.Net.Store.Directory"/> implementations may be able to efficiently map slices of a file
            into memory when only certain parts of a file are required.
            <para/>
            @lucene.internal
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.IndexInputSlicer.OpenSlice(System.String,System.Int64,System.Int64)">
            <summary>
            Returns an <see cref="T:Lucene.Net.Store.IndexInput"/> slice starting at the given offset with the given length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.IndexInputSlicer.OpenFullSlice">
            <summary>
            Returns an <see cref="T:Lucene.Net.Store.IndexInput"/> slice starting at offset <c>0</c> with a
            length equal to the length of the underlying file </summary>
        </member>
        <member name="T:Lucene.Net.Store.Directory.SlicedIndexInput">
            <summary>
            Implementation of an <see cref="T:Lucene.Net.Store.IndexInput"/> that reads from a portion of
            a file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Expert: implements buffer refill.  Reads bytes from the current
            position in the input. </summary>
            <param name="b"> the array to read bytes into </param>
            <param name="offset"> the offset in the array to start storing bytes </param>
            <param name="len"> the number of bytes to read </param>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.SeekInternal(System.Int64)">
            <summary>
            Expert: implements seek.  Sets current position in this file, where
            the next <see cref="M:Lucene.Net.Store.Directory.SlicedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/> will occur. 
            </summary>
            <seealso cref="M:Lucene.Net.Store.Directory.SlicedIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.Directory.SlicedIndexInput.Dispose(System.Boolean)">
            <summary>
            Closes the stream to further operations.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.FileSwitchDirectory">
             <summary>
             Expert: A <see cref="T:Lucene.Net.Store.Directory"/> instance that switches files between
             two other <see cref="T:Lucene.Net.Store.Directory"/> instances.
            
             <para/>Files with the specified extensions are placed in the
             primary directory; others are placed in the secondary
             directory.  The provided <see cref="T:ISet{string}"/> must not change once passed
             to this class, and must allow multiple threads to call
             contains at once.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="P:Lucene.Net.Store.FileSwitchDirectory.PrimaryDir">
            <summary>
            Return the primary directory </summary>
        </member>
        <member name="P:Lucene.Net.Store.FileSwitchDirectory.SecondaryDir">
            <summary>
            Return the secondary directory </summary>
        </member>
        <member name="M:Lucene.Net.Store.FileSwitchDirectory.GetExtension(System.String)">
            <summary>
            Utility method to return a file's extension. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FilterDirectory">
            <summary>
            Directory implementation that delegates calls to another directory.
            This class can be used to add limitations on top of an existing
            <see cref="T:Lucene.Net.Store.Directory"/> implementation such as
            rate limiting (<see cref="T:Lucene.Net.Store.RateLimitedDirectoryWrapper"/>) or to add additional
            sanity checks for tests. However, if you plan to write your own
            <see cref="T:Lucene.Net.Store.Directory"/> implementation, you should consider extending directly
            <see cref="T:Lucene.Net.Store.Directory"/> or <see cref="T:Lucene.Net.Store.BaseDirectory"/> rather than try to reuse
            functionality of existing <see cref="T:Lucene.Net.Store.Directory"/>s by extending this class.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FilterDirectory.#ctor(Lucene.Net.Store.Directory)">
            <summary>
            Sole constructor, typically called from sub-classes. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FilterDirectory.Delegate">
            <summary>
            Return the wrapped <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FlushInfo">
            <summary>
            <para>A FlushInfo provides information required for a FLUSH context.
            It is used as part of an <see cref="T:Lucene.Net.Store.IOContext"/> in case of FLUSH context.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FlushInfo.#ctor(System.Int32,System.Int64)">
            <summary>
            <para/>Creates a new <see cref="T:Lucene.Net.Store.FlushInfo"/> instance from
            the values required for a FLUSH <see cref="T:Lucene.Net.Store.IOContext"/> context.
            <para/>
            These values are only estimates and are not the actual values.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.FSDirectory">
             <summary>
             Base class for <see cref="P:Lucene.Net.Store.FSDirectory.Directory"/> implementations that store index
             files in the file system.
             <para/>
             There are currently three core
             subclasses:
            
             <list type="bullet">
            
                 <item> <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> is a straightforward
                     implementation using <see cref="T:System.IO.FileStream"/>.
                     However, it has poor concurrent performance
                     (multiple threads will bottleneck) as it
                     synchronizes when multiple threads read from the
                     same file.</item>
            
                 <item> <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> uses java.nio's
                     FileChannel's positional io when reading to avoid
                     synchronization when reading from the same file.
                     Unfortunately, due to a Windows-only <a
                     href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734">Sun
                     JRE bug</a> this is a poor choice for Windows, but
                     on all other platforms this is the preferred
                     choice. Applications using <see cref="M:System.Threading.Thread.Interrupt"/> or
                     <see cref="T:System.Threading.Tasks.Task`1"/> should use
                     <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> instead. See <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> java doc
                     for details.</item>
            
                 <item> <see cref="T:Lucene.Net.Store.MMapDirectory"/> uses memory-mapped IO when
                     reading. This is a good choice if you have plenty
                     of virtual memory relative to your index size, eg
                     if you are running on a 64 bit runtime, or you are
                     running on a 32 bit runtime but your index sizes are
                     small enough to fit into the virtual memory space.
                     <para/>
                     Applications using <see cref="M:System.Threading.Thread.Interrupt"/> or
                     <see cref="T:System.Threading.Tasks.Task"/> should use
                     <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> instead. See <see cref="T:Lucene.Net.Store.MMapDirectory"/>
                     doc for details.</item>
             </list>
            
             Unfortunately, because of system peculiarities, there is
             no single overall best implementation.  Therefore, we've
             added the <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.String)"/> method  (or one of its overloads), to allow Lucene to choose
             the best <see cref="T:Lucene.Net.Store.FSDirectory"/> implementation given your
             environment, and the known limitations of each
             implementation.  For users who have no reason to prefer a
             specific implementation, it's best to simply use 
             <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.String)"/>  (or one of its overloads).  For all others, you should instantiate the
             desired implementation directly.
            
             <para/>The locking implementation is by default 
             <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>, but can be changed by
             passing in a custom <see cref="T:Lucene.Net.Store.LockFactory"/> instance.
             </summary>
             <seealso cref="P:Lucene.Net.Store.FSDirectory.Directory"/>
        </member>
        <member name="F:Lucene.Net.Store.FSDirectory.DEFAULT_READ_CHUNK_SIZE">
            <summary>
            Default read chunk size: 8192 bytes (this is the size up to which the runtime
            does not allocate additional arrays while reading/writing) </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.FSDirectory"/> for the named location (ctor for subclasses). </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<seealso cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo)">
             <summary>
             Creates an <see cref="T:Lucene.Net.Store.FSDirectory"/> instance, trying to pick the
             best implementation given the current environment.
             The directory returned uses the <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            
             <para/>Currently this returns <see cref="T:Lucene.Net.Store.MMapDirectory"/> for most Solaris
             and Windows 64-bit runtimes, <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for other
             non-Windows runtimes, and <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for other
             runtimes on Windows. It is highly recommended that you consult the
             implementation's documentation for your platform before
             using this method.
            
             <para/><b>NOTE</b>: this method may suddenly change which
             implementation is returned from release to release, in
             the event that higher performance defaults become
             possible; if the precise implementation is important to
             your application, please instantiate it directly,
             instead. For optimal performance you should consider using
             <see cref="T:Lucene.Net.Store.MMapDirectory"/> on 64 bit runtimes.
            
             <para/>See <see cref="T:Lucene.Net.Store.FSDirectory"/>.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.String)">
            <summary>
            Just like <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo)"/>, but
            allows you to specify the directory as a <see cref="T:System.String"/>.
            </summary>
            <param name="path">The path (to a directory) to open</param>
            <returns>An open <see cref="T:Lucene.Net.Store.FSDirectory"/></returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Just like <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo)"/>, but allows you to
            also specify a custom <see cref="T:Lucene.Net.Store.LockFactory"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Open(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Just like <see cref="M:Lucene.Net.Store.FSDirectory.Open(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)"/>, but
            allows you to specify the directory as a <see cref="T:System.String"/>.
            </summary>
            <param name="path">The path (to a directory) to open</param>
            <param name="lockFactory"></param>
            <returns>An open <see cref="T:Lucene.Net.Store.FSDirectory"/></returns>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ListAll(System.IO.DirectoryInfo)">
            <summary>
            Lists all files (not subdirectories) in the
            directory.  This method never returns <c>null</c> (throws
            <seealso cref="T:System.IO.IOException"/> instead).
            </summary>
            <exception cref="T:System.IO.DirectoryNotFoundException"> if the directory
            does not exist, or does exist but is not a
            directory or is invalid (for example, it is on an unmapped drive). </exception>
            <exception cref="T:System.Security.SecurityException">The caller does not have the required permission.</exception>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ListAll">
            <summary>
            Lists all files (not subdirectories) in the
            directory. </summary>
            <seealso cref="M:Lucene.Net.Store.FSDirectory.ListAll(System.IO.DirectoryInfo)"/>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileExists(System.String)">
            <summary>
            Returns true iff a file with the given name exists. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FileLength(System.String)">
            <summary>
            Returns the length in bytes of a file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexOutput"/> for the file with the given name. </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.Dispose(System.Boolean)">
            <summary>
            Closes the store to future operations. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.Directory">
            <summary> the underlying filesystem directory </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.ToString">
            <summary>
            For debug output. </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSDirectory.ReadChunkSize">
            <summary>
            this setting has no effect anymore. </summary>
        </member>
        <member name="T:Lucene.Net.Store.FSDirectory.FSIndexOutput">
            <summary>
            Writes output with <see cref="M:System.IO.FileStream.Write(System.Byte[],System.Int32,System.Int32)"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSDirectory.FSIndexOutput.Seek(System.Int64)">
            <summary>
            Random-access methods </summary>
        </member>
        <member name="T:Lucene.Net.Store.FSLockFactory">
            <summary>
            Base class for file system based locking implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.FSLockFactory.m_lockDir">
            <summary>
            Directory for the lock files.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.FSLockFactory.SetLockDir(System.IO.DirectoryInfo)">
            <summary>
            Set the lock directory. This property can be only called
            once to initialize the lock directory. It is used by <see cref="T:Lucene.Net.Store.FSDirectory"/>
            to set the lock directory to itself.
            Subclasses can also use this property to set the directory
            in the constructor.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.FSLockFactory.LockDir">
            <summary>
            Gets the lock directory.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexInput">
             <summary>
             Abstract base class for input from a file in a <see cref="T:Lucene.Net.Store.Directory"/>.  A
             random-access input stream.  Used for all Lucene index input operations.
            
             <para/><see cref="T:Lucene.Net.Store.IndexInput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position). To allow
             multithreaded use, every <see cref="T:Lucene.Net.Store.IndexInput"/> instance must be cloned before
             used in another thread. Subclasses must therefore implement <see cref="M:Lucene.Net.Store.IndexInput.Clone"/>,
             returning a new <see cref="T:Lucene.Net.Store.IndexInput"/> which operates on the same underlying
             resource, but positioned independently. Lucene never closes cloned
             <see cref="T:Lucene.Net.Store.IndexInput"/>s, it will only do this on the original one.
             The original instance must take care that cloned instances throw
             <see cref="T:System.ObjectDisposedException"/> when the original one is closed.
             </summary>
             <seealso cref="T:Lucene.Net.Store.Directory"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.#ctor(System.String)">
            <summary>
            <paramref name="resourceDescription"/> should be a non-null, opaque string
            describing this resource; it's returned from
            <see cref="M:Lucene.Net.Store.IndexInput.ToString"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Dispose">
            <summary>
            Closes the stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Dispose(System.Boolean)">
            <summary>
            Closes the stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.GetFilePointer">
            <summary>
            Returns the current position in this file, where the next read will
            occur. </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Seek(System.Int64)">
            <summary>
            Sets current position in this file, where the next read will occur.
            </summary>
            <seealso cref="M:Lucene.Net.Store.IndexInput.GetFilePointer"/>
        </member>
        <member name="P:Lucene.Net.Store.IndexInput.Length">
            <summary>
            The number of bytes in the file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.ToString">
            <summary>
            Returns the resourceDescription that was passed into the constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexInput.Clone">
             <summary>
             Returns a clone of this stream.
            
             <para/>Clones of a stream access the same data, and are positioned at the same
             point as the stream they were cloned from.
            
             <para/>Expert: Subclasses must ensure that clones may be positioned at
             different points in the input from each other and from the stream they
             were cloned from.
             
             <para/><b>Warning:</b> Lucene never closes cloned
             <see cref="T:Lucene.Net.Store.IndexInput"/>s, it will only do this on the original one.
             The original instance must take care that cloned instances throw
             <see cref="T:System.ObjectDisposedException"/> when the original one is closed.
             </summary>
        </member>
        <member name="T:Lucene.Net.Store.IndexOutput">
             <summary>
             Abstract base class for output to a file in a <see cref="T:Lucene.Net.Store.Directory"/>.  A random-access
             output stream.  Used for all Lucene index output operations.
            
             <para/><see cref="T:Lucene.Net.Store.IndexOutput"/> may only be used from one thread, because it is not
             thread safe (it keeps internal state like file position).
             </summary>
             <seealso cref="T:Lucene.Net.Store.Directory"/>
             <seealso cref="T:Lucene.Net.Store.IndexInput"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Flush">
            <summary>
            Forces any buffered output to be written. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Dispose">
            <summary>
            Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Dispose(System.Boolean)">
            <summary>
            Closes this stream to further operations. </summary>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.GetFilePointer">
            <summary>
            Returns the current position in this file, where the next write will
            occur. </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.IndexOutput.Seek(System.Int64)">
            <summary>
            Sets current position in this file, where the next write will occur. </summary>
            <seealso cref="M:Lucene.Net.Store.IndexOutput.GetFilePointer"/>
        </member>
        <member name="P:Lucene.Net.Store.IndexOutput.Checksum">
            <summary>
            Returns the current checksum of bytes written so far </summary>
        </member>
        <member name="P:Lucene.Net.Store.IndexOutput.Length">
            <summary>
            Gets or Sets the file length. By default, this property's setter does
            nothing (it's optional for a <see cref="T:Lucene.Net.Store.Directory"/> to implement
            it).  But, certain <see cref="T:Lucene.Net.Store.Directory"/> implementations (for 
            example <see cref="T:Lucene.Net.Store.FSDirectory"/>) can use this to inform the
            underlying IO system to pre-allocate the file to the
            specified size.  If the length is longer than the
            current file length, the bytes added to the file are
            undefined.  Otherwise the file is truncated.</summary>
        </member>
        <member name="T:Lucene.Net.Store.InputStreamDataInput">
            <summary>
            A <see cref="T:Lucene.Net.Store.DataInput"/> wrapping a plain <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IOContext">
            <summary>
            <see cref="T:Lucene.Net.Store.IOContext"/> holds additional details on the merge/search context. A <see cref="T:Lucene.Net.Store.IOContext"/>
            object can never be initialized as null as passed as a parameter to either
            <see cref="M:Lucene.Net.Store.Directory.OpenInput(System.String,Lucene.Net.Store.IOContext)"/> or
            <see cref="M:Lucene.Net.Store.Directory.CreateOutput(System.String,Lucene.Net.Store.IOContext)"/>
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.IOContext.UsageContext">
            <summary>
            <see cref="T:Lucene.Net.Store.IOContext.UsageContext"/> is a enumeration which specifies the context in which the <see cref="T:Lucene.Net.Store.Directory"/>
            is being used for.
            <para/>
            NOTE: This was Context in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.IOContext.Context">
            <summary>
            A <see cref="T:Lucene.Net.Store.IOContext.UsageContext"/> setting
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.IOContext.#ctor(Lucene.Net.Store.IOContext,System.Boolean)">
            <summary>
            This constructor is used to initialize a <see cref="T:Lucene.Net.Store.IOContext"/> instance with a new value for the <see cref="P:Lucene.Net.Store.IOContext.ReadOnce"/> property. </summary>
            <param name="ctxt"> <see cref="T:Lucene.Net.Store.IOContext"/> object whose information is used to create the new instance except the <see cref="P:Lucene.Net.Store.IOContext.ReadOnce"/> property. </param>
            <param name="readOnce"> The new <see cref="T:Lucene.Net.Store.IOContext"/> object will use this value for <see cref="P:Lucene.Net.Store.IOContext.ReadOnce"/>.  </param>
        </member>
        <member name="T:Lucene.Net.Store.Lock">
            <summary>
            An interprocess mutex lock.
            <para/>Typical use might look like:
            
            <code>
                var result = Lock.With.NewAnonymous&lt;string&gt;(
                    @lock: directory.MakeLock("my.lock"), 
                    lockWaitTimeout: Lock.LOCK_OBTAIN_WAIT_FOREVER, 
                    doBody: () =>
                {
                    //... code to execute while locked ...
                    return "the result";
                }).Run();
            </code>
            </summary>
            <seealso cref="M:Lucene.Net.Store.Directory.MakeLock(System.String)"/>
        </member>
        <member name="F:Lucene.Net.Store.Lock.LOCK_POLL_INTERVAL">
            <summary>
            How long <see cref="M:Lucene.Net.Store.Lock.Obtain(System.Int64)"/> waits, in milliseconds,
            in between attempts to acquire the lock.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER">
            <summary>
            Pass this value to <see cref="M:Lucene.Net.Store.Lock.Obtain(System.Int64)"/> to try
            forever to obtain the lock.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.NewAnonymous``1(Lucene.Net.Store.Lock,System.Int32,System.Func{``0})">
            <summary>
            Creates a new instance with the ability to specify the <see cref="!:With.DoBody()"/> method
            through the <paramref name="doBody"/> argument
            <para/>
            Simple example:
            <code>
                var result = Lock.With.NewAnonymous&lt;string&gt;(
                    @lock: directory.MakeLock("my.lock"), 
                    lockWaitTimeout: Lock.LOCK_OBTAIN_WAIT_FOREVER, 
                    doBody: () =>
                {
                    //... code to execute while locked ...
                    return "the result";
                }).Run();
            </code>
            <para/>
            The result of the operation is the value that is returned from <paramref name="doBody"/>
            (i.e. () => { return "the result"; }). The type of <typeparam name="T"/> determines the
            return type of the operation.
            </summary>
            <param name="lock"> the <see cref="T:Lucene.Net.Store.Lock"/> instance to use </param>
            <param name="lockWaitTimeout"> length of time to wait in
                   milliseconds or 
                   <see cref="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER"/> to retry forever </param>
            <param name="doBody"> a delegate method that </param>
            <returns>The value that is returned from the <paramref name="doBody"/> delegate method (i.e. () => { return theObject; })</returns>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain">
            <summary>
            Attempts to obtain exclusive access and immediately return
            upon success or failure.  Use <see cref="M:Lucene.Net.Store.Lock.Dispose"/> to
            release the lock. </summary>
            <returns> true iff exclusive access is obtained </returns>
        </member>
        <member name="P:Lucene.Net.Store.Lock.FailureReason">
            <summary>
            If a lock obtain called, this failureReason may be set
            with the "root cause" <see cref="T:System.Exception"/> as to why the lock was
            not obtained.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Obtain(System.Int64)">
            <summary>
            Attempts to obtain an exclusive lock within amount of
            time given. Polls once per <see cref="F:Lucene.Net.Store.Lock.LOCK_POLL_INTERVAL"/>
            (currently 1000) milliseconds until <paramref name="lockWaitTimeout"/> is
            passed.
            </summary>
            <param name="lockWaitTimeout"> length of time to wait in
                   milliseconds or 
                   <see cref="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER"/> to retry forever </param>
            <returns> <c>true</c> if lock was obtained </returns>
            <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if lock wait times out </exception>
            <exception cref="T:System.ArgumentException"> if <paramref name="lockWaitTimeout"/> is
                    out of bounds </exception>
            <exception cref="T:System.IO.IOException"> if <see cref="M:Lucene.Net.Store.Lock.Obtain"/> throws <see cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Dispose">
            <summary>
            Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.Dispose(System.Boolean)">
            <summary>
            Releases exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.IsLocked">
            <summary>
            Returns <c>true</c> if the resource is currently locked.  Note that one must
            still call <see cref="M:Lucene.Net.Store.Lock.Obtain"/> before using the resource.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.Lock.With`1">
            <summary>
            Utility class for executing code with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With`1.#ctor(Lucene.Net.Store.Lock,System.Int64)">
            <summary>
            Constructs an executor that will grab the named <paramref name="lock"/>. </summary>
            <param name="lock"> the <see cref="T:Lucene.Net.Store.Lock"/> instance to use </param>
            <param name="lockWaitTimeout"> length of time to wait in
                   milliseconds or 
                   <see cref="F:Lucene.Net.Store.Lock.LOCK_OBTAIN_WAIT_FOREVER"/> to retry forever </param>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With`1.DoBody">
            <summary>
            Code to execute with exclusive access. </summary>
        </member>
        <member name="M:Lucene.Net.Store.Lock.With`1.Run">
            <summary>
            Calls <see cref="M:Lucene.Net.Store.Lock.With`1.DoBody"/> while <i>lock</i> is obtained.  Blocks if lock
            cannot be obtained immediately.  Retries to obtain lock once per second
            until it is obtained, or until it has tried ten times. Lock is released when
            <see cref="M:Lucene.Net.Store.Lock.With`1.DoBody"/> exits. </summary>
            <exception cref="T:Lucene.Net.Store.LockObtainFailedException"> if lock could not
            be obtained </exception>
            <exception cref="T:System.IO.IOException"> if <see cref="M:Lucene.Net.Store.Lock.Obtain"/> throws <see cref="T:System.IO.IOException"/> </exception>
        </member>
        <member name="T:Lucene.Net.Store.Lock.AnonymousWith`1">
            <summary>
            LUCENENET specific class to simulate the anonymous creation of a With class in Java
            by using deletate methods.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.LockFactory">
             <summary>
             <para>Base class for Locking implementation.  <see cref="T:Lucene.Net.Store.Directory"/> uses
             instances of this class to implement locking.</para>
            
             <para>Lucene uses <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> by default for
             <see cref="T:Lucene.Net.Store.FSDirectory"/>-based index directories.</para>
            
             <para>Special care needs to be taken if you change the locking
             implementation: First be certain that no writer is in fact
             writing to the index otherwise you can easily corrupt
             your index. Be sure to do the <see cref="T:Lucene.Net.Store.LockFactory"/> change on all Lucene
             instances and clean up all leftover lock files before starting
             the new configuration for the first time. Different implementations
             can not work together!</para>
            
             <para>If you suspect that some <see cref="T:Lucene.Net.Store.LockFactory"/> implementation is
             not working properly in your environment, you can easily
             test it by using <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>, 
             <see cref="T:Lucene.Net.Store.LockVerifyServer"/> and <see cref="T:Lucene.Net.Store.LockStressTest"/>.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/>
             <seealso cref="T:Lucene.Net.Store.LockStressTest"/>
             <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory"/>
        </member>
        <member name="P:Lucene.Net.Store.LockFactory.LockPrefix">
            <summary>
            Gets or Sets the prefix in use for all locks created in this
            <see cref="T:Lucene.Net.Store.LockFactory"/>.  This is normally called once, when a
            <see cref="T:Lucene.Net.Store.Directory"/> gets this <see cref="T:Lucene.Net.Store.LockFactory"/> instance.  However, you
            can also call this (after this instance is assigned to
            a <see cref="T:Lucene.Net.Store.Directory"/>) to override the prefix in use.  This
            is helpful if you're running Lucene on machines that
            have different mount points for the same shared
            directory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.MakeLock(System.String)">
            <summary>
            Return a new <see cref="T:Lucene.Net.Store.Lock"/> instance identified by <paramref name="lockName"/>. </summary>
            <param name="lockName"> name of the lock to be created. </param>
        </member>
        <member name="M:Lucene.Net.Store.LockFactory.ClearLock(System.String)">
            <summary>
            Attempt to clear (forcefully unlock and remove) the
            specified lock.  Only call this at a time when you are
            certain this lock is no longer in use. </summary>
            <param name="lockName"> name of the lock to be cleared. </param>
        </member>
        <member name="T:Lucene.Net.Store.LockObtainFailedException">
            <summary>
            This exception is thrown when the <c>write.lock</c>
            could not be acquired.  This
            happens when a writer tries to open an index
            that another writer already has open. </summary>
            <seealso cref="M:Lucene.Net.Store.Lock.Obtain(System.Int64)"/>
        </member>
        <member name="M:Lucene.Net.Store.LockObtainFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Store.LockReleaseFailedException">
            <summary>
            This exception is thrown when the <c>write.lock</c>
            could not be released. </summary>
            <seealso cref="M:Lucene.Net.Store.Lock.Dispose"/>
        </member>
        <member name="M:Lucene.Net.Store.LockReleaseFailedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Store.LockStressTest">
            <summary>
            Simple standalone tool that forever acquires &amp; releases a
            lock using a specific <see cref="T:Lucene.Net.Store.LockFactory"/>.  Run without any args
            to see usage.
            </summary>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory"/>
            <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/>
        </member>
        <member name="T:Lucene.Net.Store.LockVerifyServer">
            <summary>
            Simple standalone server that must be running when you
            use <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>.  This server simply
            verifies at most one process holds the lock at a time.
            Run without any args to see usage.
            </summary>
            <seealso cref="T:Lucene.Net.Store.VerifyingLockFactory"/>
            <seealso cref="T:Lucene.Net.Store.LockStressTest"/>
        </member>
        <member name="T:Lucene.Net.Store.MergeInfo">
            <summary>
            <para>A MergeInfo provides information required for a MERGE context.
            It is used as part of an <see cref="T:Lucene.Net.Store.IOContext"/> in case of MERGE context.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.MergeInfo.#ctor(System.Int32,System.Int64,System.Boolean,System.Int32)">
            <summary>
            <para/>Creates a new <see cref="T:Lucene.Net.Store.MergeInfo"/> instance from
            the values required for a MERGE <see cref="T:Lucene.Net.Store.IOContext"/> context.
            <para/>
            These values are only estimates and are not the actual values.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.MMapDirectory">
             <summary>
             File-based <see cref="T:Lucene.Net.Store.Directory"/> implementation that uses
             <see cref="T:System.IO.MemoryMappedFiles.MemoryMappedFile"/> for reading, and
             <see cref="T:Lucene.Net.Store.FSDirectory.FSIndexOutput"/> for writing.
            
             <para/><b>NOTE</b>: memory mapping uses up a portion of the
             virtual memory address space in your process equal to the
             size of the file being mapped.  Before using this class,
             be sure your have plenty of virtual address space, e.g. by
             using a 64 bit runtime, or a 32 bit runtime with indexes that are
             guaranteed to fit within the address space.
             On 32 bit platforms also consult <see cref="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)"/>
             if you have problems with mmap failing because of fragmented
             address space. If you get an <see cref="T:System.OutOfMemoryException"/>, it is recommended
             to reduce the chunk size, until it works.
             <para>
             <b>NOTE:</b> Accessing this class either directly or
             indirectly from a thread while it's interrupted can close the
             underlying channel immediately if at the same time the thread is
             blocked on IO. The channel will remain closed and subsequent access
             to <see cref="T:Lucene.Net.Store.MMapDirectory"/> will throw a <see cref="T:System.ObjectDisposedException"/>.
             </para>
             </summary>
        </member>
        <member name="F:Lucene.Net.Store.MMapDirectory.DEFAULT_MAX_BUFF">
            <summary>
            Default max chunk size. </summary>
            <seealso cref="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location, specifying the
            maximum chunk size used for memory mapping.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or <c>null</c> for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <param name="maxChunkSize"> maximum chunk size (default is 1 GiBytes for
            64 bit runtimes and 256 MiBytes for 32 bit runtimes) used for memory mapping.
            <para/>
            Especially on 32 bit platform, the address space can be very fragmented,
            so large index files cannot be mapped. Using a lower chunk size makes
            the directory implementation a little bit slower (as the correct chunk
            may be resolved on lots of seeks) but the chance is higher that mmap
            does not fail. On 64 bit platforms, this parameter should always
            be <c>1 &lt;&lt; 30</c>, as the address space is big enough.
            <para/>
            <b>Please note:</b> The chunk size is always rounded down to a power of 2.
            </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory,System.Int32)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.MMapDirectory"/> for the named location, specifying the
            maximum chunk size used for memory mapping.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or <c>null</c> for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <param name="maxChunkSize"> maximum chunk size (default is 1 GiBytes for
            64 bit runtimes and 256 MiBytes for 32 bit runtimes) used for memory mapping.
            <para/>
            Especially on 32 bit platform, the address space can be very fragmented,
            so large index files cannot be mapped. Using a lower chunk size makes
            the directory implementation a little bit slower (as the correct chunk
            may be resolved on lots of seeks) but the chance is higher that mmap
            does not fail. On 64 bit platforms, this parameter should always
            be <c>1 &lt;&lt; 30</c>, as the address space is big enough.
            <para/>
            <b>Please note:</b> The chunk size is always rounded down to a power of 2.
            </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="F:Lucene.Net.Store.MMapDirectory.UNMAP_SUPPORTED">
            <summary>
            <c>true</c>, if this platform supports unmapping mmapped files.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.MMapDirectory.UseUnmap">
            <summary>
            This property enables the workaround for unmapping the buffers
            from address space after closing <see cref="T:Lucene.Net.Store.IndexInput"/>, that is
            mentioned in the bug report. This hack may fail on non-Sun JVMs.
            It forcefully unmaps the buffer on close by using
            an undocumented internal cleanup functionality.
            <para/><b>NOTE:</b> Enabling this is completely unsupported
            by Java and may lead to JVM crashes if <see cref="T:Lucene.Net.Store.IndexInput"/>
            is closed while another thread is still accessing it (SIGSEGV). </summary>
            <exception cref="T:System.ArgumentException"> if <see cref="F:Lucene.Net.Store.MMapDirectory.UNMAP_SUPPORTED"/>
            is <c>false</c> and the workaround cannot be enabled. </exception>
        </member>
        <member name="P:Lucene.Net.Store.MMapDirectory.MaxChunkSize">
            <summary>
            Returns the current mmap chunk size. </summary>
            <seealso cref="M:Lucene.Net.Store.MMapDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory,System.Int32)"/>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexInput"/> for the file with the given name. </summary>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.MMapIndexInput.FreeBuffer(Lucene.Net.Support.IO.ByteBuffer)">
            <summary>
            Try to unmap the buffer, this method silently fails if no support
            for that in the runtime. On Windows, this leads to the fact,
            that mmapped files cannot be modified or deleted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.MMapDirectory.Map(Lucene.Net.Store.MMapDirectory.MMapIndexInput,System.IO.FileStream,System.Int64,System.Int64)">
            <summary>
            Maps a file into a set of buffers </summary>
        </member>
        <member name="T:Lucene.Net.Store.NativeFSLockFactory">
             <summary>
             <para>Implements <see cref="T:Lucene.Net.Store.LockFactory"/> using native OS file
             locks.  For NFS based access to an index, it's
             recommended that you try <see cref="T:Lucene.Net.Store.SimpleFSLockFactory"/>
             first and work around the one limitation that a lock file
             could be left when the runtime exits abnormally.</para>
            
             <para>The primary benefit of <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> is
             that locks (not the lock file itsself) will be properly
             removed (by the OS) if the runtime has an abnormal exit.</para>
            
             <para>Note that, unlike <see cref="T:Lucene.Net.Store.SimpleFSLockFactory"/>, the existence of
             leftover lock files in the filesystem is fine because the OS
             will free the locks held against these files even though the
             files still remain. Lucene will never actively remove the lock
             files, so although you see them, the index may not be locked.</para>
            
             <para>Special care needs to be taken if you change the locking
             implementation: First be certain that no writer is in fact
             writing to the index otherwise you can easily corrupt
             your index. Be sure to do the <see cref="T:Lucene.Net.Store.LockFactory"/> change on all Lucene
             instances and clean up all leftover lock files before starting
             the new configuration for the first time. Different implementations
             can not work together!</para>
            
             <para>If you suspect that this or any other <see cref="T:Lucene.Net.Store.LockFactory"/> is
             not working properly in your environment, you can easily
             test it by using <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>, 
             <see cref="T:Lucene.Net.Store.LockVerifyServer"/> and <see cref="T:Lucene.Net.Store.LockStressTest"/>.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> instance, with <c>null</c> (unset)
            lock directory. When you pass this factory to a <see cref="T:Lucene.Net.Store.FSDirectory"/>
            subclass, the lock directory is automatically set to the
            directory itself. Be sure to create one instance for each directory
            your create!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.String)">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> instance, storing lock
            files into the specified <paramref name="lockDirName"/>
            </summary>
            <param name="lockDirName"> where lock files are created. </param>
        </member>
        <member name="M:Lucene.Net.Store.NativeFSLockFactory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/> instance, storing lock
            files into the specified <paramref name="lockDir"/>
            </summary>
            <param name="lockDir"> where lock files are created. </param>
        </member>
        <member name="T:Lucene.Net.Store.NIOFSDirectory">
            <summary>
            An <see cref="T:Lucene.Net.Store.FSDirectory"/> implementation that uses <see cref="T:System.IO.FileStream"/>'s
            positional read, which allows multiple threads to read from the same file
            without synchronizing.
            <para/>
            This class only uses <see cref="T:System.IO.FileStream"/> when reading; writing is achieved with
            <see cref="T:Lucene.Net.Store.FSDirectory.FSIndexOutput"/>.
            <para>
            <b>NOTE</b>: <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> is not recommended on Windows because of a bug in
            how FileChannel.read is implemented in Sun's JRE. Inside of the
            implementation the position is apparently synchronized. See <a
            href="http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=6265734">here</a>
            for details.
            </para>
            <para>
            <font color="red"><b>NOTE:</b> Accessing this class either directly or
            indirectly from a thread while it's interrupted can close the
            underlying file descriptor immediately if at the same time the thread is
            blocked on IO. The file descriptor will remain closed and subsequent access
            to <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> will throw a <see cref="T:System.ObjectDisposedException"/>. If
            your application uses either <see cref="M:System.Threading.Thread.Interrupt"/> or
            <see cref="T:System.Threading.Tasks.Task"/> you should use <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> in
            favor of <see cref="T:Lucene.Net.Store.NIOFSDirectory"/>.</font>
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.NIOFSDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexInput"/> for the file with the given name. </summary>
        </member>
        <member name="T:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput">
            <summary>
            Reads bytes with the <see cref="M:Lucene.Net.Support.IO.FileStreamExtensions.Read(System.IO.FileStream,Lucene.Net.Support.IO.ByteBuffer,System.Int64)"/>
            extension method for <see cref="T:System.IO.FileStream"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.CHUNK_SIZE">
            <summary>
            The maximum chunk size for reads of 16384 bytes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.m_channel">
            <summary>
            the file channel we will read from </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.isClone">
            <summary>
            is this instance a clone and hence does not own the file to close it </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.m_off">
            <summary>
            start offset: non-zero in the slice case </summary>
        </member>
        <member name="F:Lucene.Net.Store.NIOFSDirectory.NIOFSIndexInput.m_end">
            <summary>
            end offset (start+length) </summary>
        </member>
        <member name="T:Lucene.Net.Store.NoLockFactory">
            <summary>
            Use this <see cref="T:Lucene.Net.Store.LockFactory"/> to disable locking entirely.
            Only one instance of this lock is created.  You should call 
            <see cref="M:Lucene.Net.Store.NoLockFactory.GetNoLockFactory"/> to get the instance.
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="T:Lucene.Net.Store.NRTCachingDirectory">
             <summary>
             Wraps a <see cref="T:Lucene.Net.Store.RAMDirectory"/>
             around any provided delegate directory, to
             be used during NRT search.
            
             <para>This class is likely only useful in a near-real-time
             context, where indexing rate is lowish but reopen
             rate is highish, resulting in many tiny files being
             written.  This directory keeps such segments (as well as
             the segments produced by merging them, as long as they
             are small enough), in RAM.</para>
            
             <para>This is safe to use: when your app calls <see cref="M:Lucene.Net.Index.IndexWriter.Commit"/>,
             all cached files will be flushed from the cached and sync'd.</para>
            
             <para/>Here's a simple example usage:
            
             <code>
                 Directory fsDir = FSDirectory.Open(new DirectoryInfo("/path/to/index"));
                 NRTCachingDirectory cachedFSDir = new NRTCachingDirectory(fsDir, 5.0, 60.0);
                 IndexWriterConfig conf = new IndexWriterConfig(Version.LUCENE_48, analyzer);
                 IndexWriter writer = new IndexWriter(cachedFSDir, conf);
             </code>
            
             <para>This will cache all newly flushed segments, all merges
             whose expected segment size is &lt;= 5 MB, unless the net
             cached bytes exceeds 60 MB at which point all writes will
             not be cached (until the net bytes falls below 60 MB).</para>
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.#ctor(Lucene.Net.Store.Directory,System.Double,System.Double)">
            <summary>
            We will cache a newly created output if 1) it's a
            flush or a merge and the estimated size of the merged segment is &lt;=
            maxMergeSizeMB, and 2) the total cached bytes is &lt;=
            maxCachedMB
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.GetSizeInBytes">
            <summary>
            Returns how many bytes are being used by the
            <see cref="T:Lucene.Net.Store.RAMDirectory"/> cache
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.Dispose(System.Boolean)">
            <summary>
            Dispose this directory, which flushes any cached files
            to the delegate and then disposes the delegate.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.NRTCachingDirectory.DoCacheWrite(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Subclass can override this to customize logic; return
            <c>true</c> if this file should be written to the <see cref="T:Lucene.Net.Store.RAMDirectory"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.OutputStreamDataOutput">
            <summary>
            A <see cref="T:Lucene.Net.Store.DataOutput"/> wrapping a plain <see cref="T:System.IO.Stream"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMDirectory">
             <summary>
             A memory-resident <see cref="T:Lucene.Net.Store.Directory"/> implementation.  Locking
             implementation is by default the <see cref="T:Lucene.Net.Store.SingleInstanceLockFactory"/>
             but can be changed with <see cref="M:Lucene.Net.Store.Directory.SetLockFactory(Lucene.Net.Store.LockFactory)"/>.
            
             <para/><b>Warning:</b> This class is not intended to work with huge
             indexes. Everything beyond several hundred megabytes will waste
             resources (GC cycles), because it uses an internal buffer size
             of 1024 bytes, producing millions of <see cref="T:byte[1024]"/> arrays.
             This class is optimized for small memory-resident indexes.
             It also has bad concurrency on multithreaded environments.
            
             <para/>It is recommended to materialize large indexes on disk and use
             <see cref="T:Lucene.Net.Store.MMapDirectory"/>, which is a high-performance directory
             implementation working directly on the file system cache of the
             operating system, so copying data to heap space is not useful.
             </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor">
            <summary>
            Constructs an empty <see cref="T:Lucene.Net.Store.Directory"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.#ctor(Lucene.Net.Store.Directory,Lucene.Net.Store.IOContext)">
             <summary>
             Creates a new <see cref="T:Lucene.Net.Store.RAMDirectory"/> instance from a different
             <see cref="T:Lucene.Net.Store.Directory"/> implementation.  This can be used to load
             a disk-based index into memory.
            
             <para/><b>Warning:</b> this class is not intended to work with huge
             indexes. Everything beyond several hundred megabytes will waste
             resources (GC cycles), because it uses an internal buffer size
             of 1024 bytes, producing millions of <see cref="T:byte[1024]"/> arrays.
             this class is optimized for small memory-resident indexes.
             It also has bad concurrency on multithreaded environments.
            
             <para/>For disk-based indexes it is recommended to use
             <see cref="T:Lucene.Net.Store.MMapDirectory"/>, which is a high-performance directory
             implementation working directly on the file system cache of the
             operating system, so copying data to heap space is not useful.
            
             <para/>Note that the resulting <see cref="T:Lucene.Net.Store.RAMDirectory"/> instance is fully
             independent from the original <see cref="T:Lucene.Net.Store.Directory"/> (it is a
             complete copy).  Any subsequent changes to the
             original <see cref="T:Lucene.Net.Store.Directory"/> will not be visible in the
             <see cref="T:Lucene.Net.Store.RAMDirectory"/> instance.
             </summary>
             <param name="dir"> a <see cref="T:Lucene.Net.Store.Directory"/> value </param>
             <param name="context">io context</param>
             <exception cref="T:System.IO.IOException"> if an error occurs </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileExists(System.String)">
            <summary>
            Returns true iff the named file exists in this directory. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.FileLength(System.String)">
            <summary>
            Returns the length in bytes of a file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.GetSizeInBytes">
            <summary>
            Return total size in bytes of all files in this directory. This is
            currently quantized to <see cref="F:Lucene.Net.Store.RAMOutputStream.BUFFER_SIZE"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.DeleteFile(System.String)">
            <summary>
            Removes an existing file in the directory. </summary>
            <exception cref="T:System.IO.IOException"> if the file does not exist </exception>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.CreateOutput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates a new, empty file in the directory with the given name. Returns a stream writing this file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.NewRAMFile">
            <summary>
            Returns a new <see cref="T:Lucene.Net.Store.RAMFile"/> for storing data. this method can be
            overridden to return different <see cref="T:Lucene.Net.Store.RAMFile"/> impls, that e.g. override
            <see cref="M:Lucene.Net.Store.RAMFile.NewBuffer(System.Int32)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Returns a stream reading an existing file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMDirectory.Dispose(System.Boolean)">
            <summary>
            Closes the store to future operations, releasing associated memory. </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMFile">
            <summary>
            Represents a file in RAM as a list of <see cref="T:byte[]"/> buffers.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMFile.#ctor">
            <summary>
            File used as buffer, in no <see cref="T:Lucene.Net.Store.RAMDirectory"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.RAMFile.Length">
            <summary>
            For non-stream access from thread that might be concurrent with writing
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMFile.NewBuffer(System.Int32)">
            <summary>
            Expert: allocate a new buffer.
            Subclasses can allocate differently. </summary>
            <param name="size"> size of allocated buffer. </param>
            <returns> allocated buffer. </returns>
        </member>
        <member name="T:Lucene.Net.Store.RAMInputStream">
            <summary>
            A memory-resident <see cref="T:Lucene.Net.Store.IndexInput"/> implementation.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.RAMOutputStream">
            <summary>
            A memory-resident <see cref="T:Lucene.Net.Store.IndexOutput"/> implementation.
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.#ctor">
            <summary>
            Construct an empty output buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(Lucene.Net.Store.DataOutput)">
            <summary>
            Copy the current contents of this buffer to the named output. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.WriteTo(System.Byte[],System.Int32)">
            <summary>
            Copy the current contents of this buffer to output
            byte array
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.Reset">
            <summary>
            Resets this to an empty file. </summary>
        </member>
        <member name="M:Lucene.Net.Store.RAMOutputStream.GetSizeInBytes">
            <summary>
            Returns byte usage of all buffers. </summary>
        </member>
        <member name="T:Lucene.Net.Store.RateLimitedDirectoryWrapper">
            
             <summary>
             A <see cref="T:Lucene.Net.Store.Directory"/> wrapper that allows <see cref="T:Lucene.Net.Store.IndexOutput"/> rate limiting using
             IO context (<see cref="T:Lucene.Net.Store.IOContext.UsageContext"/>) specific rate limiters (<see cref="T:Lucene.Net.Store.RateLimiter"/>).
             <para/>
             @lucene.experimental
             </summary>
             <seealso cref="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetRateLimiter(Lucene.Net.Store.RateLimiter,Lucene.Net.Store.IOContext.UsageContext)"/>
        </member>
        <member name="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetMaxWriteMBPerSec(System.Nullable{System.Double},Lucene.Net.Store.IOContext.UsageContext)">
             <summary>
             Sets the maximum (approx) MB/sec allowed by all write IO performed by
             <see cref="T:Lucene.Net.Store.IndexOutput"/> created with the given <see cref="T:Lucene.Net.Store.IOContext.UsageContext"/>. Pass 
             <c>null</c> for <paramref name="mbPerSec"/> to have no limit.
            
             <para/>
             <b>NOTE</b>: For already created <see cref="T:Lucene.Net.Store.IndexOutput"/> instances there is no
             guarantee this new rate will apply to them; it will only be guaranteed to
             apply for new created <see cref="T:Lucene.Net.Store.IndexOutput"/> instances.
             <para/>
             <b>NOTE</b>: this is an optional operation and might not be respected by
             all <see cref="T:Lucene.Net.Store.Directory"/> implementations. Currently only buffered (<see cref="T:Lucene.Net.Store.FSDirectory"/>)
             <see cref="T:Lucene.Net.Store.Directory"/> implementations use rate-limiting.
             <para/>
             @lucene.experimental
             </summary>
             <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Store.Directory"/> is already disposed
             </exception>
        </member>
        <member name="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetRateLimiter(Lucene.Net.Store.RateLimiter,Lucene.Net.Store.IOContext.UsageContext)">
             <summary>
             Sets the rate limiter to be used to limit (approx) MB/sec allowed by all IO
             performed with the given context (<see cref="T:Lucene.Net.Store.IOContext.UsageContext"/>). Pass <c>null</c> to
             have no limit.
            
             <para/>
             Passing an instance of rate limiter compared to setting it using
             <see cref="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetMaxWriteMBPerSec(System.Nullable{System.Double},Lucene.Net.Store.IOContext.UsageContext)"/>
             allows to use the same limiter instance across several directories globally
             limiting IO across them.
             <para/>
             @lucene.experimental
             </summary>
             <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Store.Directory"/> is already disposed
             </exception>
        </member>
        <member name="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.GetMaxWriteMBPerSec(Lucene.Net.Store.IOContext.UsageContext)">
            <summary>
            See <see cref="M:Lucene.Net.Store.RateLimitedDirectoryWrapper.SetMaxWriteMBPerSec(System.Nullable{System.Double},Lucene.Net.Store.IOContext.UsageContext)"/>.
            <para/>
            @lucene.experimental
            </summary>
            <exception cref="T:System.ObjectDisposedException"> if the <see cref="T:Lucene.Net.Store.Directory"/> is already disposed
            </exception>
        </member>
        <member name="T:Lucene.Net.Store.RateLimitedIndexOutput">
            <summary>
            A rate limiting (<see cref="T:Lucene.Net.Store.RateLimiter"/>) <see cref="T:Lucene.Net.Store.IndexOutput"/>
            <para/>
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.RateLimiter">
            <summary>
            Abstract base class to rate limit IO.  Typically implementations are
            shared across multiple <see cref="T:Lucene.Net.Store.IndexInput"/>s or <see cref="T:Lucene.Net.Store.IndexOutput"/>s (for example
            those involved all merging).  Those <see cref="T:Lucene.Net.Store.IndexInput"/>s and
            <see cref="T:Lucene.Net.Store.IndexOutput"/>s would call <see cref="M:Lucene.Net.Store.RateLimiter.Pause(System.Int64)"/> whenever they
            want to read bytes or write bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SetMbPerSec(System.Double)">
            <summary>
            Sets an updated mb per second rate limit.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.RateLimiter.MbPerSec">
            <summary>
            The current mb per second rate limit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.Pause(System.Int64)">
            <summary>
            Pauses, if necessary, to keep the instantaneous IO
            rate at or below the target.
            <para>
            Note: the implementation is thread-safe
            </para> 
            </summary>
            <returns> the pause time in nano seconds </returns>
        </member>
        <member name="T:Lucene.Net.Store.RateLimiter.SimpleRateLimiter">
            <summary>
            Simple class to rate limit IO.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.#ctor(System.Double)">
            <summary>
            <paramref name="mbPerSec"/> is the MB/sec max IO rate </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.SetMbPerSec(System.Double)">
            <summary>
            Sets an updated mb per second rate limit.
            </summary>
        </member>
        <member name="P:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.MbPerSec">
            <summary>
            The current mb per second rate limit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.RateLimiter.SimpleRateLimiter.Pause(System.Int64)">
            <summary>
            Pauses, if necessary, to keep the instantaneous IO
            rate at or below the target. NOTE: multiple threads
            may safely use this, however the implementation is
            not perfectly thread safe but likely in practice this
            is harmless (just means in some rare cases the rate
            might exceed the target).  It's best to call this
            with a biggish count, not one byte at a time. </summary>
            <returns> the pause time in nano seconds </returns>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSDirectory">
            <summary>
            A straightforward implementation of <see cref="T:Lucene.Net.Store.FSDirectory"/>
            using <see cref="T:System.IO.FileStream"/>.  However, this class has
            poor concurrent performance (multiple threads will
            bottleneck) as it synchronizes when multiple threads
            read from the same file.  It's usually better to use
            <see cref="T:Lucene.Net.Store.NIOFSDirectory"/> or <see cref="T:Lucene.Net.Store.MMapDirectory"/> instead.
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.IO.DirectoryInfo,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.String,Lucene.Net.Store.LockFactory)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <param name="lockFactory"> the lock factory to use, or null for the default
            (<see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>); </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.#ctor(System.String)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Store.SimpleFSDirectory"/> for the named location and <see cref="T:Lucene.Net.Store.NativeFSLockFactory"/>.
            <para/>
            LUCENENET specific overload for convenience using string instead of <see cref="T:System.IO.DirectoryInfo"/>.
            </summary>
            <param name="path"> the path of the directory </param>
            <exception cref="T:System.IO.IOException"> if there is a low-level I/O error </exception>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.OpenInput(System.String,Lucene.Net.Store.IOContext)">
            <summary>
            Creates an <see cref="T:Lucene.Net.Store.IndexInput"/> for the file with the given name. </summary>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput">
            <summary>
            Reads bytes with <see cref="M:System.IO.FileStream.Seek(System.Int64,System.IO.SeekOrigin)"/> followed by
            <see cref="M:System.IO.FileStream.Read(System.Byte[],System.Int32,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.m_file">
            <summary>
            the file channel we will read from </summary>
        </member>
        <member name="P:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.IsClone">
            <summary>
            is this instance a clone and hence does not own the file to close it </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.m_off">
            <summary>
            start offset: non-zero in the slice case </summary>
        </member>
        <member name="F:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.m_end">
            <summary>
            end offset (start+length) </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSDirectory.SimpleFSIndexInput.ReadInternal(System.Byte[],System.Int32,System.Int32)">
            <summary>
            <see cref="T:Lucene.Net.Store.IndexInput"/> methods </summary>
        </member>
        <member name="T:Lucene.Net.Store.SimpleFSLockFactory">
             <summary>
             <para>Implements <see cref="T:Lucene.Net.Store.LockFactory"/> using 
             <see cref="M:System.IO.File.WriteAllText(System.String,System.String,System.Text.Encoding)"/> 
             (writes the file with UTF8 encoding and no byte order mark).</para>
            
             <para>Special care needs to be taken if you change the locking
             implementation: First be certain that no writer is in fact
             writing to the index otherwise you can easily corrupt
             your index. Be sure to do the <see cref="T:Lucene.Net.Store.LockFactory"/> change to all Lucene
             instances and clean up all leftover lock files before starting
             the new configuration for the first time. Different implementations
             can not work together!</para>
            
             <para>If you suspect that this or any other <see cref="T:Lucene.Net.Store.LockFactory"/> is
             not working properly in your environment, you can easily
             test it by using <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/>, 
             <see cref="T:Lucene.Net.Store.LockVerifyServer"/> and <see cref="T:Lucene.Net.Store.LockStressTest"/>.</para>
             </summary>
             <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor">
            <summary>
            Create a <see cref="T:Lucene.Net.Store.SimpleFSLockFactory"/> instance, with <c>null</c> (unset)
            lock directory. When you pass this factory to a <see cref="T:Lucene.Net.Store.FSDirectory"/>
            subclass, the lock directory is automatically set to the
            directory itself. Be sure to create one instance for each directory
            your create!
            </summary>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.IO.DirectoryInfo)">
            <summary>
            Instantiate using the provided directory (as a <see cref="T:System.IO.DirectoryInfo"/> instance). </summary>
            <param name="lockDir"> where lock files should be created. </param>
        </member>
        <member name="M:Lucene.Net.Store.SimpleFSLockFactory.#ctor(System.String)">
            <summary>
            Instantiate using the provided directory name (<see cref="T:System.String"/>). </summary>
            <param name="lockDirName"> where lock files should be created. </param>
        </member>
        <member name="T:Lucene.Net.Store.SingleInstanceLockFactory">
            <summary>
            Implements <see cref="T:Lucene.Net.Store.LockFactory"/> for a single in-process instance,
            meaning all locking will take place through this one instance.
            Only use this <see cref="T:Lucene.Net.Store.LockFactory"/> when you are certain all
            <see cref="T:Lucene.Net.Index.IndexReader"/>s and <see cref="T:Lucene.Net.Index.IndexWriter"/>s for a given index are running
            against a single shared in-process <see cref="T:Lucene.Net.Store.Directory"/> instance.  This is
            currently the default locking for <see cref="T:Lucene.Net.Store.RAMDirectory"/>.
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockFactory"/>
        </member>
        <member name="T:Lucene.Net.Store.TrackingDirectoryWrapper">
            <summary>
            A delegating <see cref="T:Lucene.Net.Store.Directory"/> that records which files were
            written to and deleted.
            </summary>
        </member>
        <member name="T:Lucene.Net.Store.VerifyingLockFactory">
            <summary>
            A <see cref="T:Lucene.Net.Store.LockFactory"/> that wraps another 
            <see cref="T:Lucene.Net.Store.LockFactory"/> and verifies that each lock obtain/release
            is "correct" (never results in two processes holding the
            lock at the same time).  It does this by contacting an
            external server (<see cref="T:Lucene.Net.Store.LockVerifyServer"/>) to assert that
            at most one process holds the lock at a time.  To use
            this, you should also run <see cref="T:Lucene.Net.Store.LockVerifyServer"/> on the
            host &amp; port matching what you pass to the constructor.
            </summary>
            <seealso cref="T:Lucene.Net.Store.LockVerifyServer"/>
            <seealso cref="T:Lucene.Net.Store.LockStressTest"/>
        </member>
        <member name="M:Lucene.Net.Store.VerifyingLockFactory.#ctor(Lucene.Net.Store.LockFactory,System.IO.Stream,System.IO.Stream)">
            <summary>
            Creates a new <see cref="T:Lucene.Net.Store.VerifyingLockFactory"/> instance.
            </summary>
            <param name="lf"> the <see cref="T:Lucene.Net.Store.LockFactory"/> that we are testing </param>
            <param name="in"> the socket's input to <see cref="T:Lucene.Net.Store.LockVerifyServer"/> </param>
            <param name="out"> the socket's output to <see cref="T:Lucene.Net.Store.LockVerifyServer"/> </param>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.Fill``1(``0[],``0)">
            <summary>
            Assigns the specified value to each element of the specified array.
            </summary>
            <typeparam name="T">the type of the array</typeparam>
            <param name="a">the array to be filled</param>
            <param name="val">the value to be stored in all elements of the array</param>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.Fill``1(``0[],System.Int32,System.Int32,``0)">
            <summary>
            Assigns the specified long value to each element of the specified
            range of the specified array of longs.  The range to be filled
            extends from index <paramref name="fromIndex"/>, inclusive, to index
            <paramref name="toIndex"/>, exclusive.  (If <c>fromIndex==toIndex</c>, the
            range to be filled is empty.)
            </summary>
            <typeparam name="T">the type of the array</typeparam>
            <param name="a">the array to be filled</param>
            <param name="fromIndex">
            the index of the first element (inclusive) to be
            filled with the specified value
            </param>
            <param name="toIndex">
            the index of the last element (exclusive) to be
            filled with the specified value
            </param>
            <param name="val">the value to be stored in all elements of the array</param>
            <exception cref="T:System.ArgumentException">if <c>fromIndex &gt; toIndex</c></exception>
            <exception cref="T:System.ArgumentOutOfRangeException">if <c>fromIndex &lt; 0</c> or <c>toIndex &gt; a.Length</c></exception>
        </member>
        <member name="M:Lucene.Net.Support.Arrays.Equals``1(``0[],``0[])">
            <summary>
            Compares the entire members of one array whith the other one.
            </summary>
            <param name="a">The array to be compared.</param>
            <param name="b">The array to be compared with.</param>
            <returns>Returns true if the two specified arrays of Objects are equal
            to one another. The two arrays are considered equal if both arrays
            contain the same number of elements, and all corresponding pairs of
            elements in the two arrays are equal. Two objects e1 and e2 are
            considered equal if (e1==null ? e2==null : e1.equals(e2)). In other
            words, the two arrays are equal if they contain the same elements in
            the same order. Also, two array references are considered equal if
            both are null.
            <para/>
            Note that if the type of <paramref name="T"/> is a <see cref="T:System.Collections.Generic.IDictionary`2"/>,
            <see cref="T:System.Collections.Generic.IList`1"/>, or <see cref="T:System.Collections.Generic.ISet`1"/>, its values and any nested collection values
            will be compared for equality as well.
            </returns>
        </member>
        <member name="M:Lucene.Net.Support.AssemblyExtensions.FindAndGetManifestResourceStream(System.Reflection.Assembly,System.Type,System.String)">
            <summary>
            Aggressively searches for a resource and, if found, returns an open <see cref="T:System.IO.Stream"/>
            where it can be read.
            </summary>
            <param name="assembly">this assembly</param>
            <param name="type">a type in the same namespace as the resource</param>
            <param name="name">the resource name to locate</param>
            <returns>an open <see cref="T:System.IO.Stream"/> that can be used to read the resource, or <c>null</c> if the resource cannot be found.</returns>
        </member>
        <member name="M:Lucene.Net.Support.AssemblyExtensions.FindResource(System.Reflection.Assembly,System.Type,System.String)">
            <summary>
            Aggressively searches to find a resource based on a <see cref="T:System.Type"/> and resource name.
            </summary>
            <param name="assembly">this assembly</param>
            <param name="type">a type in the same namespace as the resource</param>
            <param name="name">the resource name to locate</param>
            <returns>the resource, if found; if not found, returns <c>null</c></returns>
        </member>
        <member name="T:Lucene.Net.Support.AtomicInt32">
            <summary>
            NOTE: This was AtomicInteger in the JDK
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.AtomicInt64">
            <summary>
            NOTE: This was AtomicLong in the JDK
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.AtomicReferenceArray`1">
            <summary>
            Mimics Java's AtomicReferenceArray class (partial implementation)
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Lucene.Net.Support.AttributeItem">
            <summary>
            A simple wrapper to allow for the use of the GeneralKeyedCollection.  The
            wrapper is required as there can be several keys for an object depending
            on how many interfaces it implements.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.BitArrayExtensions">
            <summary>
            This class provides supporting methods of java.util.BitSet
            that are not present in System.Collections.BitArray.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.NextSetBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the next set bit at or after index, or -1 if no such bit exists.
            </summary>
            <param name="bitArray"></param>
            <param name="index">the index of bit array at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.NextClearBit(System.Collections.BitArray,System.Int32)">
            <summary>
            Returns the next un-set bit at or after index, or -1 if no such bit exists.
            </summary>
            <param name="bitArray"></param>
            <param name="index">the index of bit array at which to start checking</param>
            <returns>the next set bit or -1</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Cardinality(System.Collections.BitArray)">
            <summary>
            Returns the number of bits set to true in this BitSet.
            </summary>
            <param name="bits">The BitArray object.</param>
            <returns>The number of bits set to true in this BitSet.</returns>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Set(System.Collections.BitArray,System.Int32)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to true.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="index">The position to set to true.</param>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Set(System.Collections.BitArray,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to true.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="fromIndex">The start of the range to set(inclusive)</param>
            <param name="toIndex">The end of the range to set(exclusive)</param>
            <param name="value">the value to set to the range</param>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Clear(System.Collections.BitArray,System.Int32)">
            <summary>
            Sets the bit at the given <paramref name="index"/> to false.
            </summary>
            <param name="bits">The BitArray object.</param>
            <param name="index">The position to set to false.</param>
        </member>
        <member name="M:Lucene.Net.Support.BitArrayExtensions.Clear(System.Collections.BitArray)">
            <summary>
            Sets all bits to false
            </summary>
            <param name="bits">The BitArray object.</param>
        </member>
        <member name="T:Lucene.Net.Support.BundleResourceManagerFactory">
            <summary>
            This implementation of <see cref="T:Lucene.Net.Support.IResourceManagerFactory"/> uses a convention
            to retrieve resources. In Java NLS, the convention is to use the same name for the
            resource key propeties and for the resource file names. This presents a problem
            for .NET because the resource generator already creates an internal class with the
            same name as the <c>.resx</c> file.
            <para/>
            To work around this, we use the convention of appending the suffix "Bundle" to 
            the end of the type the resource key propeties are stored in. For example,
            if our constants are stored in a class named ErrorMessages, the type
            that will be looked up by this factory will be ErrorMessagesBundle (which is the
            name of the <c>.resx</c> file that should be added to your project).
            <para/>
            This implementation can be inherited to use a different convention or can be replaced
            to get the resources from an external source.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.BundleResourceManagerFactory.Create(System.Type)">
            <summary>
            Creates a <see cref="T:System.Resources.ResourceManager"/> instance using the specified <paramref name="resourceSource"/>.
            </summary>
            <param name="resourceSource">The type representing the resource to retrieve.</param>
            <returns>A new <see cref="T:System.Resources.ResourceManager"/> instance.</returns>
        </member>
        <member name="M:Lucene.Net.Support.BundleResourceManagerFactory.Release(System.Resources.ResourceManager)">
            <summary>
            Releases the <see cref="T:System.Resources.ResourceManager"/> instance including any disposable dependencies.
            </summary>
            <param name="manager">The <see cref="T:System.Resources.ResourceManager"/> to release.</param>
        </member>
        <member name="M:Lucene.Net.Support.BundleResourceManagerFactory.GetResourceName(System.Type)">
            <summary>
            Gets the fully-qualified name of the bundle as it would appear
            using <see cref="M:System.Reflection.Assembly.GetManifestResourceNames"/>, without the
            <c>.resources</c> extension. This is the name that is passed to the
            <c>baseName</c> parameter of
            <see cref="M:System.Resources.ResourceManager.#ctor(System.String,System.Reflection.Assembly)"/>.
            </summary>
            <param name="clazz">The type of the NLS-derived class where the field strings are located that identify resources.</param>
            <returns>The resource name.</returns>
        </member>
        <member name="P:Lucene.Net.Support.BundleResourceManagerFactory.ResourceSuffix">
            <summary>
            The suffix to append to the resource key class name to locate the embedded resource.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.CollectionValueBase`1">
            <summary>
            Base class for classes implementing ICollectionValue[T]
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionValueBase`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionValueBase`1.ActiveEvents">
            <summary>
            A flag bitmap of the events currently subscribed to by this collection.
            </summary>
            <value></value>
        </member>
        <member name="E:Lucene.Net.Support.C5.CollectionValueBase`1.CollectionChanged">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseCollectionChanged">
            <summary>
            Fire the CollectionChanged event
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.CollectionValueBase`1.CollectionCleared">
            <summary>
            The clear event. Will be raised for every Clear operation on the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseCollectionCleared(System.Boolean,System.Int32)">
            <summary>
            Fire the CollectionCleared event
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseCollectionCleared(System.Boolean,System.Int32,System.Nullable{System.Int32})">
            <summary>
            Fire the CollectionCleared event
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.CollectionValueBase`1.ItemsAdded">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseItemsAdded(`0,System.Int32)">
            <summary>
            Fire the ItemsAdded event
            </summary>
            <param name="item">The item that was added</param>
            <param name="count"></param>
        </member>
        <member name="E:Lucene.Net.Support.C5.CollectionValueBase`1.ItemsRemoved">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseItemsRemoved(`0,System.Int32)">
            <summary>
            Fire the ItemsRemoved event
            </summary>
            <param name="item">The item that was removed</param>
            <param name="count"></param>
        </member>
        <member name="E:Lucene.Net.Support.C5.CollectionValueBase`1.ItemInserted">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseItemInserted(`0,System.Int32)">
            <summary>
            Fire the ItemInserted event
            </summary>
            <param name="item">The item that was added</param>
            <param name="index"></param>
        </member>
        <member name="E:Lucene.Net.Support.C5.CollectionValueBase`1.ItemRemovedAt">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseItemRemovedAt(`0,System.Int32)">
            <summary> 
            Fire the ItemRemovedAt event
            </summary>
            <param name="item">The item that was removed</param>
            <param name="index"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForSetThis(System.Int32,`0,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="value"></param>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForInsert(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="i"></param>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForRemove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForRemove(`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="count"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForRemoveAt(System.Int32,`0)">
            <summary>
            
            </summary>
            <param name="index"></param>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForUpdate(`0,`0)">
            <summary>
            
            </summary>
            <param name="newitem"></param>
            <param name="olditem"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForUpdate(`0,`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="newitem"></param>
            <param name="olditem"></param>
            <param name="count"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForAdd(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.raiseForRemoveAll(Lucene.Net.Support.C5.ICollectionValue{`0})">
            <summary>
            
            </summary>
            <param name="wasRemoved"></param>
        </member>
        <member name="T:Lucene.Net.Support.C5.CollectionValueBase`1.RaiseForRemoveAllHandler">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.#ctor(Lucene.Net.Support.C5.CollectionValueBase{`0})">
            <summary>
            
            </summary>
            <param name="collection"></param>
        </member>
        <member name="F:Lucene.Net.Support.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.MustFire">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.Remove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.RaiseForRemoveAllHandler.Raise">
            <summary>
            
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionValueBase`1.IsEmpty">
            <summary>
            Check if collection is empty.
            </summary>
            <value>True if empty</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionValueBase`1.Count">
            <summary>
            The number of items in this collection.
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionValueBase`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to part of an array.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if <code>index</code> 
            is not a valid index
            into the array (i.e. negative or greater than the size of the array)
            or the array does not have room for the items.</exception>
            <param name="array">The array to copy to.</param>
            <param name="index">The starting index.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.ToArray">
            <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.Apply(System.Action{`0})">
            <summary>
            Apply an single argument action, <see cref="T:Action`1"/> to this enumerable
            </summary>
            <param name="action">The action delegate</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R = bool</code>) 
            defining the predicate</param>
            <returns>True if such an item exists</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.Find(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.All(System.Func{`0,System.Boolean})">
            <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R = bool</code>) 
            defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R = bool</code>) 
            defining the predicate</param>
            <returns>The filtered enumerable</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionValueBase`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.DictionaryBase`2">
            <summary>
            A base class for implementing a dictionary based on a set collection implementation.
            <i>See the source code for <see cref="T:C5.HashDictionary`2"/> for an example</i>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.DictionaryBase`2.pairs">
            <summary>
            The set collection of entries underlying this dictionary implementation
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.DictionaryBase`2.CollectionChanged">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.DictionaryBase`2.CollectionCleared">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.DictionaryBase`2.ItemsAdded">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.DictionaryBase`2.ItemsRemoved">
            <summary>
            The item added  event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.ListenableEvents">
            <summary>
            
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.ActiveEvents">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            
            </summary>
            <param name="keyequalityComparer"></param>
            <param name = "memoryType"></param>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.EqualityComparer">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Add(`0,`1)">
            <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"> if there already is an entry with the same key. </exception>
            <param name="key">Key to add</param>
            <param name="value">Value to add</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.AddAll``2(System.Collections.Generic.IEnumerable{Lucene.Net.Support.C5.KeyValuePair{``0,``1}})">
            <summary>
            Add the entries from a collection of <see cref="T:C5.KeyValuePair`2"/> pairs to this dictionary.
            <para><b>TODO: add restrictions L:K and W:V when the .Net SDK allows it </b></para>
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"> 
            If the input contains duplicate keys or a key already present in this dictionary.</exception>
            <param name="entries"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Remove(`0)">
            <summary>
            Remove an entry with a given key from the dictionary
            </summary>
            <param name="key">The key of the entry to remove</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Remove(`0,`1@)">
            <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
            <param name="key">The key of the entry to remove</param>
            <param name="value">On exit, the value of the removed entry</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Clear">
            <summary>
            Remove all entries from the dictionary
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.ContainsSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Contains(`0)">
            <summary>
            Check if there is an entry with a specified key
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            
            </summary>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Find(`0@,`1@)">
            <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
            <param name="key">The key to look for</param>
            <param name="value">On exit, the value of the entry</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Update(`0,`1)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
            <param name="key">The key to look for</param>
            <param name="value">The new value</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Update(`0,`1,`1@)">
            <summary>
            
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="oldvalue"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.FindOrAdd(`0,`1@)">
            <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
            <param name="key">On entry the key to look for</param>
            <param name="value">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.UpdateOrAdd(`0,`1)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="value">The value to add or replace with.</param>
            <returns>True if entry was updated.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.UpdateOrAdd(`0,`1,`1@)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found and the old value if any.
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="oldvalue"></param>
            <returns></returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.Keys">
            <summary>
            
            </summary>
            <value>A collection containing all the keys of the dictionary</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.Values">
            <summary>
            
            </summary>
            <value>A collection containing all the values of the dictionary</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.Func">
            <summary>
            
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.Item(`0)">
            <summary>
            Indexer by key for dictionary. 
            <para>The get method will throw an exception if no entry is found. </para>
            <para>The set method behaves like <see cref="M:C5.DictionaryBase`2.UpdateOrAdd(`0,`1)"/>.</para>
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> On get if no entry is found. </exception>
            <value>The value corresponding to the key</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if dictionary is read  only</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Check">
            <summary>
            Check the integrity of the internal data structures of this dictionary.
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.Count">
            <summary>
            
            </summary>
            <value>The number of entries in the dictionary</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.DictionaryBase`2.CountSpeed">
            <summary>
            
            </summary>
            <value>The number of entries in the dictionary</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Choose">
            <summary>
            Choose some entry in this Dictionary. 
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.GetEnumerator">
            <summary>
            Create an enumerator for the collection of entries of the dictionary
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DictionaryBase`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.SortedDictionaryBase`2">
            <summary>
            A base class for implementing a sorted dictionary based on a sorted set collection implementation.
            <i>See the source code for <see cref="T:C5.TreeDictionary`2"/> for an example</i>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.SortedDictionaryBase`2.sortedpairs">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            
            </summary>
            <param name="keycomparer"></param>
            <param name="keyequalityComparer"></param>
            <param name="memoryType">The memory type of the enumerator used to iterate the collection.</param>
        </member>
        <member name="P:Lucene.Net.Support.C5.SortedDictionaryBase`2.Comparer">
            <summary>
            The key comparer used by this dictionary.
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.SortedDictionaryBase`2.Keys">
            <summary>
            
            </summary>
            <value></value>
            I should add something to return the same instance
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.TryPredecessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a predecessor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.TrySuccessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The successor, if any</param>
            <returns>True if the key has a successor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.TryWeakPredecessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a weak predecessor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.TryWeakSuccessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The weak successor, if any</param>
            <returns>True if the key has a weak successor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.Predecessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.Successor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.WeakPredecessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.WeakSuccessor(`0)">
            <summary>
            Get the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"></exception>
            <param name="key">The key</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.FindMin">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.DeleteMin">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.FindMax">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.DeleteMax">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.Cut(System.IComparable{`0},Lucene.Net.Support.C5.KeyValuePair{`0,`1}@,System.Boolean@,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@,System.Boolean@)">
            <summary>
            
            </summary>
            <param name="cutter"></param>
            <param name="lowEntry"></param>
            <param name="lowIsValid"></param>
            <param name="highEntry"></param>
            <param name="highIsValid"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.RangeFrom(`0)">
            <summary>
            
            </summary>
            <param name="bot"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.RangeFromTo(`0,`0)">
            <summary>
            
            </summary>
            <param name="bot"></param>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.RangeTo(`0)">
            <summary>
            
            </summary>
            <param name="top"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.RangeAll">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.AddSorted(System.Collections.Generic.IEnumerable{Lucene.Net.Support.C5.KeyValuePair{`0,`1}})">
            <summary>
            
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.RemoveRangeFrom(`0)">
            <summary>
            
            </summary>
            <param name="lowKey"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.RemoveRangeFromTo(`0,`0)">
            <summary>
            
            </summary>
            <param name="lowKey"></param>
            <param name="highKey"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.RemoveRangeTo(`0)">
            <summary>
            
            </summary>
            <param name="highKey"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.SortedKeysCollection.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.SortedKeysCollection.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SortedDictionaryBase`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.SequencedBase`1">
            <summary>
            Base class (abstract) for sequenced collection implementations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            
            </summary>
            <param name="itemequalityComparer"></param>
            <param name = "memoryType">The type of memory for the enumerator used to iterate the collection</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedBase`1.ComputeHashCode(Lucene.Net.Support.C5.ISequenced{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Compute the unsequenced hash code of a collection
            </summary>
            <param name="items">The collection to compute hash code for</param>
            <param name="itemequalityComparer">The item equalitySCG.Comparer</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedBase`1.StaticEquals(Lucene.Net.Support.C5.ISequenced{`0},Lucene.Net.Support.C5.ISequenced{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Examine if tit and tat are equal as sequenced collections
            using the specified item equalityComparer (assumed compatible with the two collections).
            </summary>
            <param name="collection1">The first collection</param>
            <param name="collection2">The second collection</param>
            <param name="itemequalityComparer">The item equalityComparer to use for comparison</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedBase`1.GetSequencedHashCode">
            <summary>
            Get the sequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedBase`1.SequencedEquals(Lucene.Net.Support.C5.ISequenced{`0})">
            <summary>
            Check if the contents of that is equal to the contents of this
            in the sequenced sense. Using the item equalityComparer of this collection.
            </summary>
            <param name="otherCollection">The collection to compare to.</param>
            <returns>True if  equal</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.SequencedBase`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedBase`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
            <param name="predicate">A delegate defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedBase`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
            <param name="predicate">A delegate defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.CollectionBase`1">
            <summary>
            Base class (abstract) for ICollection implementations.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.CollectionBase`1.isReadOnlyBase">
            <summary>
            The underlying field of the ReadOnly property
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionBase`1.stamp">
            <summary>
            The current stamp value
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.CollectionBase`1.size">
            <summary>
            The number of items in the collection
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.CollectionBase`1.itemequalityComparer">
            <summary>
            The item equalityComparer of the collection
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            
            </summary>
            <param name="itemequalityComparer"></param>
            <param name = "memoryType">The type of memory for the enumerator used to iterate the collection</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.checkRange(System.Int32,System.Int32)">
            <summary>
            Utility method for range checking.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the start or count is negative or
             if the range does not fit within collection size.</exception>
            <param name="start">start of range</param>
            <param name="count">size of range</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.ComputeHashCode(Lucene.Net.Support.C5.ICollectionValue{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Compute the unsequenced hash code of a collection
            </summary>
            <param name="items">The collection to compute hash code for</param>
            <param name="itemequalityComparer">The item equalitySCG.Comparer</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.StaticEquals(Lucene.Net.Support.C5.ICollection{`0},Lucene.Net.Support.C5.ICollection{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Examine if collection1 and collection2 are equal as unsequenced collections
            using the specified item equalityComparer (assumed compatible with the two collections).
            </summary>
            <param name="collection1">The first collection</param>
            <param name="collection2">The second collection</param>
            <param name="itemequalityComparer">The item equalityComparer to use for comparison</param>
            <returns>True if equal</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.GetUnsequencedHashCode">
            <summary>
            Get the unsequenced collection hash code of this collection: from the cached 
            value if present and up to date, else (re)compute.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.UnsequencedEquals(Lucene.Net.Support.C5.ICollection{`0})">
            <summary>
            Check if the contents of otherCollection is equal to the contents of this
            in the unsequenced sense.  Uses the item equality comparer of this collection
            </summary>
            <param name="otherCollection">The collection to compare to.</param>
            <returns>True if  equal</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.modifycheck(System.Int32)">
            <summary>
            Check if the collection has been modified since a specified time, expressed as a stamp value.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.CollectionModifiedException"> if this collection has been updated 
            since a target time</exception>
            <param name="thestamp">The stamp identifying the target time</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionBase`1.updatecheck">
            <summary>
            Check if it is valid to perform update operations, and if so increment stamp.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.ReadOnlyCollectionException">If collection is read-only</exception>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionBase`1.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if this collection is read only</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionBase`1.Count">
            <summary>
            
            </summary>
            <value>The size of this collection</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionBase`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionBase`1.EqualityComparer">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CollectionBase`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty</value>
        </member>
        <member name="T:Lucene.Net.Support.C5.DirectedCollectionBase`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lucene.Net.Support.C5.DirectedCollectionBase`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            
            </summary>
            <param name="itemequalityComparer"></param>
            <param name = "memoryType">The type of memory for the enumerator used to iterate the collection</param>
        </member>
        <member name="P:Lucene.Net.Support.C5.DirectedCollectionBase`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.DirectedCollectionBase`1.Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DirectedCollectionBase`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.HashDictionary`2">
            <summary>
            A generic dictionary class based on a hash set class <see cref="T:C5.HashSet`1"/>. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashDictionary`2.#ctor(Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a hash dictionary using a default equalityComparer for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a hash dictionary using a custom equalityComparer for the keys.
            Initial capacity of internal table will be 16 entries and threshold for 
            expansion is 66% fill.
            </summary>
            <param name="keyequalityComparer">The external key equalitySCG.Comparer</param>
            <param name="memoryType">The memory type of the enumerator used to iterate the collection</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashDictionary`2.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a hash dictionary using a custom equalityComparer and prescribing the 
            initial size of the dictionary and a non-default threshold for internal table expansion.
            </summary>
            <param name="capacity">The initial capacity. Will be rounded upwards to nearest
            power of 2, at least 16.</param>
            <param name="fill">The expansion threshold. Must be between 10% and 90%.</param>
            <param name="keyequalityComparer">The external key equalitySCG.Comparer</param>
            <param name="memoryType">The memory type of the enumerator used to iterate the collection</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.HashSet`1">
            <summary>
            A set collection class based on linear hashing
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.HashSet`1.Feature">
            <summary>
            Enum class to assist printing of compilation alternatives.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.Dummy">
            <summary>
            Nothing
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.RefTypeBucket">
            <summary>
            Buckets are of reference type
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.ValueTypeBucket">
            <summary>
            Primary buckets are of value type
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.LinearProbing">
            <summary>
            Using linear probing to resolve index clashes
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.ShrinkTable">
            <summary>
            Shrink table when very sparsely filled
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.Chaining">
            <summary>
            Use chaining to resolve index clashes
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.InterHashing">
            <summary>
            Use hash function on item hash code
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.HashSet`1.Feature.RandomInterHashing">
            <summary>
            Use a universal family of hash functions on item hash code
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.HashSet`1.Features">
            <summary>
            Show which implementation features was chosen at compilation time
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.HashSet`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.searchoradd(`0@,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Search for an item equal (according to itemequalityComparer) to the supplied item.  
            </summary>
            <param name="item"></param>
            <param name="add">If true, add item to table if not found.</param>
            <param name="update">If true, update table entry if item found.</param>
            <param name="raise">If true raise events</param>
            <returns>True if found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.#ctor(Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a hash set with natural item equalityComparer and default fill threshold (66%)
            and initial table size (16).
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a hash set with external item equalityComparer and default fill threshold (66%)
            and initial table size (16).
            </summary>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
            <param name="memoryType"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a hash set with external item equalityComparer and default fill threshold (66%)
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
            <param name="memoryType"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.#ctor(System.Int32,System.Double,System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a hash set with external item equalityComparer.
            </summary>
            <param name="capacity">Initial table size (rounded to power of 2, at least 16)</param>
            <param name="fill">Fill threshold (in range 10% to 90%)</param>
            <param name="itemequalityComparer">The external item equalitySCG.Comparer</param>
            <param name="memoryType"></param>
        </member>
        <member name="P:Lucene.Net.Support.C5.HashSet`1.ContainsSpeed">
            <summary>
            The complexity of the Contains operation
            </summary>
            <value>Always returns Speed.Constant</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Contains(`0)">
            <summary>
            Check if an item is in the set 
            </summary>
            <param name="item">The item to look for</param>
            <returns>True if set contains item</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Find(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so report the actual item object found.
            </summary>
            <param name="item">On entry, the item to look for.
            On exit the item found, if any</param>
            <returns>True if set contains item</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Update(`0)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so replace the item object in the set with the supplied one.
            </summary>
            <param name="item">The item object to update with</param>
            <returns>True if item was found (and updated)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Update(`0,`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set and
            if so replace the item object in the set with the supplied one.
            </summary>
            <param name="item">The item object to update with</param>
            <param name="olditem"></param>
            <returns>True if item was found (and updated)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.FindOrAdd(`0@)">
            <summary>
            Check if an item (collection equal to a given one) is in the set.
            If found, report the actual item object in the set,
            else add the supplied one.
            </summary>
            <param name="item">On entry, the item to look for or add.
            On exit the actual object found, if any.</param>
            <returns>True if item was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.UpdateOrAdd(`0)">
            <summary>
            Check if an item (collection equal to a supplied one) is in the set and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
            <param name="item">The item to look for and update or add</param>
            <returns>True if item was updated</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.UpdateOrAdd(`0,`0@)">
            <summary>
            Check if an item (collection equal to a supplied one) is in the set and
            if so replace the item object in the set with the supplied one; else
            add the supplied one.
            </summary>
            <param name="item">The item to look for and update or add</param>
            <param name="olditem"></param>
            <returns>True if item was updated</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Remove(`0)">
            <summary>
            Remove an item from the set
            </summary>
            <param name="item">The item to remove</param>
            <returns>True if item was (found and) removed </returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Remove(`0,`0@)">
            <summary>
            Remove an item from the set, reporting the actual matching item object.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if item was found.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in a supplied collection from this set.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Clear">
            <summary>
            Remove all items from the set, resetting internal table to initial size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items *not* in a supplied collection from this set.
            </summary>
            <param name="items">The items to retain</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if all items in a supplied collection is in this set
            (ignoring multiplicities). 
            </summary>
            <param name="items">The items to look for.</param>
            <returns>True if all items are found.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.ToArray">
            <summary>
            Create an array containing all items in this set (in enumeration order).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.ContainsCount(`0)">
            <summary>
            Count the number of times an item is in this set (either 0 or 1).
            </summary>
            <param name="item">The item to look for.</param>
            <returns>1 if item is in set, 0 else</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.RemoveAllCopies(`0)">
            <summary>
            Remove all (at most 1) copies of item from this set.
            </summary>
            <param name="item">The item to remove</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Choose">
            <summary>
            Choose some item of this collection. 
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.GetEnumerator">
            <summary>
            Create an enumerator for this set.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.HashSet`1.AllowsDuplicates">
            <summary>
            Report if this is a set collection.
            </summary>
            <value>Always false</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.HashSet`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Add(`0)">
            <summary>
            Add an item to this set.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added (i.e. not found)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add an item to this set.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. Since this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.Check">
            <summary>
            Test internal structure of data (invariants)
            </summary>
            <returns>True if pass</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.HashSet`1.BucketCostDistribution">
            <summary>
            Produce statistics on distribution of bucket sizes. Current implementation is incomplete.
            </summary>
            <returns>Histogram data.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.EventBlock`1">
            <summary>
            Holds the real events for a collection
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Lucene.Net.Support.C5.ProxyEventBlock`1">
            <summary>
            Tentative, to conserve memory in GuardedCollectionValueBase
            This should really be nested in Guarded collection value, only have a guardereal field
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Lucene.Net.Support.C5.ItemCountEventArgs`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lucene.Net.Support.C5.ItemCountEventArgs`1.Item">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.ItemCountEventArgs`1.Count">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ItemCountEventArgs`1.#ctor(`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="count"></param>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ItemCountEventArgs`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.ItemAtEventArgs`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lucene.Net.Support.C5.ItemAtEventArgs`1.Item">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.ItemAtEventArgs`1.Index">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ItemAtEventArgs`1.#ctor(`0,System.Int32)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="index"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ItemAtEventArgs`1.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.ClearedEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.ClearedEventArgs.Full">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.ClearedEventArgs.Count">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ClearedEventArgs.#ctor(System.Boolean,System.Int32)">
            <summary>
            
            </summary>
            
            <param name="full">True if the operation cleared all of the collection</param>
            <param name="count">The number of items removed by the clear.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ClearedEventArgs.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.ClearedRangeEventArgs">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.ClearedRangeEventArgs.Start">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ClearedRangeEventArgs.#ctor(System.Boolean,System.Int32,System.Nullable{System.Int32})">
            <summary>
            
            </summary>
            <param name="full"></param>
            <param name="count"></param>
            <param name="start"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ClearedRangeEventArgs.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.KeyValuePair`2">
            <summary>
            An entry in a dictionary from K to V.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.KeyValuePair`2.Key">
            <summary>
            The key field of the entry
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.KeyValuePair`2.Value">
            <summary>
            The value field of the entry
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.#ctor(`0,`1)">
            <summary>
            Create an entry with specified key and value
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.#ctor(`0)">
            <summary>
            Create an entry with a specified key. The value will be the default value of type <code>V</code>.
            </summary>
            <param name="key">The key</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.ToString">
            <summary>
            Pretty print an entry
            </summary>
            <returns>(key, value)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.Equals(System.Object)">
            <summary>
            Check equality of entries. 
            </summary>
            <param name="obj">The other object</param>
            <returns>True if obj is an entry of the same type and has the same key and value</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.GetHashCode">
            <summary>
            Get the hash code of the pair.
            </summary>
            <returns>The hash code</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.Equals(Lucene.Net.Support.C5.KeyValuePair{`0,`1})">
            <summary>
            
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.op_Equality(Lucene.Net.Support.C5.KeyValuePair{`0,`1},Lucene.Net.Support.C5.KeyValuePair{`0,`1})">
            <summary>
            
            </summary>
            <param name="pair1"></param>
            <param name="pair2"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.op_Inequality(Lucene.Net.Support.C5.KeyValuePair{`0,`1},Lucene.Net.Support.C5.KeyValuePair{`0,`1})">
            <summary>
            
            </summary>
            <param name="pair1"></param>
            <param name="pair2"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="stringbuilder"></param>
            <param name="formatProvider"></param>
            <param name="rest"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePair`2.ToString(System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.KeyValuePairComparer`2">
            <summary>
            Default comparer for dictionary entries in a sorted dictionary.
            Entry comparisons only look at keys and uses an externally defined comparer for that.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePairComparer`2.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create an entry comparer for a item comparer of the keys
            </summary>
            <param name="comparer">Comparer of keys</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePairComparer`2.Compare(Lucene.Net.Support.C5.KeyValuePair{`0,`1},Lucene.Net.Support.C5.KeyValuePair{`0,`1})">
            <summary>
            Compare two entries
            </summary>
            <param name="entry1">First entry</param>
            <param name="entry2">Second entry</param>
            <returns>The result of comparing the keys</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.KeyValuePairEqualityComparer`2">
            <summary>
            Default equalityComparer for dictionary entries.
            Operations only look at keys and uses an externally defined equalityComparer for that.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePairEqualityComparer`2.#ctor">
            <summary>
            Create an entry equalityComparer using the default equalityComparer for keys
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePairEqualityComparer`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Create an entry equalityComparer from a specified item equalityComparer for the keys
            </summary>
            <param name="keyequalityComparer">The key equalitySCG.Comparer</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePairEqualityComparer`2.GetHashCode(Lucene.Net.Support.C5.KeyValuePair{`0,`1})">
            <summary>
            Get the hash code of the entry
            </summary>
            <param name="entry">The entry</param>
            <returns>The hash code of the key</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.KeyValuePairEqualityComparer`2.Equals(Lucene.Net.Support.C5.KeyValuePair{`0,`1},Lucene.Net.Support.C5.KeyValuePair{`0,`1})">
            <summary>
            Test two entries for equality
            </summary>
            <param name="entry1">First entry</param>
            <param name="entry2">Second entry</param>
            <returns>True if keys are equal</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.EqualityComparer`1">
            <summary>
            Utility class for building default generic equality comparers.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Lucene.Net.Support.C5.EqualityComparer`1.Default">
            <summary>
            A default generic equality comparer for type T. The procedure is as follows:
            <list>
            <item>If the actual generic argument T implements the generic interface
            <see cref="T:C5.ISequenced`1"/> for some value W of its generic parameter T,
            the equalityComparer will be <see cref="T:C5.SequencedCollectionEqualityComparer`2"/></item>
            <item>If the actual generic argument T implements 
            <see cref="T:C5.ICollection`1"/> for some value W of its generic parameter T,
            the equalityComparer will be <see cref="T:C5.UnsequencedCollectionEqualityComparer`2"/></item>
            <item>Otherwise the SCG.EqualityComparer&lt;T&gt;.Default is returned</item>
            </list>   
            </summary>
            <value>The comparer</value>
        </member>
        <member name="T:Lucene.Net.Support.C5.ComparerZeroHashCodeEqualityComparer`1">
            <summary>
            An equalityComparer compatible with a given comparer. All hash codes are 0, 
            meaning that anything based on hash codes will be quite inefficient.
            <para><b>Note: this will give a new EqualityComparer each time created!</b></para>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Lucene.Net.Support.C5.ComparerZeroHashCodeEqualityComparer`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a trivial <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> compatible with the 
            <see cref="T:System.Collections.Generic.IComparer`1"/> <code>comparer</code>
            </summary>
            <param name="comparer"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ComparerZeroHashCodeEqualityComparer`1.GetHashCode(`0)">
            <summary>
            A trivial, inefficient hash function. Compatible with any equality relation.
            </summary>
            <param name="item"></param>
            <returns>0</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ComparerZeroHashCodeEqualityComparer`1.Equals(`0,`0)">
            <summary>
            Equality of two items as defined by the comparer.
            </summary>
            <param name="item1"></param>
            <param name="item2"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.SequencedCollectionEqualityComparer`2">
            <summary>
            Prototype for a sequenced equalityComparer for something (T) that implements ISequenced[W].
            This will use ISequenced[W] specific implementations of the equality comparer operations.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="W"></typeparam>
        </member>
        <member name="P:Lucene.Net.Support.C5.SequencedCollectionEqualityComparer`2.Default">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedCollectionEqualityComparer`2.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this sequenced equalityComparer
            </summary>
            <param name="collection">The collection</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.SequencedCollectionEqualityComparer`2.Equals(`0,`0)">
            <summary>
            Check if two items are equal with respect to this sequenced equalityComparer
            </summary>
            <param name="collection1">first collection</param>
            <param name="collection2">second collection</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.UnsequencedCollectionEqualityComparer`2">
            <summary>
            Prototype for an unsequenced equalityComparer for something (T) that implements ICollection[W]
            This will use ICollection[W] specific implementations of the equalityComparer operations
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="W"></typeparam>
        </member>
        <member name="P:Lucene.Net.Support.C5.UnsequencedCollectionEqualityComparer`2.Default">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.UnsequencedCollectionEqualityComparer`2.GetHashCode(`0)">
            <summary>
            Get the hash code with respect to this unsequenced equalityComparer
            </summary>
            <param name="collection">The collection</param>
            <returns>The hash code</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.UnsequencedCollectionEqualityComparer`2.Equals(`0,`0)">
            <summary>
            Check if two collections are equal with respect to this unsequenced equalityComparer
            </summary>
            <param name="collection1">first collection</param>
            <param name="collection2">second collection</param>
            <returns>True if equal</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.EnumerableBase`1">
            <summary>
            A base class for implementing an IEnumerable&lt;T&gt;
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.EnumerableBase`1.GetEnumerator">
            <summary>
            Create an enumerator for this collection.
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.EnumerableBase`1.countItems(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Count the number of items in an enumerable by enumeration
            </summary>
            <param name="items">The enumerable to count</param>
            <returns>The size of the enumerable</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.DirectedCollectionValueBase`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Lucene.Net.Support.C5.DirectedCollectionValueBase`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.DirectedCollectionValueBase`1.Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.DirectedCollectionValueBase`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.CircularQueue`1">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:Lucene.Net.Support.C5.CircularQueue`1.array">
            <summary>
            The internal container array is doubled when necessary, but never shrinked.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.CircularQueue`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.#ctor(Lucene.Net.Support.C5.MemoryType)">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.#ctor(System.Int32,Lucene.Net.Support.C5.MemoryType)">
            <summary>
            
            </summary>
            <param name="capacity"></param>
            <param name="memoryType">The memory type strategy of the internal enumerator used to iterate over the collection</param>
        </member>
        <member name="P:Lucene.Net.Support.C5.CircularQueue`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.CircularQueue`1.Item(System.Int32)">
            <summary>
            Get the i'th item in the queue. The front of the queue is at index 0.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Enqueue(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Dequeue">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Push(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Pop">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Choose">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.GetEnumerator">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Lucene#Net#Support#C5#IDirectedEnumerable{T}#Backwards">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.CircularQueue`1.Check">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.Debug">
            <summary>
            Class containing debugging symbols - to eliminate preprocessor directives
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.Debug.UseDeterministicHashing">
            <summary>
            Flag used to test hashing. Set to true when unit testing hash functions.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.Showing">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.Showing.Show(System.Object,System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            Show  <code>Object obj</code> by appending it to <code>stringbuilder</code>
            </summary>
            <param name="obj"></param>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns>True if <code>obj</code> was shown completely.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.Showing.ShowString(Lucene.Net.Support.C5.IShowable,System.String,System.IFormatProvider)">
            <summary>
            
            </summary>
            <param name="showable"></param>
            <param name="format"></param>
            <param name="formatProvider"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.Showing.maxLength(System.String)">
            <summary>
            
            </summary>
            <param name="format"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.Showing.ShowCollectionValue``1(Lucene.Net.Support.C5.ICollectionValue{``0},System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="items"></param>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns>True if collection was shown completely</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.Showing.ShowDictionary``2(Lucene.Net.Support.C5.IDictionary{``0,``1},System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
            
            <param name="dictionary"></param>
            <param name="stringbuilder"></param>
            <param name="formatProvider"></param>
            <param name="rest"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.Logger">
            <summary>
            Logging module
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.Logger.Log">
            <summary>
            Gets or sets the log.
            </summary>
            <example>The following is an example of assigning a observer to the logging module:
              <code>
                Logger.Log = x => Console.WriteLine(x);
              </code>
            </example>
            <remarks>
            If Log is not set it will return a dummy action
            <c>x => { return; })</c>
            eliminating the need for null-reference checks.
            </remarks>
            <value>
            The log.
            </value>
        </member>
        <member name="T:Lucene.Net.Support.C5.IDictionary`2">
            <summary>
            A dictionary with keys of type K and values of type V. Equivalent to a
            finite partial map from K to V.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDictionary`2.EqualityComparer">
            <summary>
            The key equalityComparer.
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDictionary`2.Item(`0)">
            <summary>
            Indexer for dictionary.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no entry is found. </exception>
            <value>The value corresponding to the key</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDictionary`2.IsReadOnly">
            <summary>
            
            </summary>
            <value>True if dictionary is read-only</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDictionary`2.Keys">
            <summary>
            
            </summary>
            <value>A collection containing all the keys of the dictionary</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDictionary`2.Values">
            <summary>
            
            </summary>
            <value>A collection containing all the values of the dictionary</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDictionary`2.Func">
            <summary>
            
            </summary>
            <value>A delegate of type <see cref="T:Func`2"/> defining the partial function from K to V give by the dictionary.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Add(`0,`1)">
            <summary>
            Add a new (key, value) pair (a mapping) to the dictionary.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"> if there already is an entry with the same key. </exception>>
            <param name="key">Key to add</param>
            <param name="val">Value to add</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.AddAll``2(System.Collections.Generic.IEnumerable{Lucene.Net.Support.C5.KeyValuePair{``0,``1}})">
            <summary>
            Add the entries from a collection of <see cref="T:C5.KeyValuePair`2"/> pairs to this dictionary.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"> 
            If the input contains duplicate keys or a key already present in this dictionary.</exception>
            <param name="entries"></param>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDictionary`2.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant). 
            <para>See <see cref="T:C5.Speed"/> for the set of symbols.</para>
            </summary>
            <value>A characterization of the speed of lookup operations
            (<code>Contains()</code> etc.) of the implementation of this dictionary.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.ContainsAll``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Check whether this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Remove(`0)">
            <summary>
            Remove an entry with a given key from the dictionary
            </summary>
            <param name="key">The key of the entry to remove</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Remove(`0,`1@)">
            <summary>
            Remove an entry with a given key from the dictionary and report its value.
            </summary>
            <param name="key">The key of the entry to remove</param>
            <param name="val">On exit, the value of the removed entry</param>
            <returns>True if an entry was found (and removed)</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Clear">
            <summary>
            Remove all entries from the dictionary
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Contains(`0)">
            <summary>
            Check if there is an entry with a specified key
            </summary>
            <param name="key">The key to look for</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Find(`0@,`1@)">
            <summary>
            Check if there is an entry with a specified key and report the corresponding
            value if found. This can be seen as a safe form of "val = this[key]".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On exit, the value of the entry</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Update(`0,`1)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val".
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The new value</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Update(`0,`1,`1@)">
            <summary>
            Look for a specific key in the dictionary and if found replace the value with a new one.
            This can be seen as a non-adding version of "this[key] = val" reporting the old value.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The new value</param>
            <param name="oldval">The old value if any</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.FindOrAdd(`0,`1@)">
            <summary>
            Look for a specific key in the dictionary. If found, report the corresponding value,
            else add an entry with the key and the supplied value.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">On entry the value to add if the key is not found.
            On exit the value found if any.</param>
            <returns>True if key was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.UpdateOrAdd(`0,`1)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The value to add or replace with.</param>
            <returns>True if key was found and value updated.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.UpdateOrAdd(`0,`1,`1@)">
            <summary>
            Update value in dictionary corresponding to key if found, else add new entry.
            More general than "this[key] = val;" by reporting if key was found.
            </summary>
            <param name="key">The key to look for</param>
            <param name="val">The value to add or replace with.</param>
            <param name="oldval">The old value if any</param>
            <returns>True if key was found and value updated.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDictionary`2.Check">
            <summary>
            Check the integrity of the internal data structures of this dictionary.
            Only available in DEBUG builds???
            </summary>
            <returns>True if check does not fail.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.ISortedDictionary`2">
            <summary>
            A dictionary with sorted keys.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.ISortedDictionary`2.Keys">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.FindMin">
            <summary>
            Find the current least item of this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The least item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.DeleteMin">
            <summary>
            Remove the least item from this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.FindMax">
            <summary>
            Find the current largest item of this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The largest item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.DeleteMax">
            <summary>
            Remove the largest item from this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.ISortedDictionary`2.Comparer">
            <summary>
            The key comparer used by this dictionary.
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.TryPredecessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a predecessor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.TrySuccessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The successor, if any</param>
            <returns>True if the key has a successor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.TryWeakPredecessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak predecessor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The predecessor, if any</param>
            <returns>True if key has a weak predecessor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.TryWeakSuccessor(`0,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@)">
            <summary>
            Find the entry in the dictionary whose key is the
            weak successor of the specified key.
            </summary>
            <param name="key">The key</param>
            <param name="res">The weak successor, if any</param>
            <returns>True if the key has a weak successor</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.Predecessor(`0)">
            <summary>
            Find the entry with the largest key less than a given key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.Successor(`0)">
            <summary>
            Find the entry with the least key greater than a given key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.WeakPredecessor(`0)">
            <summary>
            Find the entry with the largest key less than or equal to a given key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.WeakSuccessor(`0)">
            <summary>
            Find the entry with the least key greater than or equal to a given key.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if there is no such entry. </exception>
            <param name="key">The key to compare to</param>
            <returns>The entry</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.Cut(System.IComparable{`0},Lucene.Net.Support.C5.KeyValuePair{`0,`1}@,System.Boolean@,Lucene.Net.Support.C5.KeyValuePair{`0,`1}@,System.Boolean@)">
            <summary>
            Given a "cut" function from the items of the sorted collection to <code>int</code>
            whose only sign changes when going through items in increasing order
            can be 
            <list>
            <item>from positive to zero</item>
            <item>from positive to negative</item>
            <item>from zero to negative</item>
            </list>
            The "cut" function is supplied as the <code>CompareTo</code> method 
            of an object <code>c</code> implementing 
            <code>IComparable&lt;K&gt;</code>. 
            A typical example is the case where <code>K</code> is comparable and 
            <code>c</code> is itself of type <code>K</code>.
            <para>This method performs a search in the sorted collection for the ranges in which the
            "cut" function is negative, zero respectively positive. If <code>K</code> is comparable
            and <code>c</code> is of type <code>K</code>, this is a safe way (no exceptions thrown) 
            to find predecessor and successor of <code>c</code>.
            </para>
            <para> If the supplied cut function does not satisfy the sign-change condition, 
            the result of this call is undefined.
            </para>
            
            </summary>
            <param name="cutFunction">The cut function <code>K</code> to <code>int</code>, given
            by the <code>CompareTo</code> method of an object implementing 
            <code>IComparable&lt;K&gt;</code>.</param>
            <param name="lowEntry">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">Returns true if the cut function is positive somewhere
            on this collection.</param>
            <param name="highEntry">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">Returns true if the cut function is negative somewhere
            on this collection.</param>
            <returns>True if the cut function is zero somewhere
            on this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="lowerBound">The lower bound (inclusive).</param>
            <param name="upperBound">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.AddSorted(System.Collections.Generic.IEnumerable{Lucene.Net.Support.C5.KeyValuePair{`0,`1}})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            </summary>
            <exception cref="T:System.ArgumentException"> if the enumerated items turns out
            not to be in increasing order.</exception>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISortedDictionary`2.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.IIndexedSorted`1">
            <summary>
            A collection where items are maintained in sorted order together
            with their indexes in that order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="predicate">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexedSorted`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <param name="comparer">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.IPersistentSorted`1">
            <summary>
            The type of a sorted collection with persistence
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPersistentSorted`1.Snapshot">
            <summary>
            Make a (read-only) snap shot of this collection.
            </summary>
            <returns>The snap shot.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.IExtensible`1">
            <summary>
            A generic collection to which one may add items. This is just the intersection
            of the main stream generic collection interfaces and the priority queue interface,
            <see cref="T:C5.ICollection`1"/> and <see cref="T:C5.IPriorityQueue`1"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.IExtensible`1.IsReadOnly">
            <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code>
            </summary>
            <value>True if this collection is read-only.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IExtensible`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value>False if this collection has set semantics, true if bag semantics.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IExtensible`1.EqualityComparer">
            <summary>
            (Here should be a discussion of the role of equalityComparers. Any ). 
            </summary>
            <value>The equalityComparer used by this collection to check equality of items. 
            Or null (????) if collection does not check equality at all or uses a comparer.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IExtensible`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.IExtensible`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IExtensible`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IExtensible`1.Check">
            <summary>
            Check the integrity of the internal data structures of this collection.
            <i>This is only relevant for developers of the library</i>
            </summary>
            <returns>True if check was passed.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.ICollection`1">
            <summary>
            The simplest interface of a main stream generic collection
            with lookup, insertion and removal operations. 
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollection`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant). 
            <para>See <see cref="T:C5.Speed"/> for the set of symbols.</para>
            </summary>
            <value>A characterization of the speed of lookup operations
            (<code>Contains()</code> etc.) of the implementation of this collection.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollection`1.Count">
            <summary>
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollection`1.IsReadOnly">
            <summary>
            If true any call of an updating operation will throw an
            <code>ReadOnlyCollectionException</code>
            </summary>
            <value>True if this collection is read-only.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to a contiguous part of an array.
            </summary>
            <param name="array">The array to copy to</param>
            <param name="index">The index at which to copy the first item</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.GetUnsequencedHashCode">
            <summary>
            The unordered collection hashcode is defined as the sum of 
            <code>h(hashcode(item))</code> over the items
            of the collection, where the function <code>h</code> is a function from 
            int to int of the form <code> t -> (a0*t+b0)^(a1*t+b1)^(a2*t+b2)</code>, where 
            the ax and bx are the same for all collection classes. 
            <para>The current implementation uses fixed values for the ax and bx, 
            specified as constants in the code.</para>
            </summary>
            <returns>The unordered hashcode of this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.UnsequencedEquals(Lucene.Net.Support.C5.ICollection{`0})">
            <summary>
            Compare the contents of this collection to another one without regards to
            the sequence order. The comparison will use this collection's itemequalityComparer
            to compare individual items.
            </summary>
            <param name="otherCollection">The collection to compare to.</param>
            <returns>True if this collection and that contains the same items.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check whether this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.FindOrAdd(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found. Else, add the item to the collection.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the item was found (hence not added).</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a (binary copy of) the supplied value. If the collection has bag semantics,
            it depends on the value of DuplicatesByCounting if this updates all equivalent copies in
            the collection or just one.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Update(`0,`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a (binary copy of) the supplied value. If the collection has bag semantics,
            it depends on the value of DuplicatesByCounting if this updates all equivalent copies in
            the collection or just one.
            </summary>
            <param name="item">Value to update.</param>
            <param name="olditem">On output the olditem, if found.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.UpdateOrAdd(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.UpdateOrAdd(`0,`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value; else add the value to the collection. 
            </summary>
            <param name="item">Value to add or update.</param>
            <param name="olditem">On output the olditem, if found.</param>
            <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The value removed if any.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollection`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.IDirectedEnumerable`1">
            <summary>
            A generic collection, that can be enumerated backwards.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDirectedEnumerable`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.IDirectedEnumerable`1.Direction">
            <summary>
            <code>Forwards</code> if same, else <code>Backwards</code>
            </summary>
            <value>The enumeration direction relative to the original collection.</value>
        </member>
        <member name="T:Lucene.Net.Support.C5.IDirectedCollectionValue`1">
            <summary>
            A sized generic collection, that can be enumerated backwards.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDirectedCollectionValue`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IDirectedCollectionValue`1.FindLast(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.ICollectionValue`1">
            <summary>
            A generic collection that may be enumerated and can answer
            efficiently how many items it contains. Like <code>IEnumerable&lt;T&gt;</code>,
            this interface does not prescribe any operations to initialize or update the 
            collection. The main usage for this interface is to be the return type of 
            query operations on generic collection.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollectionValue`1.ListenableEvents">
            <summary>
            A flag bitmap of the events subscribable to by this collection.
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollectionValue`1.ActiveEvents">
            <summary>
            A flag bitmap of the events currently subscribed to by this collection.
            </summary>
            <value></value>
        </member>
        <member name="E:Lucene.Net.Support.C5.ICollectionValue`1.CollectionChanged">
            <summary>
            The change event. Will be raised for every change operation on the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.ICollectionValue`1.CollectionCleared">
            <summary>
            The change event. Will be raised for every clear operation on the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.ICollectionValue`1.ItemsAdded">
            <summary>
            The item added  event. Will be raised for every individual addition to the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.ICollectionValue`1.ItemInserted">
            <summary>
            The item inserted  event. Will be raised for every individual insertion to the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.ICollectionValue`1.ItemsRemoved">
            <summary>
            The item removed event. Will be raised for every individual removal from the collection.
            </summary>
        </member>
        <member name="E:Lucene.Net.Support.C5.ICollectionValue`1.ItemRemovedAt">
            <summary>
            The item removed at event. Will be raised for every individual removal at from the collection.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollectionValue`1.IsEmpty">
            <summary>
            
            </summary>
            <value>True if this collection is empty.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollectionValue`1.Count">
            <summary>
            </summary>
            <value>The number of items in this collection</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.ICollectionValue`1.CountSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>A characterization of the speed of the 
            <code>Count</code> property in this collection.</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the items of this collection to a contiguous part of an array.
            </summary>
            <param name="array">The array to copy to</param>
            <param name="index">The index at which to copy the first item</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.ToArray">
            <summary>
            Create an array with the items of this collection (in the same order as an
            enumerator would output them).
            </summary>
            <returns>The array</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.Apply(System.Action{`0})">
            <summary>
            Apply a delegate to all items of this collection.
            </summary>
            <param name="action">The delegate to apply</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.Exists(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection.
            </summary>
            <param name="predicate">A  delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.Find(System.Func{`0,System.Boolean},`0@)">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the first one in enumeration order.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <param name="item"></param>
            <returns>True is such an item exists</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.All(System.Func{`0,System.Boolean})">
            <summary>
            Check if all items in this collection satisfies a specific predicate.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>True if all items satisfies the predicate</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.Choose">
            <summary>
            Choose some item of this collection. 
            <para>Implementations must assure that the item 
            returned may be efficiently removed.</para>
            <para>Implementors may decide to implement this method in a way such that repeated
            calls do not necessarily give the same result, i.e. so that the result of the following 
            test is undetermined:
            <code>coll.Choose() == coll.Choose()</code></para>
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException">if collection is empty.</exception>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ICollectionValue`1.Filter(System.Func{`0,System.Boolean})">
            <summary>
            Create an enumerable, enumerating the items of this collection that satisfies 
            a certain condition.
            </summary>
            <param name="filter">The T->bool filter delegate defining the condition</param>
            <returns>The filtered enumerable</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.IShowable">
            <summary>
            <i>(Describe usage of "L:300" format string.)</i>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IShowable.Show(System.Text.StringBuilder,System.Int32@,System.IFormatProvider)">
            <summary>
            Format <code>this</code> using at most approximately <code>rest</code> chars and 
            append the result, possibly truncated, to stringbuilder.
            Subtract the actual number of used chars from <code>rest</code>.
            </summary>
            <param name="stringbuilder"></param>
            <param name="rest"></param>
            <param name="formatProvider"></param>
            <returns>True if the appended formatted string was complete (not truncated).</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.ISorted`1">
            <summary>
            A sorted collection, i.e. a collection where items are maintained and can be searched for in sorted order.
            Thus the sequence order is given as a sorting order.
            
            <para>The sorting order is defined by a comparer, an object of type IComparer&lt;T&gt; 
            (<see cref="T:C5.IComparer`1"/>). Implementors of this interface will normally let the user 
            define the comparer as an argument to a constructor. 
            Usually there will also be constructors without a comparer argument, in which case the 
            comparer should be the defalt comparer for the item type, <see cref="P:C5.Comparer`1.Default"/>.</para>
            
            <para>The comparer of the sorted collection is available as the <code>System.Collections.Generic.Comparer</code> property 
            (<see cref="P:C5.ISorted`1.Comparer"/>).</para>
            
            <para>The methods are grouped according to
            <list>
            <item>Extrema: report or report and delete an extremal item. This is reminiscent of simplified priority queues.</item>
            <item>Nearest neighbor: report predecessor or successor in the collection of an item. Cut belongs to this group.</item>
            <item>Range: report a view of a range of elements or remove all elements in a range.</item>
            <item>AddSorted: add a collection of items known to be sorted in the same order (should be faster) (to be removed?)</item>
            </list>
            </para>
            
            <para>Since this interface extends ISequenced&lt;T&gt;, sorted collections will also have an 
            item equalityComparer (<see cref="P:C5.IExtensible`1.EqualityComparer"/>). This equalityComparer will not be used in connection with 
            the inner workings of the sorted collection, but will be used if the sorted collection is used as 
            an item in a collection of unsequenced or sequenced collections, 
            (<see cref="T:C5.ICollection`1"/> and <see cref="T:C5.ISequenced`1"/>)</para>
            
            <para>Note that code may check if two sorted collections has the same sorting order 
            by checking if the Comparer properties are equal. This is done a few places in this library
            for optimization purposes.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.FindMin">
            <summary>
            Find the current least item of this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The least item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.DeleteMin">
            <summary>
            Remove the least item from this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.FindMax">
            <summary>
            Find the current largest item of this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The largest item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.DeleteMax">
            <summary>
            Remove the largest item from this sorted collection.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if the collection is empty.</exception>
            <returns>The removed item.</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.ISorted`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this sorted collection.
            </summary>
            <value>The comparer</value>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.TryPredecessor(`0,`0@)">
            <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <param name="res">The predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a predecessor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.TrySuccessor(`0,`0@)">
            <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <param name="item">The item to find the successor for.</param>
            <param name="res">The successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a successor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.TryWeakPredecessor(`0,`0@)">
            <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak predecessor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.TryWeakSuccessor(`0,`0@)">
            <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <param name="res">The weak successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak successor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            that is, the largest item in the collection less than the supplied value.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            that is, the largest item in the collection less than or equal to the supplied value.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.WeakSuccessor(`0)">
             <summary>
             Find the weak successor in the sorted collection of a particular value,
             that is, the least item in the collection greater than or equal to the supplied value.
             </summary>
             <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
             supplied  value is greater than the maximum of this collection.)</exception>
            <param name="item">The item to find the weak successor for.</param>
             <returns>The weak successor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Given a "cut" function from the items of the sorted collection to <code>int</code>
            whose only sign changes when going through items in increasing order
            can be 
            <list>
            <item>from positive to zero</item>
            <item>from positive to negative</item>
            <item>from zero to negative</item>
            </list>
            The "cut" function is supplied as the <code>CompareTo</code> method 
            of an object <code>c</code> implementing 
            <code>IComparable&lt;T&gt;</code>. 
            A typical example is the case where <code>T</code> is comparable and 
            <code>cutFunction</code> is itself of type <code>T</code>.
            <para>This method performs a search in the sorted collection for the ranges in which the
            "cut" function is negative, zero respectively positive. If <code>T</code> is comparable
            and <code>c</code> is of type <code>T</code>, this is a safe way (no exceptions thrown) 
            to find predecessor and successor of <code>c</code>.
            </para>
            <para> If the supplied cut function does not satisfy the sign-change condition, 
            the result of this call is undefined.
            </para>
            
            </summary>
            <param name="cutFunction">The cut function <code>T</code> to <code>int</code>, given
            by the <code>CompareTo</code> method of an object implementing 
            <code>IComparable&lt;T&gt;</code>.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">Returns true if the cut function is positive somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">Returns true if the cut function is negative somewhere
            on this collection.</param>
            <returns>True if the cut function is zero somewhere
            on this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            <para>The returned collection is not a copy but a view into the collection.</para>
            <para>The view is fragile in the sense that changes to the underlying collection will 
            invalidate the view so that further operations on the view throws InvalidView exceptions.</para>
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items.
            </summary>
            <exception cref="T:System.ArgumentException"> if the enumerated items turns out
            not to be in increasing order.</exception>
            <param name="items">The collection to add.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISorted`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ISequenced`1">
             <summary>
             An editable collection maintaining a definite sequence order of the items.
            
             <i>Implementations of this interface must compute the hash code and 
             equality exactly as prescribed in the method definitions in order to
             be consistent with other collection classes implementing this interface.</i>
             <i>This interface is usually implemented by explicit interface implementation,
             not as ordinary virtual methods.</i>
             </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISequenced`1.GetSequencedHashCode">
            <summary>
            The hashcode is defined as <code>h(...h(h(h(x1),x2),x3),...,xn)</code> for
            <code>h(a,b)=CONSTANT*a+b</code> and the x's the hash codes of the items of 
            this collection.
            </summary>
            <returns>The sequence order hashcode of this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.ISequenced`1.SequencedEquals(Lucene.Net.Support.C5.ISequenced{`0})">
            <summary>
            Compare this sequenced collection to another one in sequence order.
            </summary>
            <param name="otherCollection">The sequenced collection to compare to.</param>
            <returns>True if this collection and that contains equal (according to
            this collection's itemequalityComparer) in the same sequence order.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.IIndexed`1">
            <summary>
            A sequenced collection, where indices of items in the order are maintained
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.IIndexed`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IIndexed`1.Item(System.Int32,System.Int32)">
            <summary>
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The low index of the interval (inclusive).</param>
            <param name="count">The size of the range.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexed`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwards from the start. 
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start. A negative number if item not found, 
            namely the one's complement of the index at which the Add operation would put the item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexed`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the list going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of of item from the end. A negative number if item not found, 
            namely the two-complement of the index at which the Add operation would put the item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexed`1.FindIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the first one.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexed`1.FindLastIndex(System.Func{`0,System.Boolean})">
            <summary>
            Check if there exists an item  that satisfies a
            specific predicate in this collection and return the index of the last one.
            </summary>
            <param name="predicate">A delegate 
            (<see cref="T:Func`2"/> with <code>R == bool</code>) defining the predicate</param>
            <returns>the index, if found, a negative value else</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexed`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt;= the size of the collection.</exception>
            <param name="index">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IIndexed`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException"> if start or count 
            is negative or start+count &gt; the size of the collection.</exception>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.IReadOnlyList`1">
            <summary>
            Represents a read-only collection of elements that can be accessed by index. 
            Enables System.Collections.Generic.IReadOnlyList to be used in .NET 4.5 projects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Lucene.Net.Support.C5.IReadOnlyList`1.Item(System.Int32)">
            <summary>
            Gets the element at the specified index in the read-only list.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.IReadOnlyCollection`1">
            <summary>
            Represents a strongly-typed, read-only collection of elements.
            Enables System.Collections.Generic.IReadOnlyCollection to be used in .NET 4.5 projects
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Lucene.Net.Support.C5.IStack`1">
            <summary>
            The interface describing the operations of a LIFO stack data structure.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="P:Lucene.Net.Support.C5.IStack`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IStack`1.Item(System.Int32)">
            <summary>
            Get the <code>index</code>'th element of the stack.  The bottom of the stack has index 0.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IStack`1.Push(`0)">
            <summary>
            Push an item to the top of the stack.
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IStack`1.Pop">
            <summary>
            Pop the item at the top of the stack from the stack.
            </summary>
            <returns>The popped item.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.IQueue`1">
            <summary>
            The interface describing the operations of a FIFO queue data structure.
            </summary>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="P:Lucene.Net.Support.C5.IQueue`1.AllowsDuplicates">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IQueue`1.Item(System.Int32)">
            <summary>
            Get the <code>index</code>'th element of the queue.  The front of the queue has index 0.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IQueue`1.Enqueue(`0)">
            <summary>
            Enqueue an item at the back of the queue. 
            </summary>
            <param name="item">The item</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IQueue`1.Dequeue">
            <summary>
            Dequeue an item from the front of the queue.
            </summary>
            <returns>The item</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.IList`1">
             <summary>
             This is an indexed collection, where the item order is chosen by 
             the user at insertion time.
            
             NBNBNB: we need a description of the view functionality here!
             </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.First">
            <summary>
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The first item in this list.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.Last">
            <summary>
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if this list is empty.</exception>
            <value>The last item in this list.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.FIFO">
            <summary>
            Since <code>Add(T item)</code> always add at the end of the list,
            this describes if list has FIFO or LIFO semantics.
            </summary>
            <value>True if the <code>Remove()</code> operation removes from the
            start of the list, false if it removes from the end.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.Item(System.Int32)">
            <summary>
            On this list, this indexer is read/write.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if index is negative or
            &gt;= the size of the collection.</exception>
            <value>The index'th item of this list.</value>
            <param name="index">The index of the item to fetch or store.</param>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.Count">
            <summary>
            
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.IsReadOnly">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Add(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Clear">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Contains(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.CopyTo(`0[],System.Int32)">
            <summary>
            
            </summary>
            <param name="array"></param>
            <param name="index"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Remove(`0)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.IndexOf(`0)">
            <summary>
            Searches for an item in the list going forwards from the start. 
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of item from start. A negative number if item not found, 
            namely the one's complement of the index at which the Add operation would put the item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt;= the size of the collection.</exception>
            <param name="index">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Insert(Lucene.Net.Support.C5.IList{`0},`0)">
            <summary>
            Insert an item at the end of a compatible view, used as a pointer.
            <para>The <code>pointer</code> must be a view on the same list as
            <code>this</code> and the endpoint of <code>pointer</code> must be
            a valid insertion point of <code>this</code></para>
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.IncompatibleViewException">If <code>pointer</code> 
            is not a view on the same list as <code>this</code></exception>
            <exception cref="T:System.IndexOutOfRangeException"><b>??????</b> if the endpoint of 
             <code>pointer</code> is not inside <code>this</code></exception>
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.</exception>
            <param name="pointer"></param>
            <param name="item"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.InsertFirst(`0)">
            <summary>
            Insert an item at the front of this list.
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"/> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.InsertLast(`0)">
            <summary>
            Insert an item at the back of this list.
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"/> if the list has
            <code>AllowsDuplicates==false</code> and the item is 
            already in the list.
            </summary>
            <param name="item">The item to insert.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.InsertAll(System.Int32,System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Insert into this list all items from an enumerable collection starting 
            at a particular index.
            </summary>
            <exception cref="T:System.IndexOutOfRangeException"> if <code>index</code> is negative or
            &gt; the size of the collection.</exception>
            <exception cref="T:Lucene.Net.Support.C5.DuplicateNotAllowedException"> if the list has 
            <code>AllowsDuplicates==false</code> and one of the items to insert is
            already in the list.</exception>
            <param name="index">Index to start inserting at</param>
            <param name="items">Items to insert</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new list consisting of the items of this list satisfying a 
            certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Map``1(System.Func{`0,``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use the default equalityComparer for the item type V.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Create a new list consisting of the results of mapping all items of this
            list. The new list will use a specified equalityComparer for the item type.
            </summary>
            <typeparam name="V">The type of items of the new list</typeparam>
            <param name="mapper">The delegate defining the map.</param>
            <param name="equalityComparer">The equalityComparer to use for the new list</param>
            <returns>The new list.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Remove">
            <summary>
            Remove one item from the list: from the front if <code>FIFO</code>
            is true, else from the back.
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.RemoveFirst">
            <summary>
            Remove one item from the front of the list.
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.RemoveLast">
            <summary>
            Remove one item from the back of the list.
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"/> if this list is empty.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.View(System.Int32,System.Int32)">
            <summary>
            Create a list view on this list. 
            <exception cref="T:System.ArgumentOutOfRangeException"/> if the view would not fit into
            this list.
            </summary>
            <param name="start">The index in this list of the start of the view.</param>
            <param name="count">The size of the view.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.ViewOf(`0)">
            <summary>
            Create a list view on this list containing the (first) occurrence of a particular item. 
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"/> if the item is not in this list.
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.LastViewOf(`0)">
            <summary>
            Create a list view on this list containing the last occurrence of a particular item. 
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"/> if the item is not in this list.
            </summary>
            <param name="item">The item to find.</param>
            <returns>The new list view.</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.Underlying">
            <summary>
            Null if this list is not a view.
            </summary>
            <value>Underlying list for view.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.Offset">
            <summary>
            </summary>
            <value>Offset for this list view or 0 for an underlying list.</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IList`1.IsValid">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Slide(System.Int32)">
            <summary>
            Slide this list view along the underlying list.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Slide(System.Int32,System.Int32)">
            <summary>
            Slide this list view along the underlying list, changing its size.
            
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NotAViewException"> if this list is not a view.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"> if the operation
            would bring either end of the view outside the underlying list.</exception>
            <param name="offset">The signed amount to slide: positive to slide
            towards the end.</param>
            <param name="size">The new size of the view.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.TrySlide(System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.TrySlide(System.Int32,System.Int32)">
            <summary>
            
            </summary>
            <param name="offset"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Span(Lucene.Net.Support.C5.IList{`0})">
            <summary>
            
            <para>Returns null if <code>otherView</code> is strictly to the left of this view</para>
            </summary>
            <param name="otherView"></param>
            <exception cref="T:Lucene.Net.Support.C5.IncompatibleViewException">If otherView does not have the same underlying list as this</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">If <code>otherView</code> is strictly to the left of this view</exception>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Reverse">
            <summary>
            Reverse the list so the items are in the opposite sequence order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.IsSorted">
            <summary>
            Check if this list is sorted according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NotComparableException">if T is not comparable</exception>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.IsSorted(System.Collections.Generic.IComparer{`0})">
            <summary>
            Check if this list is sorted according to a specific sorting order.
            </summary>
            <param name="comparer">The comparer defining the sorting order.</param>
            <returns>True if the list is sorted, else false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Sort">
            <summary>
            Sort the items of the list according to the default sorting order
            for the item type T, as defined by the <see cref="T:C5.Comparer`1"/> class 
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NotComparableException">if T is not comparable</exception>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>
            Sort the items of the list according to a specified sorting order.
            <para>The sorting does not perform duplicate elimination or identify items
            according to the comparer or itemequalityComparer. I.e. the list as an 
            unsequenced collection with binary equality, will not change.
            </para>
            </summary>
            <param name="comparer">The comparer defining the sorting order.</param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Shuffle">
            <summary>
            Randomly shuffle the items of this list. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IList`1.Shuffle(System.Random)">
            <summary>
            Shuffle the items of this list according to a specific random source.
            </summary>
            <param name="rnd">The random source.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.IPriorityQueueHandle`1">
            <summary>
            The base type of a priority queue handle
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Lucene.Net.Support.C5.IPriorityQueue`1">
            <summary>
            A generic collection of items prioritized by a comparison (order) relation.
            Supports adding items and reporting or removing extremal elements. 
            <para>
            
            </para>
            When adding an item, the user may choose to have a handle allocated for this item in the queue. 
            The resulting handle may be used for deleting the item even if not extremal, and for replacing the item.
            A priority queue typically only holds numeric priorities associated with some objects
            maintained separately in other collection objects.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.DeleteMax">
            <summary>
            Remove the largest item from this priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="P:Lucene.Net.Support.C5.IPriorityQueue`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="P:Lucene.Net.Support.C5.IPriorityQueue`1.Item(Lucene.Net.Support.C5.IPriorityQueueHandle{`0})">
            <summary>
            Get or set the item corresponding to a handle. Throws exceptions on 
            invalid handles.
            </summary>
            <param name="handle"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.Find(Lucene.Net.Support.C5.IPriorityQueueHandle{`0},`0@)">
            <summary>
            Check if the entry corresponding to a handle is in the priority queue.
            </summary>
            <param name="handle"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.Add(Lucene.Net.Support.C5.IPriorityQueueHandle{`0}@,`0)">
            <summary>
            Add an item to the priority queue, receiving a 
            handle for the item in the queue, 
            or reusing an existing unused handle.
            </summary>
            <param name="handle">On output: a handle for the added item. 
            On input: null for allocating a new handle, or a currently unused handle for reuse. 
            A handle for reuse must be compatible with this priority queue, 
            by being created by a priority queue of the same runtime type, but not 
            necessarily the same priority queue object.</param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.Delete(Lucene.Net.Support.C5.IPriorityQueueHandle{`0})">
            <summary>
            Delete an item with a handle from a priority queue
            </summary>
            <param name="handle">The handle for the item. The handle will be invalidated, but reusable.</param>
            <returns>The deleted item</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.Replace(Lucene.Net.Support.C5.IPriorityQueueHandle{`0},`0)">
            <summary>
            Replace an item with a handle in a priority queue with a new item. 
            Typically used for changing the priority of some queued object.
            </summary>
            <param name="handle">The handle for the old item</param>
            <param name="item">The new item</param>
            <returns>The old item</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.FindMin(Lucene.Net.Support.C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <param name="handle">On return: the handle of the item.</param>
            <returns>The least item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.FindMax(Lucene.Net.Support.C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <param name="handle">On return: the handle of the item.</param>
            <returns>The largest item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.DeleteMin(Lucene.Net.Support.C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <param name="handle">On return: the handle of the removed item.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.C5.IPriorityQueue`1.DeleteMax(Lucene.Net.Support.C5.IPriorityQueueHandle{`0}@)">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <param name="handle">On return: the handle of the removed item.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="T:Lucene.Net.Support.C5.Speed">
            <summary>
            The symbolic characterization of the speed of lookups for a collection.
            The values may refer to worst-case, amortized and/or expected asymtotic 
            complexity wrt. the collection size.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.Speed.PotentiallyInfinite">
            <summary>
            Counting the collection with the <code>Count property</code> may not return
            (for a synthetic and potentially infinite collection).
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.Speed.Linear">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property may take time O(n),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.Speed.Log">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(log n),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.Speed.Constant">
            <summary>
            Lookup operations like <code>Contains(T item)</code> or the <code>Count</code>
            property  takes time O(1),
            where n is the size of the collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.EnumerationDirection">
            <summary>
            Direction of enumeration order relative to original collection.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EnumerationDirection.Forwards">
            <summary>
            Same direction
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EnumerationDirection.Backwards">
            <summary>
            Opposite direction
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.MemoryType">
            <summary>
            It specifies the memory type strategy of the internal enumerator implemented to iterate over the collection.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.MemoryType.Normal">
            <summary>
            Normal is the usual operator type. A new instance of an enumerator is always returned
            for multithread safety purposes.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.MemoryType.Safe">
            <summary>
            Safe returns the same enumerator instance and updates references or a new instance in case of multiple enumeration and multithread access  
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.MemoryType.Strict">
            <summary>
            Strict always returns the same enumerator instance. An exception is raised if the collection is enumerated more than once or
            if the collection is accessed by multiple threads concurrently.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.EventTypeEnum">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.None">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.Changed">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.Cleared">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.Added">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.Removed">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.Basic">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.Inserted">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.RemovedAt">
            <summary>
            
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.C5.EventTypeEnum.All">
            <summary>
            
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.InternalException">
            <summary>
            An exception to throw from library code when an internal inconsistency is encountered.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.InternalException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ReadOnlyCollectionException">
            <summary>
            An exception thrown by an update operation on a Read-Only collection or dictionary.
            <para>This exception will be thrown unconditionally when an update operation 
            (method or set property) is called. No check is made to see if the update operation, 
            if allowed, would actually change the collection. </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ReadOnlyCollectionException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ReadOnlyCollectionException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ReadOnlyCollectionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.FixedSizeCollectionException">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.FixedSizeCollectionException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.FixedSizeCollectionException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.FixedSizeCollectionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.UnlistenableEventException">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.UnlistenableEventException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.UnlistenableEventException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.UnlistenableEventException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ConcurrentEnumerationException">
            <summary>
            An exception thrown by the MemorySafeEnumerator if the collection is enumerated by multiple threads concurrently
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ConcurrentEnumerationException.#ctor">
            <summary>
             Create a simple exception with no further explanation. 
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ConcurrentEnumerationException.#ctor(System.String)">
            <summary>
            Create a simple exception with the an explanation contained in the error message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ConcurrentEnumerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.MultipleEnumerationException">
            <summary>
            An exception thrown by the MemorySafeEnumerator if the collection is enumerated multiple times when the 
            memory mode is set to Strict 
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.MultipleEnumerationException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.MultipleEnumerationException.#ctor(System.String)">
            <summary>
            Create a simple exception with the an explanation contained in the error message.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.MultipleEnumerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.CollectionModifiedException">
            <summary>
            An exception thrown by enumerators, range views etc. when accessed after 
            the underlying collection has been modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionModifiedException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionModifiedException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.CollectionModifiedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ViewDisposedException">
            <summary>
            An exception thrown when trying to access a view (a list view on a <see cref="T:C5.IList`1"/> or 
            a snapshot on a <see cref="T:C5.IPersistentSorted`1"/>)
            that has been invalidated by some earlier operation.
            <para>
            The typical scenario is a view on a list that hash been invalidated by a call to 
            Sort, Reverse or Shuffle on some other, overlapping view or the whole list.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ViewDisposedException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.ViewDisposedException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.ViewDisposedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.NoSuchItemException">
            <summary>
            An exception thrown by a lookup or lookup with update operation that does not 
            find the lookup item and has no other means to communicate failure.
            <para>The typical scenario is a lookup by key in a dictionary with an indexer,
            see e.g. <see cref="P:C5.IDictionary`2.Item(`0)"/></para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.NoSuchItemException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.NoSuchItemException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.NoSuchItemException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.NotAViewException">
            <summary>
            An exception thrown by an operation on a list (<see cref="T:C5.IList`1"/>)
            that only makes sense for a view, not for an underlying list.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.NotAViewException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.NotAViewException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.NotAViewException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.DuplicateNotAllowedException">
            <summary>
            An exception thrown when an operation attempts to create a duplicate in a collection with set semantics 
            (<see cref="P:C5.IExtensible`1.AllowsDuplicates"/> is false) or attempts to create a duplicate key in a dictionary.
            <para>With collections this can only happen with Insert operations on lists, since the Add operations will
            not try to create duplictes and either ignore the failure or report it in a bool return value.
            </para>
            <para>With dictionaries this can happen with the <see cref="M:C5.IDictionary`2.Add(`0,`1)"/> metod.</para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.DuplicateNotAllowedException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.DuplicateNotAllowedException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.DuplicateNotAllowedException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.InvalidPriorityQueueHandleException">
            <summary>
            
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.InvalidPriorityQueueHandleException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.InvalidPriorityQueueHandleException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.InvalidPriorityQueueHandleException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.NotComparableException">
            <summary>
            An exception thrown by an operation that need to construct a natural
            comparer for a type.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.NotComparableException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.NotComparableException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.NotComparableException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.IncompatibleViewException">
            <summary>
            An exception thrown by operations on a list that expects an argument
            that is a view on the same underlying list.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IncompatibleViewException.#ctor">
            <summary>
            Create a simple exception with no further explanation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.C5.IncompatibleViewException.#ctor(System.String)">
            <summary>
            Create the exception with an explanation of the reason.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:Lucene.Net.Support.C5.IncompatibleViewException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.CollectionChangedHandler`1">
            <summary>
            The type of event raised after an operation on a collection has changed its contents.
            Normally, a multioperation like AddAll, 
            <see cref="M:C5.IExtensible`1.AddAll(System.Collections.Generic.IEnumerable{`0})"/> 
            will only fire one CollectionChanged event. Any operation that changes the collection
            must fire CollectionChanged as its last event.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.C5.CollectionClearedHandler`1">
            <summary>
            The type of event raised after the Clear() operation on a collection.
            <para/>
            Note: The Clear() operation will not fire ItemsRemoved events. 
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ItemsAddedHandler`1">
            <summary>
            The type of event raised after an item has been added to a collection.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: an Update operation will fire an ItemsRemoved and an ItemsAdded event.
            <para/>
            Note: When an item is inserted into a list (<see cref="T:C5.IList`1"/>), both
            ItemInserted and ItemsAdded events will be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs">An object with the item that was added</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ItemsRemovedHandler`1">
            <summary>
            The type of event raised after an item has been removed from a collection.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: The Clear() operation will not fire ItemsRemoved events. 
            <para/>
            Note: an Update operation will fire an ItemsRemoved and an ItemsAdded event.
            <para/>
            Note: When an item is removed from a list by the RemoveAt operation, both an 
            ItemsRemoved and an ItemRemovedAt event will be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs">An object with the item that was removed</param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ItemInsertedHandler`1">
            <summary>
            The type of event raised after an item has been inserted into a list by an Insert, 
            InsertFirst or InsertLast operation.
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: an ItemsAdded event will also be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:Lucene.Net.Support.C5.ItemRemovedAtHandler`1">
            <summary>
            The type of event raised after an item has been removed from a list by a RemoveAt(int i)
            operation (or RemoveFirst(), RemoveLast(), Remove() operation).
            The event will be raised at a point of time, where the collection object is 
            in an internally consistent state and before the corresponding CollectionChanged 
            event is raised.
            <para/>
            Note: an ItemRemoved event will also be fired.
            </summary>
            <param name="sender"></param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:Lucene.Net.Support.Character">
            <summary>
            Mimics Java's Character class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Character.ForDigit(System.Int32,System.Int32)">
             <summary>
            
             </summary>
             <param name="digit"></param>
             <param name="radix"></param>
             <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Character.CodePointCount(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the text range of the specified char sequence. 
            The text range begins at the specified <paramref name="beginIndex"/> and extends to the char at index <c>endIndex - 1</c>. 
            Thus the length (in <see cref="T:System.Char"/>s) of the text range is <c>endIndex-beginIndex</c>. 
            Unpaired surrogates within the text range count as one code point each.
            </summary>
            <param name="seq">the char sequence</param>
            <param name="beginIndex">the index to the first char of the text range.</param>
            <param name="endIndex">the index after the last char of the text range.</param>
            <returns>the number of Unicode code points in the specified text range</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the <paramref name="beginIndex"/> is negative, or <paramref name="endIndex"/> 
            is larger than the length of the given sequence, or <paramref name="beginIndex"/> 
            is larger than <paramref name="endIndex"/>.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.Character.OffsetByCodePoints(System.String,System.Int32,System.Int32)">
            <summary>
            Copy of the implementation from Character class in Java
            
            http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/Character.java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Character.OffsetByCodePoints(System.Char[],System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy of the implementation from Character class in Java
            
            http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b27/java/lang/Character.java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Character.GetType(System.Int32)">
            <summary>
            LUCENENET safe way to get unicode category. The .NET <seealso cref="M:System.Char.ConvertFromUtf32(System.Int32)"/>
            method should be used first to be safe for surrogate pairs. However, if the value falls between
            0x00d800 and 0x00dfff, that method throws an exception. So this is a wrapper that converts the
            codepoint to a char in those cases.
            
            This mimics the behavior of the Java Character.GetType class, but returns the .NET UnicodeCategory
            enumeration for easy consumption.
            </summary>
            <param name="c"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.CultureContext">
            <summary>
            Allows switching the current thread to a new culture in a using block that will automatically 
            return the culture to its previous state upon completion.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Equatable">
            <summary>
            A set of utilities uses for easily wrapping .NET
            collections so they can be used with <see cref="M:System.Object.Equals(System.Object)"/>
            <see cref="M:System.Object.GetHashCode"/>, and <see cref="M:System.Object.ToString"/>
            behavior similar to that in Java. The equality checking of collections
            will recursively compare the values of all elements and any nested collections.
            The same goes for using <see cref="M:System.Object.ToString"/> - the string is based
            on the values in the collection and any nested collections.
            <para/>
            Do note this has a side-effect that any custom <see cref="M:System.Object.Equals(System.Object)"/>
            <see cref="M:System.Object.GetHashCode"/>, and <see cref="M:System.Object.ToString"/> implementations
            for types that implement <see cref="T:System.Collections.Generic.IList`1"/> (including arrays), <see cref="T:System.Collections.Generic.ISet`1"/>,
            or <see cref="T:System.Collections.Generic.IDictionary`2"/> will be ignored.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Equatable.Wrap``1(System.Collections.Generic.IList{``0})">
            <summary>
            Wraps any <see cref="T:System.Collections.Generic.IList`1"/> (including <see cref="T:T[]"/>) with a 
            lightweight <see cref="T:Lucene.Net.Support.EquatableList`1"/> class that changes the behavior
            of <see cref="M:System.Object.Equals(System.Object)"/>
            <see cref="M:System.Object.GetHashCode"/>, and <see cref="M:System.Object.ToString"/>
            so they consider all values in the <see cref="T:System.Collections.Generic.IList`1"/> or any nested
            collections when comparing or making strings to represent them.
            No other behavior is changed - only these 3 methods.
            <para/>
            Note that if the list is already an <see cref="T:Lucene.Net.Support.EquatableList`1"/> or a subclass
            of it, this method simply returns the provided <paramref name="list"/>.
            </summary>
            <typeparam name="T">the type of element</typeparam>
            <param name="list">Any <see cref="T:System.Collections.Generic.IList`1"/> (including <see cref="T:T[]"/>)</param>
            <returns>An <see cref="T:Lucene.Net.Support.EquatableList`1"/> that wraps the provided <paramref name="list"/>, 
            or the value of <paramref name="list"/> unmodified if it already is an <see cref="T:Lucene.Net.Support.EquatableList`1"/></returns>
        </member>
        <member name="M:Lucene.Net.Support.Equatable.Wrap``1(System.Collections.Generic.ISet{``0})">
            <summary>
            Wraps any <see cref="T:System.Collections.Generic.ISet`1"/> with a 
            lightweight <see cref="T:Lucene.Net.Support.EquatableSet`1"/> class that changes the behavior
            of <see cref="M:System.Object.Equals(System.Object)"/>
            <see cref="M:System.Object.GetHashCode"/>, and <see cref="M:System.Object.ToString"/>
            so they consider all values in the <see cref="T:System.Collections.Generic.ISet`1"/> or any nested
            collections when comparing or making strings to represent them.
            No other behavior is changed - only these 3 methods.
            <para/>
            Note that if the set is already an <see cref="T:Lucene.Net.Support.EquatableSet`1"/> or a subclass
            of it, this method simply returns the provided <paramref name="set"/>.
            </summary>
            <typeparam name="T">the type of element</typeparam>
            <param name="set">Any <see cref="T:System.Collections.Generic.IList`1"/> (including <see cref="T:T[]"/>)</param>
            <returns>An <see cref="T:Lucene.Net.Support.EquatableSet`1"/> that wraps the provided <paramref name="set"/>, 
            or the value of <paramref name="set"/> unmodified if it already is an <see cref="T:Lucene.Net.Support.EquatableSet`1"/></returns>
        </member>
        <member name="T:Lucene.Net.Support.EquatableList`1">
            <summary>
            Represents a strongly typed list of objects that can be accessed by index.
            Provides methods to manipulate lists. Also provides functionality
            to compare lists against each other through an implementations of
            <see cref="T:System.IEquatable`1"/>, or to wrap an existing list to use
            the same comparison logic as this one while not affecting any of its
            other functionality.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.#ctor">
            <summary>Initializes a new instance of the
            <see cref="T:Lucene.Net.Support.EquatableList`1"/> class that is empty and has the
            default initial capacity.</summary>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.#ctor(System.Collections.Generic.IList{`0},System.Boolean)">
            <summary>
            Initializes a new instance of <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            <para/>
            If the <paramref name="wrap"/> parameter is <c>true</c>, the
            <paramref name="collection"/> is used as is without doing
            a copy operation. Otherwise, the collection is copied 
            (which is the same operation as the 
            <see cref="M:Lucene.Net.Support.EquatableList`1.#ctor(System.Collections.Generic.IEnumerable{`0})"/> overload). 
            <para/>
            The internal <paramref name="collection"/> is used for
            all operations except for <see cref="!:Equals()"/>, <see cref="M:Lucene.Net.Support.EquatableList`1.GetHashCode"/>,
            and <see cref="M:Lucene.Net.Support.EquatableList`1.ToString"/>, which are all based on deep analysis
            of this collection and any nested collections.
            </summary>
            <param name="collection">The collection that will either be wrapped or copied 
            depending on the value of <paramref name="wrap"/>.</param>
            <param name="wrap"><c>true</c> to wrap an existing <see cref="T:System.Collections.Generic.IList`1"/> without copying,
            or <c>false</c> to copy the collection into a new <see cref="T:System.Collections.Generic.List`1"/>.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.EquatableList`1.#ctor(System.Collections.Generic.IEnumerable{`0})" -->
        <member name="M:Lucene.Net.Support.EquatableList`1.#ctor(System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Lucene.Net.Support.EquatableList`1"/>
            class that is empty and has the specified initial capacity.</summary>
            <param name="capacity">The number of elements that the new list can initially store.</param>
        </member>
        <member name="P:Lucene.Net.Support.EquatableList`1.Item(System.Int32)">
            <summary>
            Gets or sets the element at the specified index.
            </summary>
            <param name="index">The zero-based index of the element to get or set.</param>
        </member>
        <member name="P:Lucene.Net.Support.EquatableList`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.EquatableList`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:Lucene.Net.Support.EquatableList`1"/> is read-only.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Add(`0)">
            <summary>
            Adds an object to the end of the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            </summary>
            <param name="item">The object to be added to the end of the <see cref="T:Lucene.Net.Support.EquatableList`1"/>. The value can be <c>null</c> for reference types.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Clear">
            <summary>
            Removes all items from the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:Lucene.Net.Support.EquatableList`1"/> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</param>
            <returns><c>true</c> if the Object is found in the <see cref="T:Lucene.Net.Support.EquatableList`1"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the entire <see cref="T:Lucene.Net.Support.EquatableList`1"/> to a compatible one-dimensional array, 
            starting at the specified index of the target array.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the 
            destination of the elements copied from <see cref="T:Lucene.Net.Support.EquatableList`1"/>. 
            The Array must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1"/> for the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.IndexOf(`0)">
            <summary>
            Determines the index of a specific <paramref name="item"/> in the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            </summary>
            <param name="item">The object to locate in the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</param>
            <returns>The index of <paramref name="item"/> if found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Insert(System.Int32,`0)">
            <summary>
            Inserts an item to the <see cref="T:Lucene.Net.Support.EquatableList`1"/> at the specified index.
            </summary>
            <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
            <param name="item">The object to insert into the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</param>
            <returns><c>true</c> if <paramref name="item"/> was successfully removed from the 
            <see cref="T:Lucene.Net.Support.EquatableList`1"/>; otherwise, <c>false</c>. This method also returns 
            <c>false</c> if item is not found in the original <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.RemoveAt(System.Int32)">
            <summary>
            Removes the <see cref="T:Lucene.Net.Support.EquatableList`1"/> item at the specified index.
            </summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.
            </summary>
            <returns>An <see cref="T:System.Collections.IEnumerator"/> for the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Equals(System.Collections.Generic.IList{`0})">
            <summary>
            Compares this sequence to another <see cref="T:System.Collections.Generic.IList`1"/>
            implementation, returning <c>true</c> if they are equal, <c>false</c> otherwise.
            <para/>
            The comparison takes into consideration any values in this collection and values
            of any nested collections, but does not take into consideration the data type.
            Therefore, <see cref="T:Lucene.Net.Support.EquatableList`1"/> can equal any <see cref="T:System.Collections.Generic.IList`1"/>
            with the exact same values in the same order.
            </summary>
            <param name="other">The other <see cref="T:System.Collections.Generic.IList`1"/> implementation
            to compare against.</param>
            <returns><c>true</c> if the sequence in <paramref name="other"/>
            is the same as this one.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Clone">
            <summary>Clones the <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</summary>
            <remarks>This is a shallow clone.</remarks>
            <returns>A new shallow clone of this
            <see cref="T:Lucene.Net.Support.EquatableList`1"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.Equals(System.Object)">
            <summary>
            If the object passed implements <see cref="T:System.Collections.Generic.IList`1"/>,
            compares this sequence to <paramref name="other"/>, returning <c>true</c> if they 
            are equal, <c>false</c> otherwise.
            <para/>
            The comparison takes into consideration any values in this collection and values
            of any nested collections, but does not take into consideration the data type.
            Therefore, <see cref="T:Lucene.Net.Support.EquatableList`1"/> can equal any <see cref="T:System.Collections.Generic.IList`1"/>
            with the exact same values in the same order.
            </summary>
            <param name="obj">The other object
            to compare against.</param>
            <returns><c>true</c> if the sequence in <paramref name="other"/>
            is the same as this one.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.GetHashCode">
            <summary>
            Returns the hash code value for this list.
            <para/>
            The hash code determination takes into consideration any values in
            this collection and values of any nested collections, but does not
            take into consideration the data type. Therefore, the hash codes will
            be exactly the same for this <see cref="T:Lucene.Net.Support.EquatableList`1"/> and another
            <see cref="T:System.Collections.Generic.IList`1"/> (including arrays) with the same values in the
            same order.
            </summary>
            <returns>the hash code value for this list</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableList`1.ToString">
            <summary>
            Returns a string representation of this collection (and any nested collections). 
            The string representation consists of a list of the collection's elements in 
            the order they are returned by its enumerator, enclosed in square brackets 
            ("[]"). Adjacent elements are separated by the characters ", " (comma and space).
            </summary>
            <returns>a string representation of this collection</returns>
        </member>
        <member name="T:Lucene.Net.Support.EquatableSet`1">
            <summary>
            Represents a strongly typed set of objects.
            Provides methods to manipulate the set. Also provides functionality
            to compare sets against each other through an implementations of
            <see cref="T:System.IEquatable`1"/>, or to wrap an existing set to use
            the same comparison logic as this one while not affecting any of its
            other functionality.
            </summary>
            <typeparam name="T">The type of elements in the list.</typeparam>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.#ctor">
            <summary>Initializes a new instance of the
            <see cref="T:Lucene.Net.Support.EquatableSet`1"/> class that is empty and has the
            default initial capacity.</summary>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.#ctor(System.Collections.Generic.ISet{`0},System.Boolean)">
            <summary>
            Initializes a new instance of <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.
            <para/>
            If the <paramref name="wrap"/> parameter is <c>true</c>, the
            <paramref name="collection"/> is used as is without doing
            a copy operation. Otherwise, the collection is copied 
            (which is the same operation as the 
            <see cref="M:Lucene.Net.Support.EquatableSet`1.#ctor(System.Collections.Generic.ICollection{`0})"/> overload). 
            <para/>
            The internal <paramref name="collection"/> is used for
            all operations except for <see cref="!:Equals()"/>, <see cref="M:Lucene.Net.Support.EquatableSet`1.GetHashCode"/>,
            and <see cref="M:Lucene.Net.Support.EquatableSet`1.ToString"/>, which are all based on deep analysis
            of this collection and any nested collections.
            </summary>
            <param name="collection">The collection that will either be wrapped or copied 
            depending on the value of <paramref name="wrap"/>.</param>
            <param name="wrap"><c>true</c> to wrap an existing <see cref="T:System.Collections.Generic.ISet`1"/> without copying,
            or <c>false</c> to copy the collection into a new <see cref="T:System.Collections.Generic.HashSet`1"/>.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.EquatableSet`1.#ctor(System.Collections.Generic.ICollection{`0})" -->
        <member name="M:Lucene.Net.Support.EquatableSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lucene.Net.Support.EquatableSet`1"/> class that is 
            empty and uses the specified equality comparer for the set type.
            </summary>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation 
            to use when comparing values in the set, or null to use the default 
            <see cref="T:System.Collections.Generic.EqualityComparer`1"/> implementation for the set type.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Initializes a new instance of the <see cref="T:Lucene.Net.Support.EquatableSet`1"/> class that uses the 
            specified equality comparer for the set type, contains elements 
            copied from the specified collection, and has sufficient capacity 
            to accommodate the number of elements copied.
            </summary>
            <param name="collection">The collection whose elements are copied to the new set.</param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IEqualityComparer`1"/> implementation to use 
            when comparing values in the set, or <c>null</c> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1"/>
            implementation for the set type.</param>
        </member>
        <member name="P:Lucene.Net.Support.EquatableSet`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.EquatableSet`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:Lucene.Net.Support.EquatableSet`1"/> is read-only.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Add(`0)">
            <summary>
            Adds an element to the current set and returns a value to indicate if the element was successfully added.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns><c>true</c> if the element is added to the set; <c>false</c> if the element is already in the set.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Clear">
            <summary>
            Removes all items from the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:Lucene.Net.Support.EquatableSet`1"/> contains a specific value.
            </summary>
            <param name="item">The object to locate in the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.</param>
            <returns><c>true</c> if item is found in the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:Lucene.Net.Support.EquatableSet`1"/> to an <see cref="T:System.Array"/>, 
            starting at a particular <see cref="T:System.Array"/> index.
            </summary>
            <param name="array">The one-dimensional <see cref="T:System.Array"/> that is the destination of the elements 
            copied from <see cref="T:Lucene.Net.Support.EquatableSet`1"/>. The <see cref="T:System.Array"/> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Removes all elements in the specified collection from the current set.
            </summary>
            <param name="other">The collection of items to remove from the set.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>An enumerator that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are also in a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set is a proper (strict) subset of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><c>true</c> if the current set is a proper subset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set is a proper (strict) superset of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><c>true</c> if the current set is a proper superset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a set is a subset of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><c>true</c> if the current set is a subset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set is a superset of a specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><c>true</c> if the current set is a superset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set overlaps with the specified collection.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><c>true</c> if the current set and other share at least one common element; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.
            </summary>
            <param name="item">The object to remove from the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.</param>
            <returns><c>true</c> if item was successfully removed from the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>; otherwise, <c>false</c>. 
            This method also returns <c>false</c> if item is not found in the original <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current set and the specified collection contain the same elements.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><c>true</c> if the current set is equal to other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are present either in the 
            current set or in the specified collection, but not both.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains all elements that are present in the 
            current set, in the specified collection, or in both.
            </summary>
            <param name="other">The collection to compare to the current set.</param>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Equals(System.Collections.Generic.ISet{`0})">
            <summary>
            Compares this sequence to <paramref name="other"/>, returning <c>true</c> if they 
            are equal, <c>false</c> otherwise.
            <para/>
            The comparison takes into consideration any values in this collection and values
            of any nested collections, but does not take into consideration the data type.
            Therefore, <see cref="T:Lucene.Net.Support.EquatableSet`1"/> can equal any <see cref="T:System.Collections.Generic.ISet`1"/>
            with the exact same values (in any order).
            </summary>
            <param name="obj">The other object
            to compare against.</param>
            <returns><c>true</c> if the sequence in <paramref name="other"/>
            is the same as this one.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Clone">
            <summary>Clones the <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.</summary>
            <remarks>This is a shallow clone.</remarks>
            <returns>A new shallow clone of this
            <see cref="T:Lucene.Net.Support.EquatableSet`1"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.Equals(System.Object)">
            <summary>
            If the object passed implements <see cref="T:System.Collections.Generic.IList`1"/>,
            compares this sequence to <paramref name="other"/>, returning <c>true</c> if they 
            are equal, <c>false</c> otherwise.
            <para/>
            The comparison takes into consideration any values in this collection and values
            of any nested collections, but does not take into consideration the data type.
            Therefore, <see cref="T:Lucene.Net.Support.EquatableSet`1"/> can equal any <see cref="T:System.Collections.Generic.ISet`1"/>
            with the exact same values (in any order).
            </summary>
            <param name="obj">The other object
            to compare against.</param>
            <returns><c>true</c> if the sequence in <paramref name="other"/>
            is the same as this one.</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.GetHashCode">
            <summary>
            Returns the hash code value for this list.
            <para/>
            The hash code determination takes into consideration any values in
            this collection and values of any nested collections, but does not
            take into consideration the data type. Therefore, the hash codes will
            be exactly the same for this <see cref="T:Lucene.Net.Support.EquatableSet`1"/> and another
            <see cref="T:System.Collections.Generic.ISet`1"/> with the same values (in any order).
            </summary>
            <returns>the hash code value for this list</returns>
        </member>
        <member name="M:Lucene.Net.Support.EquatableSet`1.ToString">
            <summary>
            Returns a string representation of this collection (and any nested collections). 
            The string representation consists of a list of the collection's elements in 
            the order they are returned by its enumerator, enclosed in square brackets 
            ("[]"). Adjacent elements are separated by the characters ", " (comma and space).
            </summary>
            <returns>a string representation of this collection</returns>
        </member>
        <member name="T:Lucene.Net.Support.ExceptionExtensions">
            <summary>
            Extensions to the <see cref="T:System.Exception"/> class to allow for
            adding and retrieving suppressed exceptions, like you can do in Java.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ExceptionToClassNameConventionAttribute">
            <summary>
            Use this attribute to make an exception to the class naming rules (which should not be named like Interfaces).
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ExceptionToNetNumericConventionAttribute">
            <summary>
            Properties, methods, or events marked with this attribute can ignore
            the numeric naming conventions of "Int16", "Int32", "Int64", and "Single"
            that are commonly used in .NET method and property names.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ExceptionToNullableEnumConvention">
            <summary>
            Use this attribute to make an exception to the nullable enum rule.
            Some of these cannot be avoided.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.GeneralKeyedCollection`2">
            <summary>A collection of <typeparamref name="TItem"/> which can be
            looked up by instances of <typeparamref name="TKey"/>.</summary>
            <typeparam name="TItem">The type of the items contains in this
            collection.</typeparam>
            <typeparam name="TKey">The type of the keys that can be used to look
            up the items.</typeparam>
        </member>
        <member name="M:Lucene.Net.Support.GeneralKeyedCollection`2.#ctor(System.Func{`1,`0})">
            <summary>Creates a new instance of the
            <see cref="T:Lucene.Net.Support.GeneralKeyedCollection`2"/> class.</summary>
            <param name="converter">The <see cref="T:System.Converter`2"/> which will convert
            instances of <typeparamref name="TItem"/> to <typeparamref name="TKey"/>
            when the override of <see cref="M:Lucene.Net.Support.GeneralKeyedCollection`2.GetKeyForItem(`1)"/> is called.</param>
        </member>
        <member name="F:Lucene.Net.Support.GeneralKeyedCollection`2.converter">
            <summary>The <see cref="T:System.Converter`2"/> which will convert
            instances of <typeparamref name="TItem"/> to <typeparamref name="TKey"/>
            when the override of <see cref="M:Lucene.Net.Support.GeneralKeyedCollection`2.GetKeyForItem(`1)"/> is called.</summary>
        </member>
        <member name="M:Lucene.Net.Support.GeneralKeyedCollection`2.GetKeyForItem(`1)">
            <summary>Converts an item that is added to the collection to
            a key.</summary>
            <param name="item">The instance of <typeparamref name="TItem"/>
            to convert into an instance of <typeparamref name="TKey"/>.</param>
            <returns>The instance of <typeparamref name="TKey"/> which is the
            key for this item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.GeneralKeyedCollection`2.ContainsKey(`0)">
            <summary>Determines if a key for an item exists in this
            collection.</summary>
            <param name="key">The instance of <typeparamref name="TKey"/>
            to see if it exists in this collection.</param>
            <returns>True if the key exists in the collection, false otherwise.</returns>
        </member>
        <member name="T:Lucene.Net.Support.HashMap`2">
            <summary>
            A C# emulation of the <a href="http://download.oracle.com/javase/1,5.0/docs/api/java/util/HashMap.html">Java Hashmap</a>
            <para>
            A <see cref="T:System.Collections.Generic.Dictionary`2" /> is a close equivalent to the Java
            Hashmap.  One difference java implementation of the class is that
            the Hashmap supports both null keys and values, where the C# Dictionary
            only supports null values not keys.  Also, <c>V Get(TKey)</c>
            method in Java returns null if the key doesn't exist, instead of throwing
            an exception.  This implementation doesn't throw an exception when a key
            doesn't exist, it will return null.  This class is slower than using a
            <see cref="T:System.Collections.Generic.Dictionary`2"/>, because of extra checks that have to be
            done on each access, to check for null.
            </para>
            <para>
            <b>NOTE:</b> This class works best with nullable types.  default(T) is returned
            when a key doesn't exist in the collection (this being similar to how Java returns
            null).  Therefore, if the expected behavior of the java code is to execute code
            based on if the key exists, when the key is an integer type, it will return 0 instead of null.
            </para>
            <remaks>
            Consider also implementing IDictionary, IEnumerable, and ICollection
            like <see cref="T:System.Collections.Generic.Dictionary`2" /> does, so HashMap can be
            used in substituted in place for the same interfaces it implements.
            </remaks>
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary</typeparam>
            <typeparam name="TValue">The type of values in the dictionary</typeparam>
            <remarks>
            <h2>Unordered Dictionaries</h2>
            <list type="bullet">
                <item><see cref="T:System.Collections.Generic.Dictionary`2"/> - use when order is not important and all keys are non-null.</item>
                <item><see cref="T:Lucene.Net.Support.HashMap`2"/> - use when order is not important and support for a null key is required.</item>
            </list>
            <h2>Ordered Dictionaries</h2>
            <list type="bullet">
                <item><see cref="T:Lucene.Net.Support.LinkedHashMap`2"/> - use when you need to preserve entry insertion order. Keys are nullable.</item>
                <item><see cref="T:System.Collections.Generic.SortedDictionary`2"/> - use when you need natural sort order. Keys must be unique.</item>
                <item><see cref="T:Lucene.Net.Support.TreeDictionary`2"/> - use when you need natural sort order. Keys may contain duplicates.</item>
                <item><see cref="T:Lucene.Net.Support.LurchTable`2"/> - use when you need to sort by most recent access or most recent update. Works well for LRU caching.</item>
            </list>
            </remarks>
        </member>
        <member name="T:Lucene.Net.Support.HashMap`2.NullValueCollection">
            <summary>
            Wraps a dictionary and adds the value
            represented by the null key
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.HashMap`2.NullKeyCollection">
            <summary>
            Wraps a dictionary's collection, adding in a
            null key.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ICharSequence">
            <summary>
            This interface represents an ordered set of characters and defines the
            methods to probe them.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ICharSequence.Length">
            <summary>
            Returns the number of characters in this sequence.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.ICharSequence.Item(System.Int32)">
            <summary>
            Returns the character at the specified index, with the first character
            having index zero.
            </summary>
            <param name="index">the index of the character to return.</param>
            <returns>the requested character.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if <c>index &lt; 0</c> or <c>index</c> is greater than the
            length of this sequence.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.ICharSequence.SubSequence(System.Int32,System.Int32)">
            <summary>
            Returns a <see cref="T:Lucene.Net.Support.ICharSequence"/> from the <paramref name="start"/> index (inclusive)
            to the <paramref name="end"/> index (exclusive) of this sequence.
            </summary>
            <param name="start">
            the start offset of the sub-sequence. It is inclusive, that
            is, the index of the first character that is included in the
            sub-sequence.
            </param>
            <param name="end">
            the end offset of the sub-sequence. It is exclusive, that is,
            the index of the first character after those that are included
            in the sub-sequence
            </param>
            <returns>the requested sub-sequence.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if <c>start &lt; 0</c>, <c>end &lt; 0</c>, <c>start &gt; end</c>,
            or if <paramref name="start"/> or <paramref name="end"/> are greater than the
            length of this sequence.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.ICharSequence.ToString">
            <summary>
            Returns a string with the same characters in the same order as in this
            sequence.
            </summary>
            <returns>a string based on this sequence.</returns>
        </member>
        <member name="T:Lucene.Net.Support.IChecksum">
            <summary>
            Contains conversion support elements such as classes, interfaces and static methods.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IndexWriterConfigExtensions">
            <summary>
            Extension methods that can be used to provide similar
            <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> syntax as Java Lucene.
            (config.SetCheckIntegrityAtMerge(100).SetMaxBufferedDocs(1000);)
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetTermIndexInterval(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="interval"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMaxBufferedDeleteTerms(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="maxBufferedDeleteTerms"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetRAMBufferSizeMB(Lucene.Net.Index.LiveIndexWriterConfig,System.Double)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="ramBufferSizeMB"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMaxBufferedDocs(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="maxBufferedDocs"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMergedSegmentWarmer(Lucene.Net.Index.LiveIndexWriterConfig,Lucene.Net.Index.IndexWriter.IndexReaderWarmer)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="mergeSegmentWarmer"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetReaderTermsIndexDivisor(Lucene.Net.Index.LiveIndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="!:LiveLiveIndexWriterConfig.ReaderTermsIndexDivisor"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="divisor"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetUseCompoundFile(Lucene.Net.Index.LiveIndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.UseCompoundFile"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="useCompoundFile"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetCheckIntegrityAtMerge(Lucene.Net.Index.LiveIndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.CheckIntegrityAtMerge"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</param>
            <param name="checkIntegrityAtMerge"></param>
            <returns>this <see cref="T:Lucene.Net.Index.LiveIndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetTermIndexInterval(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.TermIndexInterval"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="interval"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMaxBufferedDeleteTerms(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDeleteTerms"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="maxBufferedDeleteTerms"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetRAMBufferSizeMB(Lucene.Net.Index.IndexWriterConfig,System.Double)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.RAMBufferSizeMB"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="ramBufferSizeMB"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMaxBufferedDocs(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MaxBufferedDocs"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="maxBufferedDocs"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMergedSegmentWarmer(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IndexWriter.IndexReaderWarmer)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.MergedSegmentWarmer"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="mergeSegmentWarmer"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetReaderTermsIndexDivisor(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.ReaderTermsIndexDivisor"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="divisor"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetUseCompoundFile(Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.UseCompoundFile"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="useCompoundFile"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetCheckIntegrityAtMerge(Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.LiveIndexWriterConfig.CheckIntegrityAtMerge"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="checkIntegrityAtMerge"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetDefaultWriteLockTimeout(Lucene.Net.Index.IndexWriterConfig,System.Int64)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.DefaultWriteLockTimeout"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="writeLockTimeout"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetOpenMode(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.OpenMode)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.OpenMode"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="openMode"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetIndexDeletionPolicy(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IndexDeletionPolicy)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexDeletionPolicy"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="deletionPolicy"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetIndexCommit(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IndexCommit)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexCommit"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="commit"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetSimilarity(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Search.Similarities.Similarity)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.Similarity"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="similarity"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMergeScheduler(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.IMergeScheduler)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.MergeScheduler"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="mergeScheduler"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetWriteLockTimeout(Lucene.Net.Index.IndexWriterConfig,System.Int64)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.WriteLockTimeout"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="writeLockTimeout"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMergePolicy(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.MergePolicy)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.MergePolicy"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="mergePolicy"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetCodec(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Codecs.Codec)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.Codec"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="codec"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetIndexerThreadPool(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.DocumentsWriterPerThreadPool)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexerThreadPool"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="threadPool"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetMaxThreadStates(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.MaxThreadStates"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="maxThreadStates"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetReaderPooling(Lucene.Net.Index.IndexWriterConfig,System.Boolean)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.UseReaderPooling"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="readerPooling"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetIndexingChain(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.DocumentsWriterPerThread.IndexingChain)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.IndexingChain"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="indexingChain"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetFlushPolicy(Lucene.Net.Index.IndexWriterConfig,Lucene.Net.Index.FlushPolicy)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.FlushPolicy"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="flushPolicy"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="M:Lucene.Net.Support.IndexWriterConfigExtensions.SetRAMPerThreadHardLimitMB(Lucene.Net.Index.IndexWriterConfig,System.Int32)">
            <summary>
            Builder method for <see cref="P:Lucene.Net.Index.IndexWriterConfig.RAMPerThreadHardLimitMB"/>.
            </summary>
            <param name="config">this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</param>
            <param name="perThreadHardLimitMB"></param>
            <returns>this <see cref="T:Lucene.Net.Index.IndexWriterConfig"/> instance</returns>
        </member>
        <member name="T:Lucene.Net.Support.IResourceManagerFactory">
            <summary>
            LUCENENET specific interface used to inject instances of
            <see cref="T:System.Resources.ResourceManager"/>. This
            extension point can be used to override the default behavior
            to, for example, retrieve resources from a persistent data store,
            rather than getting them from resource files.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.LinkedHashMap`2">
            <summary>
            LinkedHashMap is a specialized dictionary that preserves the entry order of elements.
            Like a HashMap, there can be a <c>null</c> key, but it also guarantees that the enumeration
            order of the elements are the same as insertion order, regardless of the number of add/remove/update
            operations that are performed on it.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary</typeparam>
            <typeparam name="TValue">The type of values in the dictionary</typeparam>
            <remarks>
            <h2>Unordered Dictionaries</h2>
            <list type="bullet">
                <item><see cref="T:System.Collections.Generic.Dictionary`2"/> - use when order is not important and all keys are non-null.</item>
                <item><see cref="T:Lucene.Net.Support.HashMap`2"/> - use when order is not important and support for a null key is required.</item>
            </list>
            <h2>Ordered Dictionaries</h2>
            <list type="bullet">
                <item><see cref="T:Lucene.Net.Support.LinkedHashMap`2"/> - use when you need to preserve entry insertion order. Keys are nullable.</item>
                <item><see cref="T:System.Collections.Generic.SortedDictionary`2"/> - use when you need natural sort order. Keys must be unique.</item>
                <item><see cref="T:Lucene.Net.Support.TreeDictionary`2"/> - use when you need natural sort order. Keys may contain duplicates.</item>
                <item><see cref="T:Lucene.Net.Support.LurchTable`2"/> - use when you need to sort by most recent access or most recent update. Works well for LRU caching.</item>
            </list>
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.ListExtensions.Sort``1(System.Collections.Generic.IList{``0})">
            <summary>
            If the underlying type is <see cref="T:System.Collections.Generic.List`1"/>,
            calls <see cref="M:System.Collections.Generic.List`1.Sort"/>. If not, 
            uses <see cref="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0})"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="M:Lucene.Net.Support.ListExtensions.Sort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            If the underlying type is <see cref="T:System.Collections.Generic.List`1"/>,
            calls <see cref="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})"/>. If not, 
            uses <see cref="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparer">the comparer to use for the sort</param>
        </member>
        <member name="M:Lucene.Net.Support.ListExtensions.Sort``1(System.Collections.Generic.IList{``0},System.Comparison{``0})">
            <summary>
            If the underlying type is <see cref="T:System.Collections.Generic.List`1"/>,
            calls <see cref="M:System.Collections.Generic.List`1.Sort(System.Collections.Generic.IComparer{`0})"/>. If not, 
            uses <see cref="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparison">the comparison function to use for the sort</param>
        </member>
        <member name="M:Lucene.Net.Support.ListExtensions.TimSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="M:Lucene.Net.Support.ListExtensions.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.ListExtensions.IntroSort``1(System.Collections.Generic.IList{``0})" -->
        <member name="M:Lucene.Net.Support.ListExtensions.IntroSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. 
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comparer">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <member name="M:Lucene.Net.Support.SubList`1.#ctor(System.Collections.Generic.IList{`0},System.Int32,System.Int32)">
            <summary>
            Creates a ranged view of the given <paramref name="list"/>.
            </summary>
            <param name="list">The original list to view.</param>
            <param name="fromIndex">The inclusive starting index.</param>
            <param name="toIndex">The exclusive ending index.</param>
        </member>
        <member name="T:Lucene.Net.Support.LurchTableOrder">
            <summary>
            Defines if and how items added to a LurchTable are linked together, this defines
            the value returned from Peek/Dequeue as the oldest entry of the specified operation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.LurchTableOrder.None">
            <summary> No linking </summary>
        </member>
        <member name="F:Lucene.Net.Support.LurchTableOrder.Insertion">
            <summary> Linked in insertion order </summary>
        </member>
        <member name="F:Lucene.Net.Support.LurchTableOrder.Modified">
            <summary> Linked by most recently inserted or updated </summary>
        </member>
        <member name="F:Lucene.Net.Support.LurchTableOrder.Access">
            <summary> Linked by most recently inserted, updated, or fetched </summary>
        </member>
        <member name="T:Lucene.Net.Support.LurchTable`2">
            <summary>
            LurchTable stands for "Least Used Recently Concurrent Hash Table" and has definate
            similarities to both the .NET 4 ConcurrentDictionary as well as Java's LinkedHashMap.
            This gives you a thread-safe dictionary/hashtable that stores element ordering by
            insertion, updates, or access.  In addition it can be configured to use a 'hard-limit'
            count of items that will automatically 'pop' the oldest item in the collection.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
        </member>
        <member name="T:Lucene.Net.Support.LurchTable`2.ItemUpdatedMethod">
            <summary> Method signature for the ItemUpdated event </summary>
        </member>
        <member name="E:Lucene.Net.Support.LurchTable`2.ItemRemoved">
            <summary> Event raised after an item is removed from the collection </summary>
        </member>
        <member name="E:Lucene.Net.Support.LurchTable`2.ItemUpdated">
            <summary> Event raised after an item is updated in the collection </summary>
        </member>
        <member name="E:Lucene.Net.Support.LurchTable`2.ItemAdded">
            <summary> Event raised after an item is added to the collection </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.#ctor(System.Int32)">
            <summary>Creates a LurchTable that can store up to (capacity) items efficiently.</summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.#ctor(System.Int32,Lucene.Net.Support.LurchTableOrder)">
            <summary>Creates a LurchTable that can store up to (capacity) items efficiently.</summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.#ctor(System.Int32,Lucene.Net.Support.LurchTableOrder,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Creates a LurchTable that can store up to (capacity) items efficiently.</summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.#ctor(Lucene.Net.Support.LurchTableOrder,System.Int32)">
            <summary>Creates a LurchTable that orders items by (ordering) and removes items once the specified (limit) is reached.</summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.#ctor(Lucene.Net.Support.LurchTableOrder,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Creates a LurchTable that orders items by (ordering) and removes items once the specified (limit) is reached.</summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.#ctor(Lucene.Net.Support.LurchTableOrder,System.Int32,System.Int32,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Creates a LurchTable that orders items by (ordering) and removes items once the specified (limit) is reached.
            </summary>
            <param name="ordering">The type of linking for the items</param>
            <param name="limit">The maximum allowable number of items, or int.MaxValue for unlimited</param>
            <param name="hashSize">The number of hash buckets to use for the collection, usually 1/2 estimated capacity</param>
            <param name="allocSize">The number of entries to allocate at a time, usually 1/16 estimated capacity</param>
            <param name="lockSize">The number of concurrency locks to preallocate, usually 1/256 estimated capacity</param>
            <param name="comparer">The element hash generator for keys</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Dispose">
            <summary>
            Clears references to all objects and invalidates the collection
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Ordering">
            <summary>
            Retrieves the LurchTableOrder Ordering enumeration this instance was created with.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Comparer">
            <summary>
            Retrives the key comparer being used by this instance.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Limit">
            <summary>
            Gets or Sets the record limit allowed in this instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Initialize">
            <summary>
            WARNING: not thread-safe, reinitializes all internal structures.  Use Clear() for a thread-safe
            delete all.  If you have externally provided exclusive access this method may be used to more
            efficiently clear the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryGetValue(`0,`1@)">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <returns>
            true if the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"/> contains an element with the specified key; otherwise, false.
            </returns>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">The key of the element to remove.</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.GetOrAdd(`0,`1)">
            <summary>
            Adds a key/value pair to the  <see cref="T:System.Collections.Generic.IDictionary`2"/> if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="value">The value to be added, if the key does not already exist.</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryAdd(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryUpdate(`0,`1)">
            <summary>
            Updates an element with the provided key to the value if it exists.
            </summary>
            <returns>Returns true if the key provided was found and updated to the value.</returns>
            <param name="key">The object to use as the key of the element to update.</param>
            <param name="value">The new value for the key if found.</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryUpdate(`0,`1,`1)">
            <summary>
            Updates an element with the provided key to the value if it exists.
            </summary>
            <returns>Returns true if the key provided was found and updated to the value.</returns>
            <param name="key">The object to use as the key of the element to update.</param>
            <param name="value">The new value for the key if found.</param>
            <param name="comparisonValue">The value that is compared to the value of the element with key.</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryRemove(`0,`1@)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if <paramref name="key"/> was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </returns>
            <param name="key">The key of the element to remove.</param>
            <param name="value">The value that was removed.</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.GetOrAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds a key/value pair to the  <see cref="T:System.Collections.Generic.IDictionary`2"/> if the key does not already exist.
            </summary>
            <param name="key">The key of the element to add.</param>
            <param name="fnCreate">Constructs a new value for the key.</param>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.AddOrUpdate(`0,`1,Lucene.Net.Support.KeyValueUpdate{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Generic.IDictionary`2"/> if the key does not already exist, 
            or updates a key/value pair if the key already exists.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.AddOrUpdate(`0,System.Func{`0,`1},Lucene.Net.Support.KeyValueUpdate{`0,`1})">
            <summary>
            Adds a key/value pair to the <see cref="T:System.Collections.Generic.IDictionary`2"/> if the key does not already exist, 
            or updates a key/value pair if the key already exists.
            </summary>
            <remarks>
            Adds or modifies an element with the provided key and value.  If the key does not exist in the collection,
            the factory method fnCreate will be called to produce the new value, if the key exists, the converter method
            fnUpdate will be called to create an updated value.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.AddOrUpdate``1(`0,``0@)">
            <summary>
            Add, update, or fetche a key/value pair from the dictionary via an implementation of the
            <see cref="T:CSharpTest.Net.Collections.ICreateOrUpdateValue`2"/> interface.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryAdd(`0,System.Func{`0,`1})">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>
            by calling the provided factory method to construct the value if the key is not already present in the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryUpdate(`0,Lucene.Net.Support.KeyValueUpdate{`0,`1})">
            <summary>
            Modify the value associated with the result of the provided update method
            as an atomic operation, Allows for reading/writing a single record within
            the syncronization lock.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryRemove(`0,Lucene.Net.Support.KeyValuePredicate{`0,`1})">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"/>
            if the fnCondition predicate is null or returns true.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryRemove``1(`0,``0@)">
            <summary>
            Conditionally removes a key/value pair from the dictionary via an implementation of the
            <see cref="T:CSharpTest.Net.Collections.IRemoveValue`2"/> interface.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.LurchTable`2.Enumerator">
            <summary>
            Provides an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.LurchTable`2.KeyCollection">
            <summary>
            Provides the collection of Keys for the LurchTable
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.KeyCollection.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.KeyCollection.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.KeyCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.KeyCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.LurchTable`2.KeyCollection.Enumerator">
            <summary>
            Provides an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.KeyCollection.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.KeyCollection.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.KeyCollection.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.KeyCollection.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.LurchTable`2.ValueCollection">
            <summary>
            Provides the collection of Values for the LurchTable
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.ValueCollection.Contains(`1)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"/> contains a specific value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.ValueCollection.CopyTo(`1[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"/> to an <see cref="T:System.Array"/>, starting at a particular <see cref="T:System.Array"/> index.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.ValueCollection.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.ValueCollection.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.LurchTable`2.ValueCollection.Enumerator">
            <summary>
            Provides an enumerator that iterates through the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.ValueCollection.Enumerator.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.ValueCollection.Enumerator.Current">
            <summary>
            Gets the element in the collection at the current position of the enumerator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.ValueCollection.Enumerator.MoveNext">
            <summary>
            Advances the enumerator to the next element of the collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.ValueCollection.Enumerator.Reset">
            <summary>
            Sets the enumerator to its initial position, which is before the first element in the collection.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.LurchTable`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"/> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Peek(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Retrieves the oldest entry in the collection based on the ordering supplied to the constructor.
            </summary>
            <returns>True if the out parameter value was set.</returns>
            <exception cref="T:System.InvalidOperationException">Raised if the table is unordered</exception>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.Dequeue">
            <summary>
            Removes the oldest entry in the collection based on the ordering supplied to the constructor.
            If an item is not available a busy-wait loop is used to wait for for an item.
            </summary>
            <returns>The Key/Value pair removed.</returns>
            <exception cref="T:System.InvalidOperationException">Raised if the table is unordered</exception>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryDequeue(System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Removes the oldest entry in the collection based on the ordering supplied to the constructor.
            </summary>
            <returns>False if no item was available</returns>
            <exception cref="T:System.InvalidOperationException">Raised if the table is unordered</exception>
        </member>
        <member name="M:Lucene.Net.Support.LurchTable`2.TryDequeue(System.Predicate{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.KeyValuePair{`0,`1}@)">
            <summary>
            Removes the oldest entry in the collection based on the ordering supplied to the constructor.
            </summary>
            <returns>False if no item was available</returns>
            <exception cref="T:System.InvalidOperationException">Raised if the table is unordered</exception>
        </member>
        <member name="T:Lucene.Net.Support.LurchTableCorruptionException">
            <summary>
            Exception class: LurchTableCorruptionException
            The LurchTable internal datastructure appears to be corrupted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTableCorruptionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Serialization constructor
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTableCorruptionException.Create(System.Int32,System.String)">
            <summary>
            Used to create this exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTableCorruptionException.#ctor(System.Exception,System.Int32,System.String)">
            <summary>
            Constructs the exception from an hresult and message bypassing the message formatting
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTableCorruptionException.#ctor">
            <summary>
            The LurchTable internal datastructure appears to be corrupted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTableCorruptionException.#ctor(System.Exception)">
            <summary>
            The LurchTable internal datastructure appears to be corrupted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.LurchTableCorruptionException.Assert(System.Boolean)">
            <summary>
            if(condition == false) throws The LurchTable internal datastructure appears to be corrupted.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.KeyValueUpdate`2">
            <summary> Provides a delegate that performs an atomic update of a key/value pair </summary>
        </member>
        <member name="T:Lucene.Net.Support.KeyValuePredicate`2">
            <summary> Provides a delegate that performs a test on key/value pair </summary>
        </member>
        <member name="T:Lucene.Net.Support.ICreateValue`2">
            <summary>
            An interface to provide conditional or custom creation logic to a concurrent dictionary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.ICreateValue`2.CreateValue(`0,`1@)">
            <summary>
            Called when the key was not found within the dictionary to produce a new value that can be added.
            Return true to continue with the insertion, or false to prevent the key/value from being inserted.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IUpdateValue`2">
            <summary>
            An interface to provide conditional or custom update logic to a concurrent dictionary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IUpdateValue`2.UpdateValue(`0,`1@)">
            <summary>
            Called when the key was found within the dictionary to produce a modified value to update the item
            to. Return true to continue with the update, or false to prevent the key/value from being updated.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.ICreateOrUpdateValue`2">
            <summary>
            An interface to provide conditional or custom creation or update logic to a concurrent dictionary.
            </summary>
            <remarks>
            Generally implemented as a struct and passed by ref to save stack space and to retrieve the values
            that where inserted or updated.
            </remarks>
        </member>
        <member name="T:Lucene.Net.Support.IRemoveValue`2">
            <summary>
            An interface to provide conditional removal of an item from a concurrent dictionary.
            </summary>
            <remarks>
            Generally implemented as a struct and passed by ref to save stack space and to retrieve the values
            that where inserted or updated.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.IRemoveValue`2.RemoveValue(`0,`1)">
            <summary>
            Called when the dictionary is about to remove the key/value pair provided, return true to allow
            it's removal, or false to prevent it from being removed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.MathExtension.ToRadians(System.Double)">
            <summary>
            Convert to Radians.
            </summary>
            <param name="val">The value to convert to radians</param>
            <returns>The value in radians</returns>
        </member>
        <member name="T:Lucene.Net.Support.Number">
            <summary>
            A simple class for number conversions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Number.MIN_RADIX">
            <summary>
            Min radix value.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Number.MAX_RADIX">
            <summary>
            Max radix value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToString(System.Int64)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="number"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToString(System.Single)">
            <summary>
            Converts a number to System.String.
            </summary>
            <param name="f"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToString(System.Int64,System.Int32)">
            <summary>
            Converts a number to System.String in the specified radix.
            </summary>
            <param name="i">A number to be converted.</param>
            <param name="radix">A radix.</param>
            <returns>A System.String representation of the number in the specified redix.</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.Parse(System.String,System.Int32)">
            <summary>
            Parses a number in the specified radix.
            </summary>
            <param name="s">An input System.String.</param>
            <param name="radix">A radix.</param>
            <returns>The parsed number in the specified radix.</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.URShift(System.Int32,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.URShift(System.Int64,System.Int32)">
            <summary>
            Performs an unsigned bitwise right shift with the specified number
            </summary>
            <param name="number">Number to operate on</param>
            <param name="bits">Ammount of bits to shift</param>
            <returns>The resulting number from the shift operation</returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.ToInt64(System.String)">
            <summary>
            Converts a System.String number to long.
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.Number.Int32BitsToSingle(System.Int32)">
            <summary>
            NOTE: This was intBitsToFloat() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.SingleToRawInt32Bits(System.Single)">
            <summary>
            NOTE: This was floatToRawIntBits() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.SingleToInt32Bits(System.Single)">
            <summary>
            NOTE: This was floatToIntBits() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.SingleToInt64Bits(System.Single)">
            <summary>
            NOTE: This was floatToLongBits() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.DoubleToRawInt64Bits(System.Double)">
            <summary>
            NOTE: This was doubleToRawLongBits() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Number.DoubleToInt64Bits(System.Double)">
            <summary>
            NOTE: This was doubleToLongBits() in the JDK
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.OS">
            <summary>
            Provides platform infos.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.OS.IsUnix">
            <summary>
            Whether we run under a Unix platform.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.OS.IsWindows">
            <summary>
            Whether we run under a supported Windows platform.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.PriorityQueue`1">
            <summary>
            A <see cref="T:Lucene.Net.Support.PriorityQueue`1"/> holds elements on a priority heap, which orders the elements
            according to their natural order or according to the comparator specified at
            construction time. If the queue uses natural ordering, only elements that are
            comparable are permitted to be inserted into the queue.
            <para/>
            The least element of the specified ordering is stored at the head of the
            queue and the greatest element is stored at the tail of the queue.
            <para/>
            A <see cref="T:Lucene.Net.Support.PriorityQueue`1"/> is not synchronized.
            </summary>
            <typeparam name="T">Type of elements</typeparam>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor">
            <summary>
            Constructs a priority queue with an initial capacity of 11 and natural
            ordering.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor(System.Int32)">
            <summary>
            Constructs a priority queue with the specified capacity and natural
            ordering.
            </summary>
            <param name="initialCapacity">initial capacity</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if the <paramref name="initialCapacity"/> is less than 1.</exception>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor(System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates a <see cref="T:Lucene.Net.Support.PriorityQueue`1"/> with the specified initial capacity
            that orders its elements according to the specified comparer.
            </summary>
            <param name="initialCapacity">the initial capacity for this priority queue</param>
            <param name="comparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> that will be used to order this
            priority queue.  If <c>null</c>, the <see cref="T:System.IComparable`1"/>
            natural ordering of the elements will be used.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">if the <paramref name="initialCapacity"/> is less than 1</exception>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor(System.Collections.Generic.IComparer{`0})">
            <summary>
            Constructs a priority queue with the specified capacity and comparer.
            </summary>
            <param name="comparer">
            The <see cref="T:System.Collections.Generic.IComparer`1"/> that will be used to order this
            priority queue.  If <c>null</c>, the <see cref="T:System.IComparable`1"/>
            natural ordering of the elements will be used.
            </param>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor(System.Collections.Generic.ICollection{`0})">
            <summary>
            Creates a <see cref="T:Lucene.Net.Support.PriorityQueue`1"/> containing the elements in the
            specified collection.  If the specified collection is an instance of
            a <see cref="T:System.Collections.Generic.SortedSet`1"/>, <see cref="T:Lucene.Net.Support.TreeSet`1"/>,
            or is another <see cref="T:Lucene.Net.Support.PriorityQueue`1"/>, this
            priority queue will be ordered according to the same ordering.
            Otherwise, this priority queue will be ordered according to the
            <see cref="T:System.IComparable`1"/> natural ordering of its elements.
            </summary>
            <param name="collection">collection to be inserted into priority queue</param>
            <exception cref="T:System.InvalidCastException">
            if elements of the specified collection
            cannot be compared to one another according to the priority
            queue's ordering
            </exception>
            <see cref="T:System.ArgumentNullException">if the specified collection or any
            of its elements are null</see>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.#ctor(Lucene.Net.Support.PriorityQueue{`0})">
            <summary>
            Creates a <see cref="T:Lucene.Net.Support.PriorityQueue`1"/> containing the elements in the
            specified priority queue.  This priority queue will be
            ordered according to the same ordering as the given priority
            queue.
            </summary>
            <param name="collection">the priority queue whose elements are to be placed
            into this priority queue</param>
            <exception cref="T:System.InvalidCastException">
            if elements of <paramref name="collection"/>
            cannot be compared to one another according to <paramref name="collection"/>'s
            ordering
            </exception>
            <see cref="T:System.NullReferenceException">if the specified collection or any
            of its elements are null</see>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.PriorityQueue`1.#ctor(System.Collections.Generic.SortedSet{`0})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.PriorityQueue`1.#ctor(Lucene.Net.Support.TreeSet{`0})" -->
        <member name="M:Lucene.Net.Support.PriorityQueue`1.GetEnumerator">
            <summary>
            Gets the enumerator of the priority queue, which will not return elements
            in any specified ordering.
            </summary>
            <returns>The enumerator of the priority queue.</returns>
            <remarks>
            Returned enumerator does not iterate elements in sorted order.</remarks>
        </member>
        <member name="P:Lucene.Net.Support.PriorityQueue`1.Count">
            <summary>
            Gets the size of the priority queue. If the size of the queue is greater
            than the <see cref="F:System.Int32.MaxValue"/>, then it returns <see cref="F:System.Int32.MaxValue"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Clear">
            <summary>
            Removes all of the elements from this priority queue.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Offer(`0)">
            <summary>
            Inserts the specified element into this priority queue.
            </summary>
            <param name="item">the element to add to the priority queue.</param>
            <returns>always <c>true</c></returns>
            <exception cref="T:System.InvalidCastException">if the specified element cannot be
            compared with elements currently in this priority queue
            according to the priority queue's ordering</exception>
            <exception cref="T:System.ArgumentNullException">if the specified element is null</exception>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Poll">
            <summary>
            Gets and removes the head of the queue.
            </summary>
            <returns>the head of the queue or null if the queue is empty.</returns>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Peek">
            <summary>
            Gets but does not remove the head of the queue.
            </summary>
            <returns>the head of the queue or null if the queue is empty.</returns>
        </member>
        <member name="P:Lucene.Net.Support.PriorityQueue`1.Comparer">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.IComparer`1"/> used to order the elements in this
            queue, or <see cref="T:Lucene.Net.Util.ArrayUtil.NaturalComparer`1"/> if this queue is sorted according to
            the <see cref="T:System.IComparable`1"/> natural ordering of its elements.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Remove(`0)">
            <summary>
            Removes the specified object from the priority queue.
            </summary>
            <param name="item">the object to be removed.</param>
            <returns><c>true</c> if the object was in the priority queue, <c>false</c> if the object</returns>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Add(`0)">
            <summary>
            Adds the specified object to the priority queue.
            </summary>
            <param name="item">the object to be added.</param>
            <exception cref="T:System.InvalidCastException">if the specified element cannot be
            compared with elements currently in this priority queue
            according to the priority queue's ordering</exception>
            <exception cref="T:System.ArgumentNullException">if <paramref name="item"/> is <c>null</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.RemoveAt(System.Int32)">
            <summary>
            Removes the element at the specified <paramref name="index"/> from queue.
            <para/>
            Normally this method leaves the elements at up to <paramref name="index"/>-1,
            inclusive, untouched.  Under these circumstances, it returns
            <c>null</c>.  Occasionally, in order to maintain the heap invariant,
            it must swap a later element of the list with one earlier than
            <paramref name="index"/>.  Under these circumstances, this method returns the element
            that was previously at the end of the list and is now at some
            position before <paramref name="index"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Remove">
            <summary>
            Retrieves and removes the head of this queue.  This method differs
            from <see cref="M:Lucene.Net.Support.PriorityQueue`1.Poll"/> only in that it throws an exception if this
            queue is empty.
            <para/>
            This implementation returns the result of <see cref="M:Lucene.Net.Support.PriorityQueue`1.Poll"/>
            unless the queue is empty.
            </summary>
            <returns>the head of this queue</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">if this queue is empty</exception>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Element">
            <summary>
            Retrieves, but does not remove, the head of this queue.  This method
            differs from <see cref="M:Lucene.Net.Support.PriorityQueue`1.Peek"/> only in that it throws an exception if
            this queue is empty.
            <para/>
            This implementation returns the result of <see cref="M:Lucene.Net.Support.PriorityQueue`1.Peek"/>
            unless the queue is empty.
            </summary>
            <returns>the head of this queue</returns>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">if this queue is empty</exception>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.Contains(`0)">
            <summary>
            Returns <c>true</c> if this queue contains the specified element.
            More formally, returns <c>true</c> if and only if this queue contains
            at least one element <paramref name="item"/> such that <c>o.Equals(item)</c>.
            </summary>
            <param name="item">The object to locate in the priority queue</param>
            <returns><c>true</c> if item is found in the priority queue; otherwise, <c>false.</c> </returns>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the priority queue to an Array, starting at a particular Array index.
            </summary>
            <param name="array">The one-dimensional Array that is the destination of the elements copied from the priority queue. The Array must have zero-based indexing. </param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <remarks>
            It is not guaranteed that items will be copied in the sorted order.
            </remarks>
        </member>
        <member name="P:Lucene.Net.Support.PriorityQueue`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the collection is read-only.
            </summary>
            <remarks>
            For priority queue this property returns <c>false</c>.
            </remarks>
        </member>
        <member name="M:Lucene.Net.Support.PriorityQueue`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            <returns>Enumerator</returns>
            <remarks>
            Returned enumerator does not iterate elements in sorted order.</remarks>
        </member>
        <member name="T:Lucene.Net.Support.SignedZeroComparer">
            <summary>
            LUCENENET specific comparer to handle the special case
            of comparing negative zero with positive zero.
            <para/>
            For IEEE floating-point numbers, there is a distinction of negative and positive zero.
            Reference: http://stackoverflow.com/a/3139636
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.SimpleStringInterner">
            <summary> Simple lockless and memory barrier free String intern cache that is guaranteed
            to return the same String instance as String.intern() does.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.SimpleStringInterner.#ctor(System.Int32,System.Int32)">
            <param name="tableSize"> Size of the hash table, should be a power of two.
            </param>
            <param name="maxChainLength"> Maximum length of each bucket, after which the oldest item inserted is dropped.
            </param>
        </member>
        <member name="M:Lucene.Net.Support.StringBuilderExtensions.Reverse(System.Text.StringBuilder)">
            <summary>
            Causes this character sequence to be replaced by the reverse of
            the sequence. If there are any surrogate pairs included in the
            sequence, these are treated as single characters for the
            reverse operation. Thus, the order of the high-low surrogates
            is never reversed.
            <para/>
            Let <c>n</c> be the character length of this character sequence
            (not the length in <see cref="T:System.Char"/> values) just prior to
            execution of the <see cref="M:Lucene.Net.Support.StringBuilderExtensions.Reverse(System.Text.StringBuilder)"/> method. Then the
            character at index <c>k</c> in the new character sequence is
            equal to the character at index <c>n-k-1</c> in the old
            character sequence.
            <para/>
            Note that the reverse operation may result in producing
            surrogate pairs that were unpaired low-surrogates and
            high-surrogates before the operation. For example, reversing
            "&#92;uDC00&#92;uD800" produces "&#92;uD800&#92;uDC00" which is
            a valid surrogate pair.
            </summary>
            <param name="text">this <see cref="T:System.Text.StringBuilder"/></param>
            <returns>a reference to this <see cref="T:System.Text.StringBuilder"/>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.StringBuilderExtensions.CodePointCount(System.Text.StringBuilder,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the specified text
            range of this <see cref="T:System.Text.StringBuilder"/>. The text range begins at the specified
            <paramref name="beginIndex"/> and extends to the <see cref="T:System.Char"/> at
            index <c>endIndex - 1</c>. Thus the length (in
            <see cref="T:System.Char"/>s) of the text range is
            <c>endIndex-beginIndex</c>. Unpaired surrogates within
            this sequence count as one code point each.
            </summary>
            <param name="text">this <see cref="T:System.Text.StringBuilder"/></param>
            <param name="beginIndex">the index to the first <see cref="T:System.Char"/> of the text range.</param>
            <param name="endIndex">the index after the last <see cref="T:System.Char"/> of the text range.</param>
            <returns>the number of Unicode code points in the specified text range.</returns>
            <exception cref="T:System.IndexOutOfRangeException">
            if the <paramref name="beginIndex"/> is negative, or <paramref name="endIndex"/>
            is larger than the length of this sequence, or
            <paramref name="beginIndex"/> is larger than <paramref name="endIndex"/>.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.StringBuilderExtensions.GetChars(System.Text.StringBuilder)">
            <summary>
            Copies the array from the <see cref="T:System.Text.StringBuilder"/> into a new array
            and returns it.
            </summary>
            <param name="text">this <see cref="T:System.Text.StringBuilder"/></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.StringBuilderExtensions.AppendCodePoint(System.Text.StringBuilder,System.Int32)">
            <summary>
            Appends the string representation of the <paramref name="codePoint"/>
            argument to this sequence.
            
            <para>
            The argument is appended to the contents of this sequence.
            The length of this sequence increases by <see cref="M:Lucene.Net.Support.Character.CharCount(System.Int32)"/>.
            </para>
            <para>
            The overall effect is exactly as if the argument were
            converted to a <see cref="T:System.Char"/> array by the method
            <see cref="M:Lucene.Net.Support.Character.ToChars(System.Int32)"/> and the character in that array
            were then <see cref="M:System.Text.StringBuilder.Append(System.Char[])">appended</see> to this 
            <see cref="T:System.Text.StringBuilder"/>.
            </para>
            </summary>
            <param name="text">This <see cref="T:System.Text.StringBuilder"/>.</param>
            <param name="codePoint">a Unicode code point</param>
            <returns>a reference to this object.</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.StringExtensions.CompareToOrdinal(System.String,System.String)" -->
        <member name="M:Lucene.Net.Support.StringExtensions.CodePointCount(System.String,System.Int32,System.Int32)">
            <summary>
            Returns the number of Unicode code points in the specified text
            range of this <see cref="T:System.String"/>. The text range begins at the
            specified <paramref name="beginIndex"/> and extends to the
            <see cref="T:System.Char"/> at index <c>endIndex - 1</c>. Thus the
            length (in <see cref="T:System.Char"/>s) of the text range is
            <c>endIndex-beginIndex</c>. Unpaired surrogates within
            the text range count as one code point each.
            </summary>
            <param name="str"></param>
            <param name="beginIndex">the index to the first <see cref="T:System.Char"/> of the text range.</param>
            <param name="endIndex">the index after the last <see cref="T:System.Char"/> of the text range.</param>
            <returns>the number of Unicode code points in the specified text range</returns>
            <exception cref="T:System.IndexOutOfRangeException">if the <paramref name="beginIndex"/> is negative, or
            <paramref name="endIndex"/> is larger than the length of this <see cref="T:System.String"/>, or
            <paramref name="beginIndex"/> is larger than <paramref name="endIndex"/>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.StringExtensions.ToCharSequence(System.String)">
            <summary>
            Convenience method to wrap a string in a <see cref="T:Lucene.Net.Support.StringCharSequenceWrapper"/>
            so a string can be used as <see cref="T:Lucene.Net.Support.ICharSequence"/> in .NET.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.StringExtensions.IndexOf(System.String,System.Int32)">
            <summary>
            Returns the index within this string of the first occurrence of the
            specified <paramref name="codePoint"/>.
            </summary>
            <param name="str">this string</param>
            <param name="codePoint">a codePoint representing a single character or surrogate pair</param>
            <returns>the index of the first occurrence of the character (or surrogate pair) in the string, 
            or <c>-1</c> if the character (or surrogate pair) doesn't occur.</returns>
        </member>
        <member name="T:Lucene.Net.Support.StringInterner">
            <summary> Subclasses of StringInterner are required to
            return the same single String object for all equal strings.
            Depending on the implementation, this may not be
            the same object returned as String.intern().
            
            This StringInterner base class simply delegates to String.intern().
            
            LUCENENET specific.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.StringInterner.Intern(System.String)">
            <summary>Returns a single object instance for each equal string. </summary>
        </member>
        <member name="M:Lucene.Net.Support.StringInterner.Intern(System.Char[],System.Int32,System.Int32)">
            <summary>Returns a single object instance for each equal string. </summary>
        </member>
        <member name="T:Lucene.Net.Support.TreeDictionary`2">
            <summary>
            A sorted generic dictionary based on a red-black tree set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeDictionary`2.#ctor(Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a red-black tree dictionary using the natural comparer for keys.
            <exception cref="T:System.ArgumentException"/> if the key type K is not comparable.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeDictionary`2.#ctor(System.Collections.Generic.IComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a red-black tree dictionary using an external comparer for keys.
            </summary>
            <param name="comparer">The external comparer</param>
            <param name = "memoryType"></param>
        </member>
        <member name="M:Lucene.Net.Support.TreeDictionary`2.Snapshot">
            <summary>
            Make a snapshot of the current state of this dictionary
            </summary>
            <returns>The snapshot</returns>
        </member>
        <member name="T:Lucene.Net.Support.TreeSet`1">
             <summary>
             An implementation of Red-Black trees as an indexed, sorted collection with set semantics,
             cf. <a href="litterature.htm#CLRS">CLRS</a>. <see cref="T:C5.TreeBag`1"/> for a version 
             with bag semantics. <see cref="T:C5.TreeDictionary`2"/> for a sorted dictionary 
             based on this tree implementation.
             <i>
             The comparer (sorting order) may be either natural, because the item type is comparable 
             (generic: <see cref="T:C5.IComparable`1"/> or non-generic: System.IComparable) or it can
             be external and supplied by the user in the constructor.</i>
            
             <i>TODO: describe performance here</i>
             <i>TODO: discuss persistence and its useful usage modes. Warn about the space
             leak possible with other usage modes.</i>
             </summary>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.ListenableEvents">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.left(Lucene.Net.Support.TreeSet{`0}.Node)">
            <summary>
            Fetch the left child of n taking node-copying persistence into
            account if relevant. 
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.TreeSet`1.Node">
            <summary>
            The type of node in a Red-Black binary tree
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Node.update(Lucene.Net.Support.TreeSet{`0}.Node@,System.Boolean,Lucene.Net.Support.TreeSet{`0}.Node,System.Int32,System.Int32)">
            <summary>
            Update a child pointer
            </summary>
            <param name="cursor"></param>
            <param name="leftnode"></param>
            <param name="child"></param>
            <param name="maxsnapid"></param>
            <param name="generation"></param>
            <returns>True if node was *copied*</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.#ctor(Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a red-black tree collection with natural comparer and item equalityComparer.
            We assume that if <code>T</code> is comparable, its default equalityComparer 
            will be compatible with the comparer.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NotComparableException">If <code>T</code> is not comparable.
            </exception>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.#ctor(System.Collections.Generic.IComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a red-black tree collection with an external comparer. 
            <para>The itemequalityComparer will be a compatible 
            <see cref="T:C5.ComparerZeroHashCodeEqualityComparer`1"/> since the 
            default equalityComparer for T (<see cref="P:C5.EqualityComparer`1.Default"/>)
            is unlikely to be compatible with the external comparer. This makes the
            tree inadequate for use as item in a collection of unsequenced or sequenced sets or bags
            (<see cref="T:C5.ICollection`1"/> and <see cref="T:C5.ISequenced`1"/>)
            </para>
            </summary>
            <param name="comparer">The external comparer</param>
            <param name = "memoryType"></param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.#ctor(System.Collections.Generic.IComparer{`0},System.Collections.Generic.IEqualityComparer{`0},Lucene.Net.Support.C5.MemoryType)">
            <summary>
            Create a red-black tree collection with an external comparer and an external
            item equalityComparer, assumed consistent.
            </summary>
            <param name="comparer">The external comparer</param>
            <param name="equalityComparer">The external item equalitySCG.Comparer</param>
            <param name = "memoryType"></param>
        </member>
        <member name="T:Lucene.Net.Support.TreeSet`1.Enumerator">
            <summary>
            An enumerator for a red-black tree collection. Based on an explicit stack
            of subtrees waiting to be enumerated. Currently only used for the tree set 
            enumerators (tree bag enumerators use an iterator block based enumerator).
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Enumerator.#ctor(Lucene.Net.Support.TreeSet{`0})">
            <summary>
            Create a tree enumerator
            </summary>
            <param name="tree">The red-black tree to enumerate</param>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current item of the enumerator.</value>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:Lucene.Net.Support.C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Enumerator.Dispose">
            <summary>
            Call Dispose(true) and then suppress finalization of this enumerator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Enumerator.Dispose(System.Boolean)">
            <summary>
            Remove the internal data (notably the stack array).
            </summary>
            <param name="disposing">True if called from Dispose(),
            false if called from the finalizer</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Enumerator.Finalize">
            <summary>
            Finalizer for enumerator
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.TreeSet`1.SnapEnumerator">
            <summary>
            An enumerator for a snapshot of a node copy persistent red-black tree
            collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.SnapEnumerator.#ctor(Lucene.Net.Support.TreeSet{`0})">
            <summary>
            Create an enumerator for a snapshot of a node copy persistent red-black tree
            collection
            </summary>
            <param name="tree">The snapshot</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.SnapEnumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:Lucene.Net.Support.C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.SnapEnumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> object to contain all elements that are present in itself, the specified collection, or both.
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Not implemented
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Not implemented
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Not implemented
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> object.</param>
            <returns><c>true</c> if the <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a subset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> object.</param>
            <returns><c>true</c> if the <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a superset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a proper superset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> object.</param>
            <returns><c>true</c> if the <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a proper superset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether a <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a proper subset of the specified collection.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> object.</param>
            <returns><c>true</c> if the <see cref="T:Lucene.Net.Support.TreeSet`1"/> object is a proper subset of other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> object and a specified collection share common elements.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> object.</param>
            <returns><c>true</c> if the <see cref="T:Lucene.Net.Support.TreeSet`1"/> object and other share at least one common element; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Determines whether the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> and the specified collection contain the same elements.
            </summary>
            <param name="other">The collection to compare to the current <see cref="T:Lucene.Net.Support.TreeSet`1"/>.</param>
            <returns><c>true</c> if the current <see cref="T:Lucene.Net.Support.TreeSet`1"/> is equal to other; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Choose">
            <summary>
            
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException">If tree is empty</exception>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.GetEnumerator">
            <summary>
            Create an enumerator for this tree
            </summary>
            <returns>The enumerator</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.addIterative(`0,`0@,System.Boolean,System.Boolean@)">
            <summary>
            Add item to tree. If already there, return the found item in the second argument.
            </summary>
            <param name="item">Item to add</param>
            <param name="founditem">item found</param>
            <param name="update">whether item in node should be updated</param>
            <param name="wasfound">true if found in bag, false if not found or tree is a set</param>
            <returns>True if item was added</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
            <returns>True if item was added.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <summary>
            Add an item to this collection if possible. If this collection has set
            semantics, the item will be added if not already in the collection. If
            bag semantics, the item will always be added.
            </summary>
            <param name="item">The item to add.</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.AddAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add the elements from another collection with a more specialized item type 
            to this collection. If this
            collection has set semantics, only items not already in the collection
            will be added.
            </summary>
            <param name="items">The items to add</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.AddSorted(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Add all the items from another collection with an enumeration order that 
            is increasing in the items. <para>The idea is that the implementation may use
            a faster algorithm to merge the two collections.</para>
            <exception cref="T:System.ArgumentException"/> if the enumerated items turns out
            not to be in increasing order.
            </summary>
            <param name="items">The collection to add.</param>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.AllowsDuplicates">
            <summary></summary>
            <value>False since this tree has set semantics.</value>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.DuplicatesByCounting">
            <summary>
            By convention this is true for any collection with set semantics.
            </summary>
            <value>True if only one representative of a group of equal items 
            is kept in the collection together with the total count.</value>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.ContainsSpeed">
            <summary>
            The value is symbolic indicating the type of asymptotic complexity
            in terms of the size of this collection (worst-case or amortized as
            relevant).
            </summary>
            <value>Speed.Log</value>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Contains(`0)">
            <summary>
            Check if this collection contains (an item equivalent to according to the
            itemequalityComparer) a particular value.
            </summary>
            <param name="item">The value to check for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Find(`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, return in the ref argument (a
            binary copy of) the actual value found.
            </summary>
            <param name="item">The value to look for.</param>
            <returns>True if the items is in this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.FindOrAdd(`0@)">
             <summary>
             Find or add the item to the tree. If the tree does not contain
             an item equivalent to this item add it, else return the existing
             one in the ref argument. 
            
             </summary>
             <param name="item"></param>
             <returns>True if item was found</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Update(`0)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            to with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item">Value to update.</param>
            <returns>True if the item was found and hence updated.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Update(`0,`0@)">
            <summary>
            Check if this collection contains an item equivalent according to the
            itemequalityComparer to a particular value. If so, update the item in the collection 
            with a binary copy of the supplied value. If the collection has bag semantics,
            this updates all equivalent copies in
            the collection.
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.UpdateOrAdd(`0)">
             <summary>
             Check if this collection contains an item equivalent according to the
             itemequalityComparer to a particular value. If so, update the item in the collection 
             with a binary copy of the supplied value; else add the value to the collection. 
            
             <i>NOTE: the bag implementation is currently wrong! ?????</i>
             </summary>
             <param name="item">Value to add or update.</param>
             <returns>True if the item was found and updated (hence not added).</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.UpdateOrAdd(`0,`0@)">
            <summary>
            
            </summary>
            <param name="item"></param>
            <param name="olditem"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Remove(`0)">
            <summary>
            Remove a particular item from this collection. If the collection has bag
            semantics only one copy equivalent to the supplied item is removed. 
            </summary>
            <param name="item">The value to remove.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Remove(`0,`0@)">
            <summary>
            Remove a particular item from this collection if found. If the collection
            has bag semantics only one copy equivalent to the supplied item is removed,
            which one is implementation dependent. 
            If an item was removed, report a binary copy of the actual item removed in 
            the argument.
            </summary>
            <param name="item">The value to remove.</param>
            <param name="removeditem">The removed value.</param>
            <returns>True if the item was found (and removed).</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.removeIterative(`0@,System.Boolean,System.Int32@)">
            <summary>
            
            </summary>
            <param name="item">input: item to remove; output: item actually removed</param>
            <param name="all">If true, remove all copies</param>
            <param name="wasRemoved"></param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Clear">
            <summary>
            Remove all items from this collection.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RemoveAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items in another collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to remove.</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RetainAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Remove all items not in some other collection from this one. If this collection
            has bag semantics, take multiplicities into account.
            </summary>
            <param name="items">The items to retain.</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.ContainsAll(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Check if this collection contains all the values in another collection.
            If this collection has bag semantics (<code>AllowsDuplicates==true</code>)
            the check is made with respect to multiplicities, else multiplicities
            are not taken into account.
            </summary>
            <param name="items">The </param>
            <returns>True if all values in <code>items</code>is in this collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.FindAll(System.Func{`0,System.Boolean})">
            <summary>
            Create a new indexed sorted collection consisting of the items of this
            indexed sorted collection satisfying a certain predicate.
            </summary>
            <param name="filter">The filter delegate defining the predicate.</param>
            <returns>The new indexed sorted collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Map``1(System.Func{`0,``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Create a new indexed sorted collection consisting of the results of
            mapping all items of this list.
            <exception cref="T:System.ArgumentException"/> if the map is not increasing over 
            the items of this collection (with respect to the two given comparison 
            relations).
            </summary>
            <param name="mapper">The delegate definging the map.</param>
            <param name="c">The comparion relation to use for the result.</param>
            <returns>The new sorted collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.ContainsCount(`0)">
            <summary>
            Count the number of items of the collection equal to a particular value.
            Returns 0 if and only if the value is not in the collection.
            </summary>
            <param name="item">The value to count.</param>
            <returns>The number of copies found.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.UniqueItems">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.ItemMultiplicities">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RemoveAllCopies(`0)">
            <summary>
            Remove all items equivalent to a given value.
            </summary>
            <param name="item">The value to remove.</param>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.Item(System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <value>The i'th item of this list.</value>
            <param name="i">the index to lookup</param>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.IndexingSpeed">
            <summary>
            
            </summary>
            <value></value>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.IndexOf(`0)">
            <summary>
            Searches for an item in this indexed collection going forwards from the start.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of first occurrence from start of the item
            if found, else the two-complement 
            (always negative) of the index at which the item would be put if it was added.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.LastIndexOf(`0)">
            <summary>
            Searches for an item in the tree going backwards from the end.
            </summary>
            <param name="item">Item to search for.</param>
            <returns>Index of last occurrence from the end of item if found, 
            else the two-complement (always negative) of the index at which 
            the item would be put if it was added.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at a specific position of the list.
            <exception cref="T:System.IndexOutOfRangeException"/> if i is negative or
            &gt;= the size of the collection.
            </summary>
            <param name="i">The index of the item to remove.</param>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RemoveInterval(System.Int32,System.Int32)">
            <summary>
            Remove all items in an index interval.
            <exception cref="T:System.IndexOutOfRangeException"/>???. 
            </summary>
            <param name="start">The index of the first item to remove.</param>
            <param name="count">The number of items to remove.</param>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.Item(System.Int32,System.Int32)">
            <summary>
            <exception cref="T:System.IndexOutOfRangeException"/>.
            </summary>
            <value>The directed collection of items in a specific index interval.</value>
            <param name="start">The starting index of the interval (inclusive).</param>
            <param name="count">The length of the interval.</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Backwards">
            <summary>
            Create a collection containing the same items as this collection, but
            whose enumerator will enumerate the items backwards. The new collection
            will become invalid if the original is modified. Method typically used as in
            <code>foreach (T x in coll.Backwards()) {...}</code>
            </summary>
            <returns>The backwards collection.</returns>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.Comparer">
            <summary>
            The comparer object supplied at creation time for this collection
            </summary>
            <value>The comparer</value>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.FindMin">
            <summary>
            Find the current least item of this priority queue.
            </summary>
            <returns>The least item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.DeleteMin">
            <summary>
            Remove the least item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.FindMax">
            <summary>
            Find the current largest item of this priority queue.
            </summary>
            <returns>The largest item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.DeleteMax">
            <summary>
            Remove the largest item from this  priority queue.
            </summary>
            <returns>The removed item.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.TryPredecessor(`0,`0@)">
            <summary>
            Find the strict predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than the item.
            </summary>
            <param name="item">The item to find the predecessor for.</param>
            <param name="res">The predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a predecessor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.TrySuccessor(`0,`0@)">
            <summary>
            Find the strict successor of item in the sorted collection,
            that is, the least item in the collection greater than the supplied value.
            </summary>
            <param name="item">The item to find the successor for.</param>
            <param name="res">The successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a successor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.TryWeakPredecessor(`0,`0@)">
            <summary>
            Find the weak predecessor of item in the sorted collection,
            that is, the greatest item in the collection smaller than or equal to the item.
            </summary>
            <param name="item">The item to find the weak predecessor for.</param>
            <param name="res">The weak predecessor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak predecessor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.TryWeakSuccessor(`0,`0@)">
            <summary>
            Find the weak successor of item in the sorted collection,
            that is, the least item in the collection greater than or equal to the supplied value.
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <param name="res">The weak successor, if any; otherwise the default value for T.</param>
            <returns>True if item has a weak successor; otherwise false.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Predecessor(`0)">
            <summary>
            Find the strict predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than the supplied value.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than or equal to the minimum of this collection.)</exception>
            <param name="item">The item to find the predecessor for.</param>
            <returns>The predecessor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.WeakPredecessor(`0)">
            <summary>
            Find the weak predecessor in the sorted collection of a particular value,
            i.e. the largest item in the collection less than or equal to the supplied value.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is less than the minimum of this collection.)</exception>
            <param name="item">The item to find the weak predecessor for.</param>
            <returns>The weak predecessor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Successor(`0)">
            <summary>
            Find the strict successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than the supplied value.
            </summary>
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than or equal to the maximum of this collection.)</exception>
            <param name="item">The item to find the successor for.</param>
            <returns>The successor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.WeakSuccessor(`0)">
            <summary>
            Find the weak successor in the sorted collection of a particular value,
            i.e. the least item in the collection greater than or equal to the supplied value.
            <exception cref="T:Lucene.Net.Support.C5.NoSuchItemException"> if no such element exists (the
            supplied  value is greater than the maximum of this collection.)</exception>
            </summary>
            <param name="item">The item to find the weak successor for.</param>
            <returns>The weak successor.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RangeFrom(`0)">
            <summary>
            Query this sorted collection for items greater than or equal to a supplied value.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RangeFromTo(`0,`0)">
            <summary>
            Query this sorted collection for items between two supplied values.
            </summary>
            <param name="bot">The lower bound (inclusive).</param>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RangeTo(`0)">
            <summary>
            Query this sorted collection for items less than a supplied value.
            </summary>
            <param name="top">The upper bound (exclusive).</param>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RangeAll">
            <summary>
            Create a directed collection with the same items as this collection.
            </summary>
            <returns>The result directed collection.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Cut(System.IComparable{`0},`0@,System.Boolean@,`0@,System.Boolean@)">
            <summary>
            Perform a search in the sorted collection for the ranges in which a
            non-increasing (i.e. weakly decreasing) function from the item type to 
            <code>int</code> is
            negative, zero respectively positive. If the supplied cut function is
            not non-increasing, the result of this call is undefined.
            </summary>
            <param name="c">The cut function <code>T</code> to <code>int</code>, given
            as an <code>IComparable&lt;T&gt;</code> object, where the cut function is
            the <code>c.CompareTo(T that)</code> method.</param>
            <param name="low">Returns the largest item in the collection, where the
            cut function is positive (if any).</param>
            <param name="lowIsValid">True if the cut function is positive somewhere
            on this collection.</param>
            <param name="high">Returns the least item in the collection, where the
            cut function is negative (if any).</param>
            <param name="highIsValid">True if the cut function is negative somewhere
            on this collection.</param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.CountFrom(`0)">
            <summary>
            Determine the number of items at or above a supplied threshold.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.CountFromTo(`0,`0)">
            <summary>
            Determine the number of items between two supplied thresholds.
            </summary>
            <param name="bot">The lower bound (inclusive)</param>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.CountTo(`0)">
            <summary>
            Determine the number of items below a supplied threshold.
            </summary>
            <param name="top">The upper bound (exclusive)</param>
            <returns>The number of matching items.</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RemoveRangeFrom(`0)">
            <summary>
            Remove all items of this collection above or at a supplied threshold.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RemoveRangeFromTo(`0,`0)">
            <summary>
            Remove all items of this collection between two supplied thresholds.
            </summary>
            <param name="low">The lower threshold (inclusive).</param>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.RemoveRangeTo(`0)">
            <summary>
            Remove all items of this collection below a supplied threshold.
            </summary>
            <param name="hi">The upper threshold (exclusive).</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Dispose">
            <summary>
            If this tree is a snapshot, remove registration in base tree
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Snapshot">
            <summary>
            Make a (read-only) snapshot of this collection.
            </summary>
            <returns>The snapshot.</returns>
        </member>
        <member name="P:Lucene.Net.Support.TreeSet`1.Range.Enumerator.Current">
            <summary>
            Undefined if enumerator is not valid (MoveNext hash been called returning true)
            </summary>
            <value>The current value of the enumerator.</value>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Range.Enumerator.MoveNext">
            <summary>
            Move enumerator to next item in tree, or the first item if
            this is the first call to MoveNext. 
            <exception cref="T:Lucene.Net.Support.C5.CollectionModifiedException"/> if underlying tree was modified.
            </summary>
            <returns>True if enumerator is valid now</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.minidump(Lucene.Net.Support.TreeSet{`0}.Node,System.String)">
            <summary>
            Display this node on the console, and recursively its subnodes.
            </summary>
            <param name="n">Node to display</param>
            <param name="space">Indentation</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.dump">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.dump(System.String)">
            <summary>
            Print the tree structure to the console stdout.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.dump(System.String,System.String)">
            <summary>
            Display this tree on the console.
            </summary>
            <param name="msg">Identifying string of this call to dump</param>
            <param name="err">Extra (error)message to include</param>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.massert(System.Boolean,Lucene.Net.Support.TreeSet{`0}.Node,System.String)">
            <summary>
            Print warning m on logger if b is false.
            </summary>
            <param name="b">Condition that should hold</param>
            <param name="n">Place (used for id display)</param>
            <param name="m">Message</param>
            <returns>b</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Check(System.String)">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <param name="name">Title of dump</param>
            <returns>false if invariant violation</returns>
        </member>
        <member name="M:Lucene.Net.Support.TreeSet`1.Check">
            <summary>
            Checks red-black invariant. Dumps tree to console if bad
            </summary>
            <returns>false if invariant violation</returns>
        </member>
        <member name="T:Lucene.Net.Support.WeakDictionary`2.WeakKey`1">
            <summary>
            A weak reference wrapper for the hashtable keys. Whenever a key\value pair
            is added to the hashtable, the key is wrapped using a WeakKey. WeakKey saves the
            value of the original object hashcode for fast comparison.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.WritableArrayAttribute">
            <summary>
            Attribute to define a property or method as a writable array.
            Per MSDN, members should never return arrays because the array contents
            can be updated, which makes the behavior confusing. However,
            Lucene's design sometimes relies on other classes to update arrays -
            both as array fields and as methods that return arrays. So, in these
            cases we are making an exception to this rule and marking them with
            <see cref="T:Lucene.Net.Support.WritableArrayAttribute"/> to signify that this is intentional.
            <para/>
            For properties that violate this rule, you should also use
            the <see cref="T:System.Diagnostics.CodeAnalysis.SuppressMessageAttribute"/>:
            <code>
            [WritableArray, SuppressMessage("Microsoft.Performance", "CA1819", Justification = "Lucene's design requires some writable array properties")]
            </code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.Buffer">
            <summary>
            A buffer is a list of elements of a specific primitive type.
            <para/>
            A buffer can be described by the following properties:
            <list type="bullet">
                <item>
                    Capacity:
                    The number of elements a buffer can hold. Capacity may not be
                    negative and never changes.
                </item>
                <item>
                    Position:
                    A cursor of this buffer. Elements are read or written at the
                    position if you do not specify an index explicitly. Position may not be
                    negative and not greater than the limit.
                </item>
                <item>
                    Limit:
                    Controls the scope of accessible elements. You can only read or
                    write elements from index zero to <c>limit - 1</c>. Accessing
                    elements out of the scope will cause an exception. Limit may not be negative
                    and not greater than capacity.
                </item>
                <item>
                    Mark: 
                    Used to remember the current position, so that you can reset the
                    position later. Mark may not be negative and no greater than position.
                </item>
                <item>
                    A buffer can be read-only or read-write. Trying to modify the elements
                    of a read-only buffer will cause a <see cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException"/>,
                    while changing the position, limit and mark of a read-only buffer is OK.
                </item>
                <item>
                    A buffer can be direct or indirect. A direct buffer will try its best to
                    take advantage of native memory APIs and it may not stay in the heap,
                    thus it is not affected by garbage collection.
                </item>
            </list>
            <para/>
            Buffers are not thread-safe. If concurrent access to a buffer instance is
            required, then the callers are responsible to take care of the
            synchronization issues.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.Buffer.UNSET_MARK">
            <summary>
            <c>UNSET_MARK</c> means the mark has not been set.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.Buffer.capacity">
            <summary>
            The capacity of this buffer, which never change.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.Buffer.limit">
            <summary>
            <c>limit - 1</c> is the last element that can be read or written.
            Limit must be no less than zero and no greater than <see cref="F:Lucene.Net.Support.IO.Buffer.capacity"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.Buffer.mark">
            <summary>
            Mark is where position will be set when <see cref="M:Lucene.Net.Support.IO.Buffer.Reset"/> is called.
            Mark is not set by default. Mark is always no less than zero and no
            greater than <see cref="F:Lucene.Net.Support.IO.Buffer.position"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.Buffer.position">
            <summary>
            The current position of this buffer. Position is always no less than zero
            and no greater than <see cref="F:Lucene.Net.Support.IO.Buffer.limit"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.#ctor(System.Int32)">
            <summary>
            Construct a buffer with the specified capacity.
            </summary>
            <param name="capacity">The capacity of this buffer</param>
        </member>
        <member name="P:Lucene.Net.Support.IO.Buffer.Capacity">
            <summary>
            Returns the capacity of this buffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.Clear">
            <summary>
            Clears this buffer.
            <para>
            While the content of this buffer is not changed, the following internal
            changes take place: the current position is reset back to the start of
            the buffer, the value of the buffer limit is made equal to the capacity
            and mark is cleared.
            </para>
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.Flip">
            <summary>
            Flips this buffer.
            <para/>
            The limit is set to the current position, then the position is set to
            zero, and the mark is cleared.
            <para/>
            The content of this buffer is not changed.
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="P:Lucene.Net.Support.IO.Buffer.HasRemaining">
            <summary>
            Indicates if there are elements remaining in this buffer, that is if
            <c>position &lt; limit</c>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.IO.Buffer.IsReadOnly">
            <summary>
            Indicates whether this buffer is read-only.
            </summary>
            <returns>
            <c>true</c> if, this buffer is read-only; otherwise <c>false</c>.
            </returns>
        </member>
        <member name="P:Lucene.Net.Support.IO.Buffer.Limit">
            <summary>
            Gets or Sets the limit of this buffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.SetLimit(System.Int32)">
            <summary>
            Sets the limit of this buffer.
            <para/>
            If the current position in the buffer is in excess of
            <c>newLimit</c> then, on returning from this call, it will have
            been adjusted to be equivalent to <c>newLimit</c>. If the mark
            is set and is greater than the new limit, then it is cleared.
            </summary>
            <param name="newLimit">The new limit value; must be non-negative and no larger than this buffer's capacity</param>
            <returns>This buffer</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="newLimit"/> is invalid.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.Mark">
            <summary>
            Marks the current position, so that the position may return to this point
            later by calling <see cref="M:Lucene.Net.Support.IO.Buffer.Reset"/>.
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="P:Lucene.Net.Support.IO.Buffer.Position">
            <summary>
            Returns the position of this buffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.SetPosition(System.Int32)">
            <summary>
            Sets the position of this buffer.
            <para/>
            If the mark is set and it is greater than the new position, then it is
            cleared.
            </summary>
            <param name="newPosition">The new position, must be not negative and not greater than limit.</param>
            <returns>This buffer</returns>
            <exception cref="T:System.ArgumentException">If <paramref name="newPosition"/> is invalid.</exception>
        </member>
        <member name="P:Lucene.Net.Support.IO.Buffer.Remaining">
            <summary>
            Returns the number of remaining elements in this buffer, that is
            <c>limit - position</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.Reset">
            <summary>
            Resets the position of this buffer to the <see cref="F:Lucene.Net.Support.IO.Buffer.mark"/>.
            </summary>
            <returns>This buffer</returns>
            <exception cref="T:Lucene.Net.Support.IO.InvalidMarkException">If the mark has not been set</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.Buffer.Rewind">
            <summary>
            Rewinds this buffer.
            <para/>
            The position is set to zero, and the mark is cleared. The content of this]
            buffer is not changed.
            </summary>
            <returns>This buffer</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.BufferUnderflowException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Lucene.Net.Support.IO.BufferOverflowException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Lucene.Net.Support.IO.ReadOnlyBufferException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:Lucene.Net.Support.IO.InvalidMarkException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Support.IO.ByteBuffer">
            <summary>
            A buffer for bytes.
            <para/>
            A byte buffer can be created in either one of the following ways:
            <list type="bullet">
                <item><see cref="M:Lucene.Net.Support.IO.ByteBuffer.Allocate(System.Int32)"/> a new byte array and create a
                buffer based on it</item>
                <item><see cref="M:Lucene.Net.Support.IO.ByteBuffer.AllocateDirect(System.Int32)"/> a memory block and create a direct
                buffer based on it</item>
                <item><see cref="M:Lucene.Net.Support.IO.ByteBuffer.Wrap(System.Byte[])"/> an existing byte array to create a new buffer</item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Allocate(System.Int32)">
            <summary>
            Creates a byte buffer based on a newly allocated byte array.
            </summary>
            <param name="capacity">the capacity of the new buffer</param>
            <returns>The created byte buffer.</returns>
            <exception cref="T:System.ArgumentException">If the <c>capacity &lt; 0</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.AllocateDirect(System.Int32)">
            <summary>
            Creates a direct byte buffer based on a newly allocated memory block. (NOT IMPLEMENTED IN LUCENE.NET)
            </summary>
            <param name="capacity">the capacity of the new buffer</param>
            <returns>The new byte buffer</returns>
            <exception cref="T:System.ArgumentException">If the <c>capacity &lt; 0</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Wrap(System.Byte[])">
            <summary>
            Creates a new byte buffer by wrapping the given byte array.
            <para/>
            Calling this method has the same effect as
            <c>Wrap(array, 0, array.Length)</c>.
            </summary>
            <param name="array">The byte array which the new buffer will be based on</param>
            <returns>The new byte buffer</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Wrap(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Creates a new byte buffer by wrapping the given byte array.
            <para/>
            The new buffer's position will be <paramref name="start"/>, limit will be
            <c>start + len</c>, capacity will be the length of the array.
            </summary>
            <param name="array">The byte array which the new buffer will be based on.</param>
            <param name="start">
            The start index, must not be negative and not greater than <c>array.Length</c>.
            </param>
            <param name="length">
            The length, must not be negative and not greater than
            <c>array.Length - start</c>.
            </param>
            <returns>The new byte buffer</returns>
            <exception cref="T:System.IndexOutOfRangeException">if either <paramref name="start"/> or <paramref name="length"/> are invalid.</exception>
        </member>
        <member name="F:Lucene.Net.Support.IO.ByteBuffer.order">
            <summary>
            The byte order of this buffer, default is <see cref="F:Lucene.Net.Support.IO.ByteOrder.BIG_ENDIAN"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.#ctor(System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Support.IO.ByteBuffer"/> with given capacity.
            </summary>
            <param name="capacity">the capacity of the buffer.</param>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.Array">
            <summary>
            Returns the byte array which this buffer is based on, if there is one.
            </summary>
            <returns>the byte array which this buffer is based on.</returns>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if this buffer is based on a read-only array.</exception>
            <exception cref="T:System.InvalidOperationException">if this buffer is not based on an array.</exception>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.ArrayOffset">
            <summary>
            Returns the offset of the byte array which this buffer is based on, if
            there is one.
            <para/>
            The offset is the index of the array which corresponds to the zero
            position of the buffer.
            </summary>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if this buffer is based on a read-only array.</exception>
            <exception cref="T:System.InvalidOperationException">if this buffer is not based on an array.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.AsInt64Buffer">
            <summary>
            Returns a long buffer which is based on the remaining content of this
            byte buffer.
            <para/>
            The new buffer's position is zero, its limit and capacity is the number
            of remaining bytes divided by eight, and its mark is not set. The new
            buffer's read-only property and byte order are the same as this buffer's.
            The new buffer is direct if this byte buffer is direct.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </summary>
            <returns>a long buffer which is based on the content of this byte buffer.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.AsReadOnlyBuffer">
            <summary>
            Returns a read-only buffer that shares its content with this buffer.
            <para/>
            The returned buffer is guaranteed to be a new instance, even if this
            buffer is read-only itself. The new buffer's position, limit, capacity
            and mark are the same as this buffer.
            <para/>
            The new buffer shares its content with this buffer, which means this
            buffer's change of content will be visible to the new buffer. The two
            buffer's position, limit and mark are independent.
            </summary>
            <returns>a read-only version of this buffer.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Compact">
            <summary>
            Compacts this byte buffer.
            <para/>
            The remaining bytes will be moved to the head of the
            buffer, starting from position zero. Then the position is set to
            <see cref="!:Remaining"/>; the limit is set to capacity; the mark is
            cleared.
            </summary>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.CompareTo(Lucene.Net.Support.IO.ByteBuffer)">
            <summary>
            Compares the remaining bytes of this buffer to another byte buffer's
            remaining bytes.
            </summary>
            <param name="otherBuffer">another byte buffer.</param>
            <returns>
            a negative value if this is less than <c>other</c>; 0 if this
            equals to <c>other</c>; a positive value if this is greater
            than <c>other</c>.
            </returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Duplicate">
            <summary>
            Returns a duplicated buffer that shares its content with this buffer.
            <para/>
            The duplicated buffer's position, limit, capacity and mark are the same
            as this buffer's. The duplicated buffer's read-only property and byte
            order are the same as this buffer's too.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </summary>
            <returns>a duplicated buffer that shares its content with this buffer.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Equals(System.Object)">
            <summary>
            Checks whether this byte buffer is equal to another object.
            <para/>
            If <paramref name="other"/> is not a byte buffer then <c>false</c> is returned. Two
            byte buffers are equal if and only if their remaining bytes are exactly
            the same. Position, limit, capacity and mark are not considered.
            </summary>
            <param name="other">the object to compare with this byte buffer.</param>
            <returns>
            <c>true</c> if this byte buffer is equal to <paramref name="other"/>,
            <c>false</c> otherwise.
            </returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Get">
            <summary>
            Returns the byte at the current position and increases the position by 1.
            </summary>
            <returns>the byte at the current position.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if the position is equal or greater than limit.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Get(System.Byte[])">
            <summary>
            Reads bytes from the current position into the specified byte array and
            increases the position by the number of bytes read.
            <para/>
            Calling this method has the same effect as
            <c>Get(dest, 0, dest.Length)</c>.
            </summary>
            <param name="dest">the destination byte array.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if <c>dest.Length</c> is greater than <see cref="!:Remaining"/>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Get(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes from the current position into the specified byte array,
            starting at the specified offset, and increases the position by the
            number of bytes read.
            </summary>
            <param name="dest">the target byte array.</param>
            <param name="off">
            the offset of the byte array, must not be negative and
            not greater than <c>dest.Length</c>.</param>
            <param name="len">
            the number of bytes to read, must not be negative and not
            greater than <c>dest.Length - off</c>
            </param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if either <paramref name="off"/> or <paramref name="len"/> is invalid.</exception>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if <paramref name="len"/> is greater than <see cref="!:Remaining"/>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Get(System.Int32)">
            <summary>
            Returns the byte at the specified index and does not change the position.
            
            </summary>
            <param name="index">the index, must not be negative and less than limit.</param>
            <returns>the byte at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if index is invalid.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetChar">
            <summary>
            Returns the char at the current position and increases the position by 2.
            <para/>
            The 2 bytes starting at the current position are composed into a char
            according to the current byte order and returned.
            </summary>
            <returns>the char at the current position.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 2</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetChar(System.Int32)">
            <summary>
            Returns the char at the specified index.
            <para/>
            The 2 bytes starting from the specified index are composed into a char
            according to the current byte order and returned. The position is not
            changed.
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 2</c>.</param>
            <returns>the char at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetDouble">
            <summary>
            Returns the double at the current position and increases the position by 8.
            <para/>
            The 8 bytes starting from the current position are composed into a double
            according to the current byte order and returned.
            </summary>
            <returns>the double at the current position.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 8</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetDouble(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Double"/> at the specified index.
            <para/>
            The 8 bytes starting at the specified index are composed into a <see cref="T:System.Double"/>
            according to the current byte order and returned. The position is not
            changed.
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 8</c>.</param>
            <returns>the <see cref="T:System.Double"/> at the specified index.</returns>
            <returns>the <see cref="T:System.Double"/> at the current position.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetSingle">
            <summary>
            Returns the <see cref="T:System.Single"/> at the current position and increases the position by 4.
            <para/>
            The 4 bytes starting at the current position are composed into a <see cref="T:System.Single"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getFloat() in the JDK
            </summary>
            <returns>the <see cref="T:System.Single"/> at the current position.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 4</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetSingle(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Single"/> at the specified index.
            <para/>
            The 4 bytes starting at the specified index are composed into a <see cref="T:System.Single"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getFloat() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 4</c>.</param>
            <returns>the <see cref="T:System.Single"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetInt32">
            <summary>
            Returns the <see cref="T:System.Int32"/> at the current position and increases the position by 4.
            <para/>
            The 4 bytes starting at the current position are composed into a <see cref="T:System.Int32"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getInt() in the JDK
            </summary>
            <returns>the <see cref="T:System.Int32"/> at the current position.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 4</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetInt32(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Int32"/> at the specified index.
            <para/>
            The 4 bytes starting at the specified index are composed into a <see cref="T:System.Int32"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getInt() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 4</c>.</param>
            <returns>the <see cref="T:System.Int32"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetInt64">
            <summary>
            Returns the <see cref="T:System.Int64"/> at the current position and increases the position by 8.
            <para/>
            The 8 bytes starting at the current position are composed into a <see cref="T:System.Int64"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getLong() in the JDK
            </summary>
            <returns>the <see cref="T:System.Int64"/> at the current position.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 8</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetInt64(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Int64"/> at the specified index.
            <para/>
            The 8 bytes starting at the specified index are composed into a <see cref="T:System.Int64"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getLong() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 8</c>.</param>
            <returns>the <see cref="T:System.Int64"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetInt16">
            <summary>
            Returns the <see cref="T:System.Int16"/> at the current position and increases the position by 2.
            <para/>
            The 2 bytes starting at the current position are composed into a <see cref="T:System.Int16"/>
            according to the current byte order and returned.
            <para/>
            NOTE: This was getShort() in the JDK
            </summary>
            <returns>the <see cref="T:System.Int16"/> at the current position.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferUnderflowException">if the position is greater than <c>limit - 2</c>.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetInt16(System.Int32)">
            <summary>
            Returns the <see cref="T:System.Int16"/> at the specified index.
            <para/>
            The 2 bytes starting at the specified index are composed into a <see cref="T:System.Int16"/>
            according to the current byte order and returned. The position is not
            changed.
            <para/>
            NOTE: This was getShort() in the JDK
            </summary>
            <param name="index">the index, must not be negative and equal or less than <c>limit - 2</c>.</param>
            <returns>the <see cref="T:System.Int16"/> at the specified index.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.HasArray">
            <summary>
            Indicates whether this buffer is based on a byte array and provides
            read/write access.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.GetHashCode">
            <summary>
            Calculates this buffer's hash code from the remaining chars. The
            position, limit, capacity and mark don't affect the hash code.
            </summary>
            <returns>the hash code calculated from the remaining bytes.</returns>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.IsDirect">
            <summary>
            Indicates whether this buffer is direct.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.Order">
            <summary>
            Returns the byte order used by this buffer when converting bytes from/to
            other primitive types.
            <para/>
            The default byte order of byte buffer is always
            <see cref="F:Lucene.Net.Support.IO.ByteOrder.BIG_ENDIAN"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.SetOrder(Lucene.Net.Support.IO.ByteOrder)">
            <summary>
            Sets the byte order of this buffer.
            </summary>
            <param name="byteOrder">the byte order to set.</param>
            <returns>this buffer.</returns>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.ProtectedArray">
            <summary>
            Child class implements this method to realize <see cref="P:Lucene.Net.Support.IO.ByteBuffer.Array"/>.
            </summary>
            <seealso cref="P:Lucene.Net.Support.IO.ByteBuffer.Array"/>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.ProtectedArrayOffset">
            <summary>
            Child class implements this method to realize <see cref="P:Lucene.Net.Support.IO.ByteBuffer.ArrayOffset"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteBuffer.ProtectedHasArray">
            <summary>
            Child class implements this method to realize <seealso cref="P:Lucene.Net.Support.IO.ByteBuffer.HasArray"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Put(System.Byte)">
            <summary>
            Writes the given byte to the current position and increases the position
            by 1.
            </summary>
            <param name="b">the byte to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if position is equal or greater than limit.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Put(System.Byte[])">
            <summary>
            Writes bytes in the given byte array to the current position and
            increases the position by the number of bytes written.
            <para/>
            Calling this method has the same effect as
            <c>Put(src, 0, src.Length)</c>.
            </summary>
            <param name="src">the source byte array.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if <see cref="!:Remaining"/> is less than <c>src.Length</c>.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Put(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Writes bytes in the given byte array, starting from the specified offset,
            to the current position and increases the position by the number of bytes
            written.
            </summary>
            <param name="src">the source byte array.</param>
            <param name="off">
            the offset of byte array, must not be negative and not greater
            than <c>src.Length</c>.
            </param>
            <param name="len">
            the number of bytes to write, must not be negative and not
            greater than <c>src.Length - off</c>.
            </param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if <see cref="!:Remaining"/> is less than <paramref name="len"/>.</exception>
            <exception cref="T:System.IndexOutOfRangeException">if either <paramref name="off"/> or <paramref name="len"/> is invalid.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Put(Lucene.Net.Support.IO.ByteBuffer)">
            <summary>
            Writes all the remaining bytes of the <paramref name="src"/> byte buffer to this
            buffer's current position, and increases both buffers' position by the
            number of bytes copied.
            </summary>
            <param name="src">the source byte buffer.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if <c>src.Remaining</c> is greater than this buffer's <see cref="!:Remaining"/>.</exception>
            <exception cref="T:System.ArgumentException">if <paramref name="src"/> is this buffer.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Put(System.Int32,System.Byte)">
            <summary>
            Write a <see cref="T:System.Byte"/> to the specified index of this buffer without changing the
            position.
            </summary>
            <param name="index">the index, must not be negative and less than the limit.</param>
            <param name="b">the <see cref="T:System.Byte"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:System.IndexOutOfRangeException">if <paramref name="index"/> is invalid.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.PutChar(System.Char)">
            <summary>
            Writes the given <see cref="T:System.Char"/> to the current position and increases the position
            by 2.
            <para/>
            The <see cref="T:System.Char"/> is converted to bytes using the current byte order.
            </summary>
            <param name="value">the <see cref="T:System.Char"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if position is greater than <c>limit - 2</c>.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.IO.ByteBuffer.PutChar(System.Int32,System.Char)" -->
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.PutDouble(System.Double)">
            <summary>
            Writes the given <see cref="T:System.Double"/> to the current position and increases the position
            by 8.
            <para/>
            The <see cref="T:System.Double"/> is converted to bytes using the current byte order.
            </summary>
            <param name="value">the <see cref="T:System.Double"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if position is greater than <c>limit - 8</c>.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.IO.ByteBuffer.PutDouble(System.Int32,System.Double)" -->
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.PutSingle(System.Single)">
            <summary>
            Writes the given <see cref="T:System.Single"/> to the current position and increases the position
            by 4.
            <para/>
            The <see cref="T:System.Single"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putSingle() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Single"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if position is greater than <c>limit - 4</c>.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.IO.ByteBuffer.PutSingle(System.Int32,System.Single)" -->
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.PutInt32(System.Int32)">
            <summary>
            Writes the given <see cref="T:System.Int32"/> to the current position and increases the position by
            4.
            <para/>
            The <see cref="T:System.Int32"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putInt() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Int32"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if position is greater than <c>limit - 4</c>.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.IO.ByteBuffer.PutInt32(System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.PutInt64(System.Int64)">
            <summary>
            Writes the given <see cref="T:System.Int64"/> to the current position and increases the position
            by 8.
            <para/>
            The <see cref="T:System.Int64"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putLong() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Int64"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if position is greater than <c>limit - 8</c>.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.IO.ByteBuffer.PutInt64(System.Int32,System.Int64)" -->
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.PutInt16(System.Int16)">
            <summary>
            Writes the given <see cref="T:System.Int16"/> to the current position and increases the position
            by 2.
            <para/>
            The <see cref="T:System.Int16"/> is converted to bytes using the current byte order.
            <para/>
            NOTE: This was putShort() in the JDK
            </summary>
            <param name="value">the <see cref="T:System.Int16"/> to write.</param>
            <returns>this buffer.</returns>
            <exception cref="T:Lucene.Net.Support.IO.BufferOverflowException">if position is greater than <c>limit - 2</c>.</exception>
            <exception cref="T:Lucene.Net.Support.IO.ReadOnlyBufferException">if no changes may be made to the contents of this buffer.</exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Support.IO.ByteBuffer.PutInt16(System.Int32,System.Int16)" -->
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.Slice">
            <summary>
            Returns a sliced buffer that shares its content with this buffer.
            <para/>
            The sliced buffer's capacity will be this buffer's
            <see cref="!:Remaining"/>, and it's zero position will correspond to
            this buffer's current position. The new buffer's position will be 0,
            limit will be its capacity, and its mark is cleared. The new buffer's
            read-only property and byte order are the same as this buffer's.
            <para/>
            The new buffer shares its content with this buffer, which means either
            buffer's change of content will be visible to the other. The two buffer's
            position, limit and mark are independent.
            </summary>
            <returns>A sliced buffer that shares its content with this buffer.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteBuffer.ToString">
            <summary>
            Returns a string representing the state of this byte buffer.
            </summary>
            <returns>A string representing the state of this byte buffer.</returns>
        </member>
        <member name="T:Lucene.Net.Support.IO.ByteOrder">
            <summary>
            Defines byte order constants.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.ByteOrder.BIG_ENDIAN">
            <summary>
            This constant represents big endian.
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.ByteOrder.LITTLE_ENDIAN">
            <summary>
            This constant represents little endian.
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.IO.ByteOrder.NativeOrder">
            <summary>
            Returns the current platform byte order.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.ByteOrder.ToString">
            <summary>
            Returns a string that describes this object.
            </summary>
            <returns>
            "BIG_ENDIAN" for <see cref="F:Lucene.Net.Support.IO.ByteOrder.BIG_ENDIAN"/> objects,
            "LITTLE_ENDIAN" for <see cref="F:Lucene.Net.Support.IO.ByteOrder.LITTLE_ENDIAN"/> objects.
            </returns>
        </member>
        <member name="T:Lucene.Net.Support.IO.DataInputStream">
            <summary>
            Java's DataInputStream is similar to .NET's BinaryReader. However, it reads
            using a modified UTF-8 format that cannot be read using BinaryReader.
            This is a port of DataInputStream that is fully compatible with Java's DataOutputStream.
            <para>
            Usage Note: Always favor BinaryReader over DataInputStream unless you specifically need
            the modified UTF-8 format and/or the <see cref="!:ReadUTF(IDataInput)"/> method.
            </para>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Support.IO.DataInputStream"/> on the <see cref="T:System.IO.Stream"/> <paramref name="in"/>. All
            reads are then filtered through this stream. Note that data read by this
            stream is not in a human readable format and was most likely created by a
            <see cref="T:Lucene.Net.Support.IO.DataOutputStream"/>.
            </summary>
            <param name="in">the source <see cref="T:System.IO.Stream"/> the filter reads from.</param>
            <seealso cref="T:Lucene.Net.Support.IO.DataOutputStream"/>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.ReadSByte">
            <summary>
            NOTE: This was readByte() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.ReadSingle">
            <summary>
            NOTE: This was readFloat() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.ReadInt32">
            <summary>
            NOTE: This was readInt() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.ReadInt64">
            <summary>
            NOTE: This was readLong() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.ReadInt16">
            <summary>
            NOTE: This was readShort() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.ReadByte">
            <summary>
            NOTE: This was readUnsignedByte() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.ReadUInt16">
            <summary>
            NOTE: This was readUnsignedShort() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataInputStream.Skip(System.IO.Stream,System.Int32)">
            <summary>
            Helper method for SkipBytes, since Position and Seek do not work on
            non-seekable streams.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.DataOutputStream">
            <summary>
            Java's DataOutputStream is similar to .NET's BinaryWriter. However, it writes
            in a modified UTF-8 format that cannot be read (or duplicated) using BinaryWriter.
            This is a port of DataOutputStream that is fully compatible with Java's DataInputStream.
            <para>
            Usage Note: Always favor BinaryWriter over DataOutputStream unless you specifically need
            the modified UTF-8 format and/or the <see cref="!:WriteUTF(IDataOutput)"/> method.
            </para>
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.IO.DataOutputStream.written">
            <summary>
            The number of bytes written out so far.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataOutputStream.#ctor(System.IO.Stream)">
            <summary>
            Constructs a new <see cref="T:Lucene.Net.Support.IO.DataOutputStream"/> on the <see cref="T:System.IO.Stream"/>
            <paramref name="out"/>. Note that data written by this stream is not in a human
            readable form but can be reconstructed by using a <see cref="T:Lucene.Net.Support.IO.DataInputStream"/>
            on the resulting output.
            </summary>
            <param name="out">the target stream for writing.</param>
            <seealso cref="T:Lucene.Net.Support.IO.DataInputStream"/>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataOutputStream.WriteSingle(System.Single)">
            <summary>
            NOTE: This was writeFloat() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataOutputStream.WriteInt32(System.Int32)">
            <summary>
            NOTE: This was writeInt() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataOutputStream.WriteInt64(System.Int64)">
            <summary>
            NOTE: This was writeLong() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.DataOutputStream.WriteInt16(System.Int32)">
            <summary>
            NOTE: This was writeShort() in Java
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.FileSupport">
            <summary>
            Represents the methods to support some operations over files.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.GetFiles(System.IO.FileInfo)">
            <summary>
            Returns an array of abstract pathnames representing the files and directories of the specified path.
            </summary>
            <param name="path">The abstract pathname to list it childs.</param>
            <returns>An array of abstract pathnames childs of the path specified or null if the path is not a directory</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.Sync(System.IO.FileStream)">
            <summary>
            Flushes the specified file stream. Ensures that all buffered
            data is actually written to the file system.
            </summary>
            <param name="fileStream">The file stream.</param>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.CreateTempFile(System.String,System.String,System.IO.DirectoryInfo)">
            <summary>
            Creates a new empty file in the specified directory, using the given prefix and suffix strings to generate its name. 
            If this method returns successfully then it is guaranteed that:
            <list type="number">
            <item>The file denoted by the returned abstract pathname did not exist before this method was invoked, and</item>
            <item>Neither this method nor any of its variants will return the same abstract pathname again in the current invocation of the virtual machine.</item>
            </list>
            This method provides only part of a temporary-file facility.To arrange for a file created by this method to be deleted automatically, use the deleteOnExit() method.
            The prefix argument must be at least three characters long. It is recommended that the prefix be a short, meaningful string such as "hjb" or "mail". The suffix argument may be null, in which case the suffix ".tmp" will be used.
            To create the new file, the prefix and the suffix may first be adjusted to fit the limitations of the underlying platform.If the prefix is too long then it will be truncated, but its first three characters will always be preserved.If the suffix is too long then it too will be truncated, but if it begins with a period character ('.') then the period and the first three characters following it will always be preserved.Once these adjustments have been made the name of the new file will be generated by concatenating the prefix, five or more internally-generated characters, and the suffix.
            If the directory argument is null then the system-dependent default temporary-file directory will be used.The default temporary-file directory is specified by the system property java.io.tmpdir.On UNIX systems the default value of this property is typically "/tmp" or "/var/tmp"; on Microsoft Windows systems it is typically "C:\\WINNT\\TEMP". A different value may be given to this system property when the Java virtual machine is invoked, but programmatic changes to this property are not guaranteed to have any effect upon the temporary directory used by this method.
            
            Ported over from the java.io.File class. Used by the Analysis.Hunspell.Directory
            class, but this can probably be removed when that class is upgraded to a more recent
            version of lucene, where it uses the lucene Store.Directory class to create a temporary
            file.
            </summary>
            <param name="prefix">The prefix string to be used in generating the file's name; must be at least three characters long</param>
            <param name="suffix">The suffix string to be used in generating the file's name; may be null, in which case a random suffix will be generated</param>
            <param name="directory">The directory in which the file is to be created, or null if the default temporary-file directory is to be used</param>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.FileSupport.NewTempFileName(System.String,System.String,System.IO.DirectoryInfo)">
            <summary>
            Generates a new random file name with the provided <paramref name="directory"/>, 
            <paramref name="prefix"/> and optional <see cref="!:suffix"/>.
            </summary>
            <param name="prefix">The prefix string to be used in generating the file's name</param>
            <param name="suffix">The suffix string to be used in generating the file's name; may be null, in which case a random suffix will be generated</param>
            <param name="directory">A <see cref="T:System.IO.DirectoryInfo"/> object containing the temp directory path. Must not be null.</param>
            <returns>A random file name</returns>
        </member>
        <member name="T:Lucene.Net.Support.IO.HeapByteBuffer">
            <summary>
            HeapByteBuffer, ReadWriteHeapByteBuffer and ReadOnlyHeapByteBuffer compose
            the implementation of array based byte buffers.
            <para/>
            HeapByteBuffer implements all the shared readonly methods and is extended by
            the other two classes.
            <para/>
            All methods are sealed for runtime performance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.IDataInput">
            <summary>
            Equivalent to Java's DataInput interface
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataInput.ReadSByte">
            <summary>
            NOTE: This was readByte() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataInput.ReadByte">
            <summary>
            NOTE: This was readUnsignedByte() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataInput.ReadInt16">
            <summary>
            NOTE: This was readShort() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataInput.ReadUInt16">
            <summary>
            NOTE: This was readUnsignedShort() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataInput.ReadInt32">
            <summary>
            NOTE: This was readInt() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataInput.ReadInt64">
            <summary>
            NOTE: This was readLong() in Java
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.IDataOutput">
            <summary>
            Equivalent to Java's DataOutut interface
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataOutput.WriteSingle(System.Single)">
            <summary>
            NOTE: This was writeFloat() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataOutput.WriteInt32(System.Int32)">
            <summary>
            NOTE: This was writeInt() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataOutput.WriteInt64(System.Int64)">
            <summary>
            NOTE: This was writeInt64() in Java
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.IDataOutput.WriteInt16(System.Int32)">
            <summary>
            NOTE: This was writeShort() in Java
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.Int64ArrayBuffer">
            <summary>
            LongArrayBuffer, ReadWriteLongArrayBuffer and ReadOnlyLongArrayBuffer compose
            the implementation of array based long buffers.
            <para/>
            LongArrayBuffer implements all the shared readonly methods and is extended by
            the other two classes.
            <para/>
            All methods are marked final for runtime performance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.Int64Buffer">
            <summary>
            A buffer of longs.
            <para/>
            A long buffer can be created in either of the following ways:
            <list type="bullet">
                <item><see cref="M:Lucene.Net.Support.IO.Int64Buffer.Allocate(System.Int32)"/> a new long array and create a buffer
                based on it</item>
                <item><see cref="M:Lucene.Net.Support.IO.Int64Buffer.Wrap(System.Int64[])"/> an existing long array to create a new
                buffer</item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.Int64Buffer.Allocate(System.Int32)">
            <summary>
            Creates a long buffer based on a newly allocated long array.
            </summary>
            <param name="capacity">the capacity of the new buffer.</param>
            <returns>the created long buffer.</returns>
            <exception cref="T:System.ArgumentException">if <paramref name="capacity"/> is less than zero.</exception>
        </member>
        <member name="M:Lucene.Net.Support.IO.Int64Buffer.Wrap(System.Int64[])">
            <summary>
            Creates a new long buffer by wrapping the given long array.
            <para/>
            Calling this method has the same effect as
            <c>Wrap(array, 0, array.Length)</c>.
            </summary>
            <param name="array">the long array which the new buffer will be based on.</param>
            <returns>the created long buffer.</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.Int64Buffer.#ctor(System.Int32)">
            <summary>
            Constructs a <see cref="T:Lucene.Net.Support.IO.Int64Buffer"/> with given capacity.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.Int64ToByteBufferAdapter">
            <summary>
            This class wraps a byte buffer to be a long buffer.
            <para/>
            Implementation notice:
            <list type="bullet">
                <item>After a byte buffer instance is wrapped, it becomes privately owned by
                the adapter. It must NOT be accessed outside the adapter any more.</item>
                <item>The byte buffer's position and limit are NOT linked with the adapter.
                The adapter extends Buffer, thus has its own position and limit.</item>
            </list>
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetInt16">
            <summary>
            NOTE: This was getShort() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetInt16(System.Int32)">
            <summary>
            NOTE: This was getShort() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutInt16(System.Int16)">
            <summary>
            NOTE: This was putShort() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutInt16(System.Int32,System.Int16)">
            <summary>
            NOTE: This was putShort() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetInt32">
            <summary>
            NOTE: This was getInt() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetInt32(System.Int32)">
            <summary>
            NOTE: This was getInt() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutInt32(System.Int32)">
            <summary>
            NOTE: This was putInt() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutInt32(System.Int32,System.Int32)">
            <summary>
            NOTE: This was putInt() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetInt64">
            <summary>
            NOTE: This was getLong() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetInt64(System.Int32)">
            <summary>
            NOTE: This was getLong() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutInt64(System.Int64)">
            <summary>
            NOTE: This was putLong() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutInt64(System.Int32,System.Int64)">
            <summary>
            NOTE: This was putLong() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetSingle">
            <summary>
            NOTE: This was getFloat() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.GetSingle(System.Int32)">
            <summary>
            NOTE: This was getFloat() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutSingle(System.Single)">
            <summary>
            NOTE: This was putFloat() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.PutSingle(System.Int32,System.Single)">
            <summary>
            NOTE: This was putFloat() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.AsInt64Buffer">
            <summary>
            NOTE: This was asLongBuffer() in the JDK
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.NextGetIndex">
            <summary>
            Checks the current position against the limit, throwing a
            <see cref="T:Lucene.Net.Support.IO.BufferUnderflowException"/> if it is not smaller than the limit, and then
            increments the position.
            </summary>
            <returns>The current position value, before it is incremented</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.NextPutIndex">
            <summary>
            Checks the current position against the limit, throwing a <see cref="T:Lucene.Net.Support.IO.BufferOverflowException"/>
            if it is not smaller than the limit, and then
            increments the position.
            </summary>
            <returns>The current position value, before it is incremented</returns>
        </member>
        <member name="M:Lucene.Net.Support.IO.MemoryMappedFileByteBuffer.CheckIndex(System.Int32)">
            <summary>
            Checks the given index against the limit, throwing an <see cref="T:System.IndexOutOfRangeException"/> 
            if it is not smaller than the limit or is smaller than zero.
            </summary>
            <param name="i"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Support.IO.ReadOnlyHeapByteBuffer">
            <summary>
            HeapByteBuffer, ReadWriteHeapByteBuffer and ReadOnlyHeapByteBuffer compose
            the implementation of array based byte buffers.
            <para/>
            ReadOnlyHeapByteBuffer extends HeapByteBuffer with all the write methods
            throwing read only exception.
            <para/>
            This class is sealed final for runtime performance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.ReadWriteHeapByteBuffer">
            <summary>
            HeapByteBuffer, ReadWriteHeapByteBuffer and ReadOnlyHeapByteBuffer compose
            the implementation of array based byte buffers.
            <para/>
            ReadWriteHeapByteBuffer extends HeapByteBuffer with all the write methods.
            <para/>
            This class is marked sealed for runtime performance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.ReadWriteInt64ArrayBuffer">
            <summary>
            LongArrayBuffer, ReadWriteLongArrayBuffer and ReadOnlyLongArrayBuffer compose
            the implementation of array based long buffers.
            <para/>
            ReadWriteLongArrayBuffer extends LongArrayBuffer with all the write methods.
            <para/>
            This class is marked final for runtime performance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.IO.SafeTextWriterWrapper">
            <summary>
            Decorates a <see cref="T:System.IO.TextWriter"/> instance and
            makes no assumptions about whether <see cref="M:System.IDisposable.Dispose"/>
            has been called on the inner instance or not. Acts like a circuit breaker -
            the first <see cref="T:System.ObjectDisposedException"/> caught turns it off and
            the rest of the calls are ignored after that point until <see cref="M:Lucene.Net.Support.IO.SafeTextWriterWrapper.Reset"/>
            is called.
            <para/>
            The primary purpose is for using a <see cref="T:System.IO.TextWriter"/> instance within a non-disposable
            parent object. Since the creator of the <see cref="T:System.IO.TextWriter"/> ultimately is responsible for
            disposing it, our non-disposable object has no way of knowing whether it is safe to use the <see cref="T:System.IO.TextWriter"/>.
            Wraping the <see cref="T:System.IO.TextWriter"/> within a <see cref="T:Lucene.Net.Support.IO.SafeTextWriterWrapper"/> ensures the
            non-disposable object can continue to make calls to the <see cref="T:System.IO.TextWriter"/> without raising
            exceptions (it is presumed that the <see cref="T:System.IO.TextWriter"/> functionality is optional).
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Threading.DisposableThreadLocalProfiler">
            <summary>
            For Debuging purposes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Threading.IThreadRunnable">
            <summary>
            this interface should be implemented by any class whose instances are intended
            to be executed by a thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.IThreadRunnable.Run">
            <summary>
            this method has to be implemented in order that starting of the thread causes the object's
            run method to be called in that separately executing thread.
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Threading.LimitedConcurrencyLevelTaskScheduler">
            <summary>
            Provides a task scheduler that ensures a maximum concurrency level while 
            running on top of the thread pool.
            
            Source: https://msdn.microsoft.com/en-us/library/system.threading.tasks.taskscheduler(v=vs.110).aspx
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Threading.ReaderWriterLockSlimExtensions">
            <summary>
            Extensions to help obtain/release from a ReaderWriterSlimLock.
            Taken from:
            http://stackoverflow.com/questions/170028/how-would-you-simplify-entering-and-exiting-a-readerwriterlock
            
            LUCENENET specific
            </summary>
        </member>
        <member name="T:Lucene.Net.Support.Threading.ThreadClass">
            <summary>
            Support class used to handle threads
            </summary>
        </member>
        <member name="F:Lucene.Net.Support.Threading.ThreadClass._threadField">
            <summary>
            The instance of System.Threading.Thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.#ctor">
            <summary>
            Initializes a new instance of the ThreadClass class
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.#ctor(System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="name">The name of the thread</param>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.#ctor(System.Threading.ThreadStart)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.#ctor(System.Threading.ThreadStart,System.String)">
            <summary>
            Initializes a new instance of the Thread class.
            </summary>
            <param name="start">A ThreadStart delegate that references the methods to be invoked when this thread begins executing</param>
            <param name="name">The name of the thread</param>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Run">
            <summary>
            This method has no functionality unless the method is overridden
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Start">
            <summary>
            Causes the operating system to change the state of the current thread instance to ThreadState.Running
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Interrupt">
            <summary>
            Interrupts a thread that is in the WaitSleepJoin thread state
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.Threading.ThreadClass.Instance">
            <summary>
            Gets the current thread instance
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.Threading.ThreadClass.Name">
            <summary>
            Gets or sets the name of the thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.Threading.ThreadClass.Priority">
            <summary>
            Gets or sets a value indicating the scheduling priority of a thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.Threading.ThreadClass.IsAlive">
            <summary>
            Gets a value indicating the execution status of the current thread
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.Threading.ThreadClass.IsBackground">
            <summary>
            Gets or sets a value indicating whether or not a thread is a background thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Join">
            <summary>
            Blocks the calling thread until a thread terminates
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Join(System.Int64)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="milliSeconds">Time of wait in milliseconds</param>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Join(System.Int64,System.Int32)">
            <summary>
            Blocks the calling thread until a thread terminates or the specified time elapses
            </summary>
            <param name="milliSeconds">Time of wait in milliseconds</param>
            <param name="nanoSeconds">Time of wait in nanoseconds</param>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Resume">
            <summary>
            Resumes a thread that has been suspended
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Abort">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread. Calling this method
            usually terminates the thread
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Abort(System.Object)">
            <summary>
            Raises a ThreadAbortException in the thread on which it is invoked,
            to begin the process of terminating the thread while also providing
            exception information about the thread termination.
            Calling this method usually terminates the thread.
            </summary>
            <param name="stateInfo">An object that contains application-specific information, such as state, which can be used by the thread being aborted</param>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Suspend">
            <summary>
            Suspends the thread, if the thread is already suspended it has no effect
            </summary>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.ToString">
            <summary>
            Obtain a String that represents the current object
            </summary>
            <returns>A String that represents the current object</returns>
        </member>
        <member name="M:Lucene.Net.Support.Threading.ThreadClass.Current">
            <summary>
            Gets the currently running thread
            </summary>
            <returns>The currently running thread</returns>
        </member>
        <member name="T:Lucene.Net.Support.Threading.ThreadLock">
            <summary>
            Abstract base class that provides a synchronization interface
            for derived lock types
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.Threading.ThreadLock.NullLock">
            <summary>
            A ThreadLock class that actually does no locking
            Used in ParallelMultiSearcher/MultiSearcher
            </summary>
        </member>
        <member name="P:Lucene.Net.Support.Threading.ThreadLock.MonitorLock">
            <summary>
            Wrapper class for the Monitor Enter/Exit methods
            using the <see cref="T:Lucene.Net.Support.Threading.ThreadLock"/> interface
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.GetHashCode``1(System.Collections.Generic.IList{``0})">
            <summary>
            The same implementation of GetHashCode from Java's AbstractList
            (the default implementation for all lists).
            <para/>
            This algorithm depends on the order of the items in the list.
            It is recursive and will build the hash code based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.GetHashCode``1(System.Collections.Generic.ISet{``0})">
            <summary>
            The same implementation of GetHashCode from Java's AbstractSet
            (the default implementation for all sets)
            <para/>
            This algorithm does not depend on the order of the items in the set.
            It is recursive and will build the hash code based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.GetHashCode``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            The same implementation of GetHashCode from Java's AbstractMap
            (the default implementation for all dictionaries)
            <para/>
            This algoritm does not depend on the order of the items in the dictionary.
            It is recursive and will build the hash code based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.GetHashCode(System.Object)">
            <summary>
            This method generally assists with the recursive GetHashCode() that
            builds a hash code based on all of the values in a collection 
            including any nested collections (lists, sets, arrays, and dictionaries).
            <para/>
            Note this currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
            <param name="obj">the object to build the hash code for</param>
            <returns>a value that represents the unique state of all of the values and 
            nested collection values in the object, provided the main object itself is 
            a collection, otherwise calls <see cref="M:System.Object.GetHashCode"/> on the 
            object that is passed.</returns>
        </member>
        <member name="M:Lucene.Net.Collections.Equals``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            The same implementation of Equals from Java's AbstractList
            (the default implementation for all lists)
            <para/>
            This algorithm depends on the order of the items in the list. 
            It is recursive and will determine equality based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.Equals``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0})">
            <summary>
            The same implementation of Equals from Java's AbstractSet
            (the default implementation for all sets)
            <para/>
            This algoritm does not depend on the order of the items in the set.
            It is recursive and will determine equality based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.Equals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            This is the same implemenation of Equals from Java's AbstractMap
            (the default implementation of all dictionaries)
            <para/>
            This algoritm does not depend on the order of the items in the dictionary.
            It is recursive and will determine equality based on the values of
            all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.Equals(System.Object,System.Object)">
            <summary>
            A helper method to recursively determine equality based on
            the values of the collection and all nested collections.
            <para/>
            Note this operation currently only supports <see cref="T:System.Collections.Generic.IList`1"/>, <see cref="T:System.Collections.Generic.ISet`1"/>, 
            and <see cref="T:System.Collections.Generic.IDictionary`2"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.ToString``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists)
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.ToString``1(System.Collections.Generic.ICollection{``0},System.Globalization.CultureInfo)">
            <summary>
            This is the same implementation of ToString from Java's AbstractCollection
            (the default implementation for all sets and lists), plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.ToString``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            This is the same implementation of ToString from Java's AbstractMap
            (the default implementation for all dictionaries)
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.ToString``2(System.Collections.Generic.IDictionary{``0,``1},System.Globalization.CultureInfo)">
            <summary>
            This is the same implementation of ToString from Java's AbstractMap
            (the default implementation for all dictionaries), plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.ToString(System.Object)">
            <summary>
            This is a helper method that assists with recursively building
            a string of the current collection and all nested collections.
            </summary>
        </member>
        <member name="M:Lucene.Net.Collections.ToString(System.Object,System.Globalization.CultureInfo)">
            <summary>
            This is a helper method that assists with recursively building
            a string of the current collection and all nested collections, plus the ability
            to specify culture for formatting of nested numbers and dates. Note that
            this overload will change the culture of the current thread.
            </summary>
        </member>
        <member name="F:Lucene.Net.Collections.ReverseComparer2`1.cmp">
             The comparer specified in the static factory.  This will never
             be null, as the static factory returns a ReverseComparer
             instance if its argument is null.
            
             @serial
        </member>
        <member name="T:Lucene.Net.Util.ExcludeServiceAttribute">
            <summary>
            Base class for <see cref="T:Lucene.Net.Util.Attribute"/> types that exclude services from Reflection scanning.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IServiceListable">
            <summary>
            LUCENENET specific contract that provides support for <see cref="M:Lucene.Net.Codecs.Codec.AvailableCodecs"/>, 
            <see cref="M:Lucene.Net.Codecs.DocValuesFormat.AvailableDocValuesFormats"/>, 
            and <see cref="M:Lucene.Net.Codecs.PostingsFormat.AvailablePostingsFormats"/>. Implement this
            interface in addition to <see cref="T:Lucene.Net.Codecs.ICodecFactory"/>, <see cref="T:Lucene.Net.Codecs.IDocValuesFormatFactory"/>,
            or <see cref="T:Lucene.Net.Codecs.IPostingsFormatFactory"/> to provide optional support for the above
            methods when providing a custom implementation. If this interface is not supported by
            the corresponding factory, a <see cref="T:System.NotSupportedException"/> will be thrown from the above methods.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IServiceListable.AvailableServices">
            <summary>
            Lists the available services for the current service type.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Util.NamedServiceFactory`1">
            <summary>
            LUCENENET specific abstract class containing common fuctionality for named service factories.
            </summary>
            <typeparam name="TService">The type of service this factory applies to.</typeparam>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.EnsureInitialized">
            <summary>
            Ensures the <see cref="M:Lucene.Net.Util.NamedServiceFactory`1.Initialize"/> method has been called since the
            last application start. This method is thread-safe.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.Initialize">
            <summary>
            Initializes the dependencies of this factory (such as using Reflection to populate the type cache).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.NamedServiceFactory`1.CodecsAssembly">
            <summary>
            The Lucene.Net.Codecs assembly or <c>null</c> if the assembly is not referenced
            in the host project.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.IsServiceType(System.Type)">
            <summary>
            Determines whether the given type is corresponding service for this class,
            based on its generic closing type <typeparamref name="TService"/>.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> of service to analyze.</param>
            <returns><c>true</c> if the service subclasses <typeparamref name="TService"/>, is public, and is not abstract; otherwise <c>false</c>.</returns>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.GetServiceName(System.Type)">
            <summary>
            Get the service name for the class (either by convention or by attribute).
            </summary>
            <param name="type">A service to get the name for.</param>
            <returns>The canonical name of the service or the name provided in the corresponding name attribute, if supplied.</returns>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.GetCanonicalName(System.Type)">
            <summary>
            Gets the type name without the suffix of the abstract base class it implements.
            If the class is generic, it will add the word "Generic" to the suffix in place of "`"
            to ensure the name is ASCII-only.
            </summary>
            <param name="type">The <see cref="T:System.Type"/> to get the name for.</param>
            <returns>The canonical name of the service.</returns>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.CheckServiceName(System.String)">
            <summary>
            Validates that a service name meets the requirements of Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NamedServiceFactory`1.IsLetterOrDigit(System.Char)">
            <summary>
            Checks whether a character is a letter or digit (ascii) which are defined in the spec.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.NamedServiceFactory`1.IsFullyTrusted">
            <summary>
            Gets a value that indicates whether the current application domain executes with full trust.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ServiceNameAttribute">
            <summary>
            LUCENENET specific abstract class for <see cref="T:System.Attribute"/>s that can
            be used to override the default convention-based names of services. For example,
            "Lucene40Codec" will by convention be named "Lucene40". Using the <see cref="T:Lucene.Net.Codecs.CodecNameAttribute"/>,
            the name can be overridden with a custom value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ServiceNameAttribute.#ctor(System.String)">
            <summary>
            Sole constructor. Initializes the service name.
            </summary>
            <param name="name"></param>
        </member>
        <member name="P:Lucene.Net.Util.ServiceNameAttribute.Name">
            <summary>
            Gets the service name.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IAccountable">
            <summary>
            An object whose RAM usage can be computed.
            
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IAccountable.RamBytesUsed">
            <summary>
            Return the memory usage of this object in bytes. Negative values are illegal.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayInPlaceMergeSorter`1">
            <summary>
            An <seealso cref="T:Lucene.Net.Util.InPlaceMergeSorter"/> for object arrays.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayInPlaceMergeSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new <seealso cref="!:ArrayInPlaceMergeSorter"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayIntroSorter`1">
            <summary>
            An <seealso cref="T:Lucene.Net.Util.IntroSorter"/> for object arrays.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayIntroSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0})">
            <summary>
            Create a new <seealso cref="!:ArrayInPlaceMergeSorter"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayTimSorter`1">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.TimSorter"/> for object arrays.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayTimSorter`1.#ctor(`0[],System.Collections.Generic.IComparer{`0},System.Int32)">
            <summary>
            Create a new <seealso cref="!:ArrayTimSorter"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ArrayUtil">
             <summary>
             Methods for manipulating arrays.
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.ArrayUtil.MAX_ARRAY_LENGTH">
            <summary>
            Maximum length for an array; we set this to "a
             bit" below <see cref="F:System.Int32.MaxValue"/> because the exact max
             allowed byte[] is JVM dependent, so we want to avoid
             a case where a large value worked during indexing on
             one JVM but failed later at search time with a
             different JVM.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt32(System.Char[])">
            <summary>
            Parses the string argument as if it was an int value and returns the
            result. Throws NumberFormatException if the string does not represent an
            int quantity.
            <para/>
            NOTE: This was parseInt() in Lucene
            </summary>
            <param name="chars"> a string representation of an int quantity. </param>
            <returns> int the value represented by the argument </returns>
            <exception cref="!:NumberFormatException"> if the argument could not be parsed as an int quantity. </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt32(System.Char[],System.Int32,System.Int32)">
            <summary>
            Parses a char array into an int. 
            <para/>
            NOTE: This was parseInt() in Lucene
            </summary>
            <param name="chars"> the character array </param>
            <param name="offset"> The offset into the array </param>
            <param name="len"> The length </param>
            <returns> the int </returns>
            <exception cref="!:NumberFormatException"> if it can't parse </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.ParseInt32(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Parses the string argument as if it was an int value and returns the
            result. Throws NumberFormatException if the string does not represent an
            int quantity. The second argument specifies the radix to use when parsing
            the value.
            <para/>
            NOTE: This was parseInt() in Lucene
            </summary>
            <param name="chars"> a string representation of an int quantity. </param>
            <param name="radix"> the base to use for conversion. </param>
            <returns> int the value represented by the argument </returns>
            <exception cref="!:NumberFormatException"> if the argument could not be parsed as an int quantity. </exception>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Oversize(System.Int32,System.Int32)">
             <summary>
             Returns an array size >= minTargetSize, generally
              over-allocating exponentially to achieve amortized
              linear-time cost as the array grows.
            
              NOTE: this was originally borrowed from Python 2.4.2
              listobject.c sources (attribution in LICENSE.txt), but
              has now been substantially changed based on
              discussions from java-dev thread with subject "Dynamic
              array reallocation algorithms", started on Jan 12
              2010.
             </summary>
             <param name="minTargetSize"> Minimum required value to be returned. </param>
             <param name="bytesPerElement"> Bytes used by each element of
             the array.  See constants in <seealso cref="T:Lucene.Net.Util.RamUsageEstimator"/>.
            
             @lucene.internal </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns hash of chars in range start (inclusive) to
            end (inclusive)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetHashCode(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns hash of bytes in range start (inclusive) to
            end (inclusive)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.ArrayUtil.Equals(System.Char[],System.Int32,System.Char[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.ArrayUtil.Equals(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.ArrayUtil.Equals(System.Int32[],System.Int32,System.Int32[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.ArrayUtil.ToInt32Array(System.Collections.Generic.ICollection{System.Nullable{System.Int32}})">
            <summary>
            NOTE: This was toIntArray() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.GetNaturalComparer``1">
            <summary>
            Get the natural <seealso cref="!:Comparer"/> for the provided object class.
            <para/>
            The comparer returned depends on the <typeparam name="T"/> argument:
            <list type="number">
                <item>If the type is <see cref="T:System.String"/>, the comparer returned uses
                    the <see cref="M:System.String.CompareOrdinal(System.String,System.String)"/> to make the comparison
                    to ensure that the current culture doesn't affect the results. This is the
                    default string comparison used in Java, and what Lucene's design depends on.</item>
                <item>If the type implements <see cref="T:System.IComparable`1"/>, the comparer uses
                    <see cref="M:System.IComparable`1.CompareTo(`0)"/> for the comparison. This allows
                    the use of types with custom comparison schemes.</item>
                <item>If neither of the above conditions are true, will default to <see cref="P:System.Collections.Generic.Comparer`1.Default"/>.</item>
            </list>
            <para/>
            NOTE: This was naturalComparer() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.Swap``1(``0[],System.Int32,System.Int32)">
            <summary>
            Swap values stored in slots <code>i</code> and <code>j</code> </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array slice using the <seealso cref="!:Comparer"/>. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array using the <seealso cref="!:Comparer"/>. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the given array slice in natural order. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.IntroSort``1(``0[])">
            <summary>
            Sorts the given array in natural order. this method uses the intro sort
            algorithm, but falls back to insertion sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Int32,System.Int32,System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array slice using the <seealso cref="!:Comparer"/>. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given array using the <seealso cref="!:Comparer"/>. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[],System.Int32,System.Int32)">
            <summary>
            Sorts the given array slice in natural order. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays. </summary>
            <param name="fromIndex"> start index (inclusive) </param>
            <param name="toIndex"> end index (exclusive) </param>
        </member>
        <member name="M:Lucene.Net.Util.ArrayUtil.TimSort``1(``0[])">
            <summary>
            Sorts the given array in natural order. this method uses the Tim sort
            algorithm, but falls back to binary sort for small arrays.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IAttribute">
            <summary> Base interface for attributes.</summary>
        </member>
        <member name="T:Lucene.Net.Util.Attribute">
            <summary> Base class for Attributes that can be added to a
            <see cref="T:Lucene.Net.Util.AttributeSource" />.
            <p/>
            Attributes are used to add data in a dynamic, yet type-safe way to a source
            of usually streamed objects, e. g. a <see cref="T:Lucene.Net.Analysis.TokenStream" />.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.Clear">
            <summary> Clears the values in this Attribute and resets it to its
            default value. If this implementation implements more than one Attribute interface
            it clears all.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Attribute.StringBuilderAttributeReflector">
            <summary>
            This is equivalent to the anonymous class in the java version of ReflectAsString
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.ToString">
             <summary> The default implementation of this method accesses all declared
             fields of this object and prints the values in the following syntax:
            
             <code>
             public String toString() {
             return "start=" + startOffset + ",end=" + endOffset;
             }
             </code>
            
             This method may be overridden by subclasses.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.CopyTo(Lucene.Net.Util.IAttribute)">
            <summary> Copies the values from this Attribute into the passed-in
            target attribute. The target implementation must support all the
            Attributes this implementation supports.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Attribute.Clone">
            <summary> Shallow clone. Subclasses must override this if they
            need to clone any members deeply,
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.AttributeSource">
            <summary>
            An AttributeSource contains a list of different <seealso cref="T:Lucene.Net.Util.Attribute"/>s,
            and methods to add and get them. There can only be a single instance
            of an attribute in the same AttributeSource instance. this is ensured
            by passing in the actual type of the Attribute (Class&lt;Attribute&gt;) to
            the <seealso cref="!:#addAttribute(Class)"/>, which then checks if an instance of
            that type is already present. If yes, it returns the instance, otherwise
            it creates a new instance and returns it.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.AttributeSource.AttributeFactory">
            <summary>
            An AttributeFactory creates instances of <seealso cref="T:Lucene.Net.Util.Attribute"/>s.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.AttributeFactory.CreateAttributeInstance``1">
            <summary>
            returns an <seealso cref="T:Lucene.Net.Util.Attribute"/> for the supplied <seealso cref="T:Lucene.Net.Util.Attribute"/> interface class.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.AttributeSource.AttributeFactory.DEFAULT_ATTRIBUTE_FACTORY">
            <summary>
            this is the default factory that creates <seealso cref="T:Lucene.Net.Util.Attribute"/>s using the
            class name of the supplied <seealso cref="T:Lucene.Net.Util.Attribute"/> interface class by appending <code>Impl</code> to it.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.AttributeSource.State" -->
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor">
            <summary>
            An AttributeSource using the default attribute factory <seealso cref="!:AttributeSource.AttributeFactory#DEFAULT_ATTRIBUTE_FACTORY"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor(Lucene.Net.Util.AttributeSource)">
            <summary>
            An AttributeSource that uses the same attributes as the supplied one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.#ctor(Lucene.Net.Util.AttributeSource.AttributeFactory)">
            <summary>
            An AttributeSource using the supplied <seealso cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/> for creating new <seealso cref="T:Lucene.Net.Util.Attribute"/> instances.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttributeFactory">
            <summary>
            returns the used AttributeFactory.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttributeClassesEnumerator">
            <summary>
            Returns a new iterator that iterates the attribute classes
            in the same order they were added in.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttributeImplsEnumerator">
            <summary>
            Returns a new iterator that iterates all unique Attribute implementations.
            this iterator may contain less entries that <seealso cref="!:#getAttributeClassesIterator"/>,
            if one instance implements more than one Attribute interface.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.AttributeSource.knownImplClasses">
            <summary>
            a cache that stores all interfaces for known implementation classes for performance (slow reflection) </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.AddAttributeImpl(Lucene.Net.Util.Attribute)">
            <summary>
            <b>Expert:</b> Adds a custom Attribute instance with one or more Attribute interfaces.
            <p><font color="red"><b>Please note:</b> It is not guaranteed, that <code>att</code> is added to
            the <code>AttributeSource</code>, because the provided attributes may already exist.
            You should always retrieve the wanted attributes using <seealso cref="!:#getAttribute"/> after adding
            with this method and cast to your class.
            The recommended way to use custom implementations is using an <seealso cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            </font></p>
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.AttributeSource.HasAttributes">
            <summary>
            Returns true, iff this AttributeSource has any attributes </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.HasAttribute``1">
            <summary>
            The caller must pass in a Class&lt;? extends Attribute&gt; value.
            Returns true, iff this AttributeSource contains the passed-in Attribute.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.GetAttribute``1">
            <summary>
            The caller must pass in a Class&lt;? extends Attribute&gt; value.
            Returns the instance of the passed in Attribute contained in this AttributeSource
            </summary>
            <exception cref="!:IllegalArgumentException"> if this AttributeSource does not contain the
                    Attribute. It is recommended to always use <seealso cref="!:#addAttribute"/> even in consumers
                    of TokenStreams, because you cannot know if a specific TokenStream really uses
                    a specific Attribute. <seealso cref="!:#addAttribute"/> will automatically make the attribute
                    available. If you want to only use the attribute, if it is available (to optimize
                    consuming), use <seealso cref="!:#HasAttribute"/>. </exception>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.ClearAttributes">
            <summary>
            Resets all Attributes in this AttributeSource by calling
            <seealso cref="!:Attribute#clear()"/> on each Attribute implementation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.CaptureState">
            <summary>
            Captures the state of all Attributes. The return value can be passed to
            <seealso cref="!:#restoreState"/> to restore the state of this or another AttributeSource.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.RestoreState(Lucene.Net.Util.AttributeSource.State)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.ReflectAsString(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.ReflectWith(Lucene.Net.Util.IAttributeReflector)" -->
        <member name="M:Lucene.Net.Util.AttributeSource.CloneAttributes">
            <summary>
            Performs a clone of all <seealso cref="T:Lucene.Net.Util.Attribute"/> instances returned in a new
            {@code AttributeSource} instance. this method can be used to e.g. create another TokenStream
            with exactly the same attributes (using <seealso cref="!:#AttributeSource(AttributeSource)"/>).
            You can also use it as a (non-performant) replacement for <seealso cref="!:#captureState"/>, if you need to look
            into / modify the captured state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.AttributeSource.CopyTo(Lucene.Net.Util.AttributeSource)">
            <summary>
            Copies the contents of this {@code AttributeSource} to the given target {@code AttributeSource}.
            The given instance has to provide all <seealso cref="T:Lucene.Net.Util.Attribute"/>s this instance contains.
            The actual attribute implementations must be identical in both {@code AttributeSource} instances;
            ideally both AttributeSource instances should use the same <seealso cref="T:Lucene.Net.Util.AttributeSource.AttributeFactory"/>.
            You can use this method as a replacement for <seealso cref="!:#restoreState"/>, if you use
            <seealso cref="!:#cloneAttributes"/> instead of <seealso cref="!:#captureState"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.AttributeSource.ToString" -->
        <member name="T:Lucene.Net.Util.IBits">
            <summary>
            Interface for Bitset-like structures.
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IBits.Get(System.Int32)">
            <summary>
            Returns the value of the bit with the specified <code>index</code>.
            </summary>
            <param name="index"> index, should be non-negative and &lt; <seealso cref="!:#length()"/>.
                   The result of passing negative or out of bounds values is undefined
                   by this interface, <b>just don't do it!</b> </param>
            <returns> <code>true</code> if the bit is set, <code>false</code> otherwise. </returns>
        </member>
        <member name="P:Lucene.Net.Util.IBits.Length">
            <summary>
            Returns the number of bits in this set </summary>
        </member>
        <member name="T:Lucene.Net.Util.Bits.MatchAllBits">
            <summary>
            Bits impl of the specified length with all bits set.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Bits.MatchNoBits">
            <summary>
            Bits impl of the specified length with no bits set.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BitUtil">
            <summary>
             A variety of high efficiency bit twiddling routines.
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.BitUtil.BIT_LISTS" -->
        <member name="M:Lucene.Net.Util.BitUtil.BitCount(System.Byte)">
            <summary>
            Return the number of bits sets in b. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BitUtil.BitList(System.Byte)" -->
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Array(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the number of set bits in an array of longs. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Intersect(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of the two sets after an intersection.
             Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Union(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of the union of two sets.
             Neither array is modified.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BitUtil.Pop_AndNot(System.Int64[],System.Int64[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.BitUtil.Pop_Xor(System.Int64[],System.Int64[],System.Int32,System.Int32)">
            <summary>
            Returns the popcount or cardinality of A ^ B
            Neither array is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.NextHighestPowerOfTwo(System.Int32)">
            <summary>
            returns the next highest power of two, or the current value if it's already a power of two or zero </summary>
        </member>
        <member name="M:Lucene.Net.Util.BitUtil.NextHighestPowerOfTwo(System.Int64)">
            <summary>
            returns the next highest power of two, or the current value if it's already a power of two or zero </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.BroadWord" -->
        <member name="M:Lucene.Net.Util.BroadWord.BitCount(System.Int64)">
            <summary>
            Bit count of a long.
            Only here to compare the implementation with <seealso cref="!:#select(long,int)"/>,
            normally <seealso cref="!:Long#bitCount"/> is preferable. </summary>
            <returns> The total number of 1 bits in x. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.Select(System.Int64,System.Int32)">
            <summary>
            Select a 1-bit from a long. </summary>
            <returns> The index of the r-th 1 bit in x, or if no such bit exists, 72. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BroadWord.SmallerUpTo7_8(System.Int64,System.Int64)" -->
        <member name="M:Lucene.Net.Util.BroadWord.Smalleru_8(System.Int64,System.Int64)">
            <summary>
            An unsigned bytewise smaller &lt;<sub><small>8</small></sub> operator.
            this uses the following numbers of basic long operations: 3 or, 2 and, 2 xor, 1 minus, 1 not. </summary>
            <returns> A long with bits set in the <seealso cref="!:#H8_L"/> positions corresponding to each input unsigned byte pair that compares smaller. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.NotEquals0_8(System.Int64)">
            <summary>
            An unsigned bytewise not equals 0 operator.
            this uses the following numbers of basic long operations: 2 or, 1 and, 1 minus. </summary>
            <returns> A long with bits set in the <seealso cref="!:#H8_L"/> positions corresponding to each unsigned byte that does not equal 0. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BroadWord.SmallerUpto15_16(System.Int64,System.Int64)">
            <summary>
            A bytewise smaller &lt;<sub><small>16</small></sub> operator.
            this uses the following numbers of basic long operations: 1 or, 2 and, 2 xor, 1 minus, 1 not. </summary>
            <returns> A long with bits set in the <seealso cref="!:#H16_L"/> positions corresponding to each input signed short pair that compares smaller. </returns>
        </member>
        <member name="F:Lucene.Net.Util.BroadWord.L8_L">
            <summary>
            Lk denotes the constant whose ones are in position 0, k, 2k, . . .
             These contain the low bit of each group of k bits.
             The suffix _L indicates the long implementation.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.BroadWord.H8_L" -->
        <member name="M:Lucene.Net.Util.BroadWord.SelectNaive(System.Int64,System.Int32)">
            <summary>
            Naive implementation of <seealso cref="!:#select(long,int)"/>, using <seealso cref="!:Long#numberOfTrailingZeros"/> repetitively.
            Works relatively fast for low ranks. </summary>
            <returns> The index of the r-th 1 bit in x, or if no such bit exists, 72. </returns>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool">
             <summary>
             Class that Posting and PostingVector use to write byte
             streams into shared fixed-size byte[] arrays.  The idea
             is to allocate slices of increasing lengths For
             example, the first slice is 5 bytes, the next slice is
             14, etc.  We start by writing our bytes into the first
             5 bytes.  When we hit the end of the slice, we allocate
             the next slice and then write the address of the new
             slice into the last 4 bytes of the previous slice (the
             "forwarding address").
            
             Each slice is filled with 0's initially, and we mark
             the end with a non-zero byte.  this way the methods
             that are writing into the slice don't need to record
             its length and instead allocate a new slice once they
             hit a non-zero byte.
            
             @lucene.internal
            
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.Allocator">
            <summary>
            Abstract class for allocating and freeing byte
             blocks.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.DirectAllocator">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> that never recycles. </summary>
        </member>
        <member name="T:Lucene.Net.Util.ByteBlockPool.DirectTrackingAllocator">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> that never recycles, but
             tracks how much total RAM is in use.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.Buffers">
            <summary>
            array of buffers currently used in the pool. Buffers are allocated if
            needed don't modify this outside of this class.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.bufferUpto">
            <summary>
            index into the buffers array pointing to the current buffer used as the head </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.ByteUpto">
            <summary>
            Where we are in head buffer </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.Buffer">
            <summary>
            Current head buffer
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.ByteBlockPool.ByteOffset">
            <summary>
            Current head offset </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Reset">
            <summary>
            Resets the pool to its initial state reusing the first buffer and fills all
            buffers with <tt>0</tt> bytes before they reused or passed to
            <seealso cref="!:Allocator#recycleByteBlocks(byte[][], int, int)"/>. Calling
            <seealso cref="!:ByteBlockPool#nextBuffer()"/> is not needed after reset.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Reset(System.Boolean,System.Boolean)">
            <summary>
            Expert: Resets the pool to its initial state reusing the first buffer. Calling
            <seealso cref="!:ByteBlockPool#nextBuffer()"/> is not needed after reset. </summary>
            <param name="zeroFillBuffers"> if <code>true</code> the buffers are filled with <tt>0</tt>.
                   this should be set to <code>true</code> if this pool is used with slices. </param>
            <param name="reuseFirst"> if <code>true</code> the first buffer will be reused and calling
                   <seealso cref="!:ByteBlockPool#nextBuffer()"/> is not needed after reset iff the
                   block pool was used before ie. <seealso cref="!:ByteBlockPool#nextBuffer()"/> was called before. </param>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.NextBuffer">
            <summary>
            Advances the pool to its next buffer. this method should be called once
            after the constructor to initialize the pool. In contrast to the
            constructor a <seealso cref="!:ByteBlockPool#reset()"/> call will advance the pool to
            its first buffer immediately.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.NewSlice(System.Int32)">
            <summary>
            Allocates a new slice with the given size.</summary>
            <seealso>ByteBlockPool#FIRST_LEVEL_SIZE</seealso>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.NEXT_LEVEL_ARRAY">
            <summary>
            An array holding the offset into the <seealso cref="!:ByteBlockPool#LEVEL_SIZE_ARRAY"/>
            to quickly navigate to the next slice level.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.ByteBlockPool.LEVEL_SIZE_ARRAY">
            <summary>
            An array holding the level sizes for byte slices.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.ByteBlockPool.FIRST_LEVEL_SIZE" -->
        <member name="M:Lucene.Net.Util.ByteBlockPool.AllocSlice(System.Byte[],System.Int32)">
            <summary>
            Creates a new byte slice with the given starting size and
            returns the slices offset in the pool.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.Append(Lucene.Net.Util.BytesRef)">
            <summary>
            Appends the bytes in the provided <seealso cref="T:Lucene.Net.Util.BytesRef"/> at
            the current position.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ByteBlockPool.ReadBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Reads bytes bytes out of the pool starting at the given offset with the given
            length into the given byte array at offset <tt>off</tt>.
            <p>Note: this method allows to copy across block boundaries.</p>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.BytesRef" -->
        <member name="F:Lucene.Net.Util.BytesRef.EMPTY_BYTES">
            <summary>
            An empty byte array for convenience </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Bytes">
            <summary>
            The contents of the BytesRef. Should never be {@code null}.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Offset">
            <summary>
            Offset of first valid byte.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.Length">
            <summary>
            Length of used bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor">
            <summary>
            Create a BytesRef with <seealso cref="!:#EMPTY_BYTES"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            this instance will directly reference bytes w/o making a copy.
            bytes should not be null.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Byte[])">
            <summary>
            this instance will directly reference bytes w/o making a copy.
            bytes should not be null
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.Int32)">
            <summary>
            Create a BytesRef pointing to a new array of size <code>capacity</code>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(Lucene.Net.Support.ICharSequence)">
            <summary>
            Initialize the byte[] from the UTF8 bytes
            for the provided String.
            </summary>
            <param name="text"> this must be well-formed
            unicode text, with no unpaired surrogates. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.#ctor(System.String)">
            <summary>
            Initialize the byte[] from the UTF8 bytes
            for the provided String.
            </summary>
            <param name="text"> this must be well-formed
            unicode text, with no unpaired surrogates. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CopyChars(Lucene.Net.Support.ICharSequence)">
            <summary>
            Copies the UTF8 bytes for this string.
            </summary>
            <param name="text"> Must be well-formed unicode text, with no
            unpaired surrogates or invalid UTF16 code units. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CopyChars(System.String)">
            <summary>
            Copies the UTF8 bytes for this string.
            </summary>
            <param name="text"> Must be well-formed unicode text, with no
            unpaired surrogates or invalid UTF16 code units. </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.BytesEquals(Lucene.Net.Util.BytesRef)">
            <summary>
            Expert: compares the bytes against another BytesRef,
            returning true if the bytes are equal.
            </summary>
            <param name="other"> Another BytesRef, should not be null.
            @lucene.internal </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.Clone" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.GetHashCode" -->
        <member name="M:Lucene.Net.Util.BytesRef.Utf8ToString">
            <summary>
            Interprets stored bytes as UTF8 bytes, returning the
             resulting string
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.ToString">
            <summary>
            Returns hex encoded bytes, eg [0x6c 0x75 0x63 0x65 0x6e 0x65] </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.CopyBytes(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.Append(Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.BytesRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CompareTo(System.Object)">
            <summary>
            Unsigned byte order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRef.CompareTo(Lucene.Net.Util.BytesRef)">
            <summary>
            Unsigned byte order comparison </summary>
        </member>
        <member name="F:Lucene.Net.Util.BytesRef.utf8SortedAsUTF16SortOrder">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="P:Lucene.Net.Util.BytesRef.UTF8SortedAsUTF16Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRef.DeepCopyOf(Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.BytesRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Utf8SortedAsUtf16Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="T:Lucene.Net.Util.BytesRefArray">
             <summary>
             A simple append only random-access <seealso cref="T:Lucene.Net.Util.BytesRef"/> array that stores full
             copies of the appended bytes in a <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/>.
            
            
             <b>Note: this class is not Thread-Safe!</b>
            
             @lucene.internal
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.#ctor(Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> with a counter to track allocated bytes
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Clear">
            <summary>
            Clears this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Append(Lucene.Net.Util.BytesRef)">
            <summary>
            Appends a copy of the given <seealso cref="T:Lucene.Net.Util.BytesRef"/> to this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/>. </summary>
            <param name="bytes"> the bytes to append </param>
            <returns> the index of the appended bytes </returns>
        </member>
        <member name="P:Lucene.Net.Util.BytesRefArray.Length">
            <summary>
            Returns the current size of this <see cref="T:Lucene.Net.Util.BytesRefArray"/>.
            NOTE: This was size() in Lucene.
            </summary>
            <returns> the current size of this <see cref="T:Lucene.Net.Util.BytesRefArray"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.Get(Lucene.Net.Util.BytesRef,System.Int32)">
            <summary>
            Returns the <i>n'th</i> element of this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> </summary>
            <param name="spare"> a spare <seealso cref="T:Lucene.Net.Util.BytesRef"/> instance </param>
            <param name="index"> the elements index to retrieve </param>
            <returns> the <i>n'th</i> element of this <seealso cref="T:Lucene.Net.Util.BytesRefArray"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.GetIterator">
            <summary>
            sugar for <seealso cref="!:#iterator(Comparer)"/> with a <code>null</code> comparer
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefArray.GetIterator(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            <p>
            Returns a <seealso cref="T:Lucene.Net.Util.IBytesRefIterator"/> with point in time semantics. The
            iterator provides access to all so far appended <seealso cref="T:Lucene.Net.Util.BytesRef"/> instances.
            </p>
            <p>
            If a non <code>null</code> <seealso cref="!:Comparer"/> is provided the iterator will
            iterate the byte values in the order specified by the comparer. Otherwise
            the order is the same as the values were appended.
            </p>
            <p>
            this is a non-destructive operation.
            </p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash">
             <summary>
             <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> is a special purpose hash-map like data-structure
             optimized for <seealso cref="T:Lucene.Net.Util.BytesRef"/> instances. BytesRefHash maintains mappings of
             byte arrays to ids (Map&lt;BytesRef,int&gt;) storing the hashed bytes
             efficiently in continuous storage. The mapping to the id is
             encapsulated inside <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> and is guaranteed to be increased
             for each added <seealso cref="T:Lucene.Net.Util.BytesRef"/>.
            
             <p>
             Note: The maximum capacity <seealso cref="T:Lucene.Net.Util.BytesRef"/> instance passed to
             <seealso cref="!:#add(BytesRef)"/> must not be longer than <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/>-2.
             The internal storage is limited to 2GB total byte storage.
             </p>
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> with a <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/> using a
            <seealso cref="T:Lucene.Net.Util.ByteBlockPool.DirectAllocator"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor(Lucene.Net.Util.ByteBlockPool)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.#ctor(Lucene.Net.Util.ByteBlockPool,System.Int32,Lucene.Net.Util.BytesRefHash.BytesStartArray)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.BytesRefHash.Count">
            <summary>
            Returns the number of <seealso cref="T:Lucene.Net.Util.BytesRef"/> values in this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>.
            NOTE: This was size() in Lucene.
            </summary>
            <returns> the number of <seealso cref="T:Lucene.Net.Util.BytesRef"/> values in this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/>. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRefHash.Get(System.Int32,Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.BytesRefHash.Compact">
            <summary>
            Returns the ids array in arbitrary order. Valid ids start at offset of 0
            and end at a limit of <seealso cref="P:Lucene.Net.Util.BytesRefHash.Count"/> - 1
            <p>
            Note: this is a destructive operation. <seealso cref="!:#clear()"/> must be called in
            order to reuse this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> instance.
            </p>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Sort(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})">
            <summary>
            Returns the values array sorted by the referenced byte values.
            <p>
            Note: this is a destructive operation. <seealso cref="!:#clear()"/> must be called in
            order to reuse this <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> instance.
            </p>
            </summary>
            <param name="comp">
                     the <seealso cref="!:Comparer"/> used for sorting </param>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Clear(System.Boolean)">
            <summary>
            Clears the <seealso cref="T:Lucene.Net.Util.BytesRef"/> which maps to the given <seealso cref="T:Lucene.Net.Util.BytesRef"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Dispose">
            <summary>
            Closes the BytesRefHash and releases all internally used memory
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Add(Lucene.Net.Util.BytesRef)">
            <summary>
            Adds a new <seealso cref="T:Lucene.Net.Util.BytesRef"/>
            </summary>
            <param name="bytes">
                     the bytes to hash </param>
            <returns> the id the given bytes are hashed if there was no mapping for the
                    given bytes, otherwise <code>(-(id)-1)</code>. this guarantees
                    that the return value will always be &gt;= 0 if the given bytes
                    haven't been hashed before.
            </returns>
            <exception cref="T:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException">
                      if the given bytes are > 2 +
                      <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/> </exception>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.Find(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the id of the given <seealso cref="T:Lucene.Net.Util.BytesRef"/>.
            </summary>
            <param name="bytes">
                     the bytes to look for
            </param>
            <returns> the id of the given bytes, or {@code -1} if there is no mapping for the
                    given bytes. </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.AddByPoolOffset(System.Int32)">
            <summary>
            Adds a "arbitrary" int offset instead of a BytesRef
             term.  this is used in the indexer to hold the hash for term
             vectors, because they do not redundantly store the byte[] term
             directly and instead reference the byte[] term
             already stored by the postings BytesRefHash.  See
             add(int textStart) in TermsHashPerField.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.BytesRefHash.Rehash(System.Int32,System.Boolean)" -->
        <member name="M:Lucene.Net.Util.BytesRefHash.Reinit">
            <summary>
            reinitializes the <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> after a previous <seealso cref="!:#clear()"/>
            call. If <seealso cref="!:#clear()"/> has not been called previously this method has no
            effect.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.ByteStart(System.Int32)">
            <summary>
            Returns the bytesStart offset into the internally used
            <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/> for the given bytesID
            </summary>
            <param name="bytesID">
                     the id to look up </param>
            <returns> the bytesStart offset into the internally used
                    <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/> for the given id </returns>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException">
            <summary>
            Thrown if a <seealso cref="T:Lucene.Net.Util.BytesRef"/> exceeds the <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> limit of
            <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/>-2.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.MaxBytesLengthExceededException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.BytesStartArray">
            <summary>
            Manages allocation of the per-term addresses. </summary>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Init">
            <summary>
            Initializes the BytesStartArray. this call will allocate memory
            </summary>
            <returns> the initialized bytes start array </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Grow">
            <summary>
            Grows the <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>
            </summary>
            <returns> the grown array </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.Clear">
            <summary>
            clears the <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> and returns the cleared instance.
            </summary>
            <returns> the cleared instance, this might be <code>null</code> </returns>
        </member>
        <member name="M:Lucene.Net.Util.BytesRefHash.BytesStartArray.BytesUsed">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Counter"/> reference holding the number of bytes used by this
            <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>. The <seealso cref="T:Lucene.Net.Util.BytesRefHash"/> uses this reference to
            track it memory usage
            </summary>
            <returns> a <seealso cref="T:Lucene.Net.Support.AtomicInt64"/> reference holding the number of bytes used
                    by this <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/>. </returns>
        </member>
        <member name="T:Lucene.Net.Util.BytesRefHash.DirectBytesStartArray">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.BytesRefHash.BytesStartArray"/> that tracks
             memory allocation using a private <seealso cref="T:Lucene.Net.Util.Counter"/>
             instance.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IBytesRefIterator">
            <summary>
            A simple iterator interface for <seealso cref="T:Lucene.Net.Util.BytesRef"/> iteration.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IBytesRefIterator.Next">
            <summary>
            Increments the iteration to the next <seealso cref="T:Lucene.Net.Util.BytesRef"/> in the iterator.
            Returns the resulting <seealso cref="T:Lucene.Net.Util.BytesRef"/> or <code>null</code> if the end of
            the iterator is reached. The returned BytesRef may be re-used across calls
            to next. After this method returns null, do not call it again: the results
            are undefined.
            </summary>
            <returns> the next <seealso cref="T:Lucene.Net.Util.BytesRef"/> in the iterator or <code>null</code> if
                    the end of the iterator is reached. </returns>
            <exception cref="!:IOException"> If there is a low-level I/O error. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.IBytesRefIterator.Comparer" -->
        <member name="T:Lucene.Net.Util.BytesRefIterator">
            <summary>
            LUCENENET specific class to make the syntax of creating an empty
            <see cref="T:Lucene.Net.Util.IBytesRefIterator"/> the same as it was in Lucene. Example:
            <code>
            var iter = BytesRefIterator.Empty;
            </code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.CharsRef">
            <summary>
            Represents char[], as a slice (offset + Length) into an existing char[].
            The <seealso cref="!:#chars"/> member should never be null; use
            <seealso cref="!:#EMPTY_CHARS"/> if necessary.
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.CharsRef.EMPTY_CHARS">
            <summary>
            An empty character array for convenience </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Chars">
            <summary>
            The contents of the CharsRef. Should never be {@code null}.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Offset">
            <summary>
            Offset of first valid character. </summary>
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.Length">
            <summary>
            Length of used characters. </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized an empty array zero-Length
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized with an array of the given
            capacity
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.Char[],System.Int32,System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized with the given array, offset and
            Length
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.#ctor(System.String)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.CharsRef"/> initialized with the given Strings character
            array
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.CharsRef.Clone" -->
        <member name="M:Lucene.Net.Util.CharsRef.CompareTo(Lucene.Net.Util.CharsRef)">
            <summary>
            Signed int order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.CopyChars(Lucene.Net.Util.CharsRef)">
            <summary>
            Copies the given <seealso cref="T:Lucene.Net.Util.CharsRef"/> referenced content into this instance.
            </summary>
            <param name="other">
                     the <seealso cref="T:Lucene.Net.Util.CharsRef"/> to copy </param>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.CopyChars(System.Char[],System.Int32,System.Int32)">
            <summary>
            Copies the given array into this CharsRef.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.CharsRef.Append(System.Char[],System.Int32,System.Int32)">
            <summary>
            Appends the given array to this CharsRef
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.CharsRef.utf16SortedAsUTF8SortOrder">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="P:Lucene.Net.Util.CharsRef.UTF16SortedAsUTF8Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <member name="T:Lucene.Net.Util.CharsRef.Utf16SortedAsUTF8Comparer">
            @deprecated this comparer is only a transition mechanism
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.CharsRef.DeepCopyOf(Lucene.Net.Util.CharsRef)" -->
        <member name="M:Lucene.Net.Util.CharsRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.DisposableThreadLocal`1">
             <summary>
             Java's builtin ThreadLocal has a serious flaw:
              it can take an arbitrarily long amount of time to
              dereference the things you had stored in it, even once the
              ThreadLocal instance itself is no longer referenced.
              this is because there is single, master map stored for
              each thread, which all ThreadLocals share, and that
              master map only periodically purges "stale" entries.
            
              While not technically a memory leak, because eventually
              the memory will be reclaimed, it can take a long time
              and you can easily hit OutOfMemoryError because from the
              GC's standpoint the stale entries are not reclaimable.
            
              this class works around that, by only enrolling
              WeakReference values into the ThreadLocal, and
              separately holding a hard reference to each stored
              value.  When you call <seealso cref="!:#close"/>, these hard
              references are cleared and then GC is freely able to
              reclaim space by objects stored in it.
            
              We can not rely on <seealso cref="!:ThreadLocal#remove()"/> as it
              only removes the value for the caller thread, whereas
              <seealso cref="!:#close"/> takes care of all
              threads.  You should not call <seealso cref="!:#close"/> until all
              threads are done using the instance.
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.CollectionUtil">
             <summary>
             Methods for manipulating (sorting) collections.
             Sort methods work directly on the supplied lists and don't copy to/from arrays
             before/after. For medium size collections as used in the Lucene indexer that is
             much more efficient.
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.IntroSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. 
            </summary>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comp">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.IntroSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given random access <see cref="T:System.Collections.Generic.IList`1"/> in natural order.
            This method uses the intro sort
            algorithm, but falls back to insertion sort for small lists. 
            </summary>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> using the <see cref="T:System.Collections.Generic.IComparer`1"/>.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
            <param name="comp">The <see cref="T:System.Collections.Generic.IComparer`1"/> to use for the sort.</param>
        </member>
        <member name="M:Lucene.Net.Util.CollectionUtil.TimSort``1(System.Collections.Generic.IList{``0})">
            <summary>
            Sorts the given <see cref="T:System.Collections.Generic.IList`1"/> in natural order.
            This method uses the Tim sort
            algorithm, but falls back to binary sort for small lists. </summary>
            <param name="list">this <see cref="T:System.Collections.Generic.IList`1"/></param>
        </member>
        <member name="T:Lucene.Net.Util.CommandLineUtil">
             <summary>
             Class containing some useful methods used by command line tools
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.NewFSDirectory(System.String,System.IO.DirectoryInfo)">
            <summary>
            Creates a specific FSDirectory instance starting from its class name </summary>
            <param name="clazzName"> The name of the FSDirectory class to load </param>
            <param name="file"> The file to be used as parameter constructor </param>
            <returns> the new FSDirectory instance </returns>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.LoadDirectoryClass(System.String)">
            <summary>
            Loads a specific Directory implementation </summary>
            <param name="clazzName"> The name of the Directory class to load </param>
            <returns> The Directory class loaded </returns>
            <exception cref="!:ClassNotFoundException"> If the specified class cannot be found. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.LoadFSDirectoryClass(System.String)">
            <summary>
            Loads a specific FSDirectory implementation </summary>
            <param name="clazzName"> The name of the FSDirectory class to load </param>
            <returns> The FSDirectory class loaded </returns>
            <exception cref="!:ClassNotFoundException"> If the specified class cannot be found. </exception>
        </member>
        <member name="M:Lucene.Net.Util.CommandLineUtil.NewFSDirectory(System.Type,System.IO.DirectoryInfo)">
            <summary>
            Creates a new specific FSDirectory instance </summary>
            <param name="clazz"> The class of the object to be created </param>
            <param name="file"> The file to be used as parameter constructor </param>
            <returns> The new FSDirectory instance </returns>
            <exception cref="!:NoSuchMethodException"> If the Directory does not have a constructor that takes <code>File</code>. </exception>
            <exception cref="!:InstantiationException"> If the class is abstract or an interface. </exception>
            <exception cref="!:IllegalAccessException"> If the constructor does not have public visibility. </exception>
            <exception cref="!:InvocationTargetException"> If the constructor throws an exception </exception>
        </member>
        <member name="T:Lucene.Net.Util.Constants">
            <summary>
            Some useful constants.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.RUNTIME_VERSION" -->
        <member name="F:Lucene.Net.Util.Constants.RUNTIME_VENDOR">
            <summary>
            NOTE: This was JAVA_VENDOR in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.OS_NAME">
            <summary>
            The value of <see cref="M:System.Environment.GetEnvironmentVariable(System.String)"/> with parameter "OS".</summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.LINUX">
            <summary>
            True iff running on Linux. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.WINDOWS">
            <summary>
            True iff running on Windows. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.SUN_OS">
            <summary>
            True iff running on SunOS. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.MAC_OS_X">
            <summary>
            True iff running on Mac OS X </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.FREE_BSD">
            <summary>
            True iff running on FreeBSD </summary>
        </member>
        <member name="F:Lucene.Net.Util.Constants.RUNTIME_IS_64BIT">
            <summary>
            NOTE: This was JRE_IS_64BIT in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Constants.LUCENE_MAIN_VERSION" -->
        <member name="F:Lucene.Net.Util.Constants.LUCENE_VERSION">
            <summary>
            this is the Lucene version for display purposes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Constants.MainVersionWithoutAlphaBeta">
            <summary>
            Returns a LUCENE_MAIN_VERSION without any ALPHA/BETA qualifier
            Used by test only!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Constants.ExtractString(System.String,System.Text.RegularExpressions.Regex)">
            <summary>
            Extracts the first group matched with the regex as a new string.
            </summary>
            <param name="input">The string to examine</param>
            <param name="pattern">A regex object to use to extract the string</param>
        </member>
        <member name="T:Lucene.Net.Util.Counter">
             <summary>
             Simple counter class
            
             @lucene.internal
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Counter.AddAndGet(System.Int64)">
            <summary>
            Adds the given delta to the counters current value
            </summary>
            <param name="delta">
                     the delta to add </param>
            <returns> the counters updated value </returns>
        </member>
        <member name="M:Lucene.Net.Util.Counter.Get">
            <summary>
            Returns the counters current value
            </summary>
            <returns> the counters current value </returns>
        </member>
        <member name="M:Lucene.Net.Util.Counter.NewCounter">
            <summary>
            Returns a new counter. The returned counter is not thread-safe.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Counter.NewCounter(System.Boolean)">
            <summary>
            Returns a new counter.
            </summary>
            <param name="threadSafe">
                     <code>true</code> if the returned counter can be used by multiple
                     threads concurrently. </param>
            <returns> a new counter. </returns>
        </member>
        <member name="T:Lucene.Net.Util.DocIdBitSet">
            <summary>
            Simple DocIdSet and DocIdSetIterator backed by a BitSet 
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.DocIdBitSet.IsCacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="P:Lucene.Net.Util.DocIdBitSet.BitSet">
            <summary>
            Returns the underlying BitSet.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache`2">
             <summary>
             Simple concurrent LRU cache, using a "double barrel"
             approach where two ConcurrentHashMaps record entries.
            
             <p>At any given time, one hash is primary and the other
             is secondary.  <seealso cref="!:#get"/> first checks primary, and if
             that's a miss, checks secondary.  If secondary has the
             entry, it's promoted to primary (<b>NOTE</b>: the key is
             cloned at this point).  Once primary is full, the
             secondary is cleared and the two are swapped.</p>
            
             <p>this is not as space efficient as other possible
             concurrent approaches (see LUCENE-2075): to achieve
             perfect LRU(N) it requires 2*N storage.  But, this
             approach is relatively simple and seems in practice to
             not grow unbounded in size when under hideously high
             load.</p>
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache">
            <summary>
            LUCENENET specific class to nest the <see cref="T:Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey"/>
            so it can be accessed without referencing the generic closing types
            of <see cref="T:Lucene.Net.Util.DoubleBarrelLRUCache`2"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.DoubleBarrelLRUCache.CloneableKey">
            <summary>
            Object providing clone(); the key class must subclass this.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.FieldCacheSanityChecker" -->
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.#ctor(System.Boolean)">
            <param name="estimateRam">If set, estimate size for all CacheEntry objects will be calculated.</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSanity(Lucene.Net.Search.IFieldCache)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSanity(Lucene.Net.Search.FieldCache.CacheEntry[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.Check(Lucene.Net.Search.FieldCache.CacheEntry[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckValueMismatch(Lucene.Net.Util.MapOfSets{System.Int32,Lucene.Net.Search.FieldCache.CacheEntry},Lucene.Net.Util.MapOfSets{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField,System.Int32},System.Collections.Generic.ISet{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FieldCacheSanityChecker.CheckSubreaders(Lucene.Net.Util.MapOfSets{System.Int32,Lucene.Net.Search.FieldCache.CacheEntry},Lucene.Net.Util.MapOfSets{Lucene.Net.Util.FieldCacheSanityChecker.ReaderField,System.Int32})" -->
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.GetAllDescendantReaderKeys(System.Object)">
            <summary>
            Checks if the seed is an IndexReader, and if so will walk
            the hierarchy of subReaders building up a list of the objects
            returned by {@code seed.getCoreCacheKey()}
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker.ReaderField">
            <summary>
            Simple pair object for using "readerKey + fieldName" a Map key
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.FieldCacheSanityChecker.Insanity">
            <summary>
            Simple container for a collection of related CacheEntry objects that
            in conjunction with each other represent some "insane" usage of the
            FieldCache.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.Type">
            <summary>
            Type of insane behavior this object represents
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.Msg">
            <summary>
            Description of hte insane behavior
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.CacheEntries">
            <summary>
            CacheEntry objects which suggest a problem
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FieldCacheSanityChecker.Insanity.ToString">
            <summary>
            Multi-Line representation of this Insanity object, starting with
            the Type and Msg, followed by each CacheEntry.toString() on it's
            own line prefaced by a tab character
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType" -->
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.SUBREADER">
            <summary>
            Indicates an overlap in cache usage on a given field
            in sub/super readers.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.VALUEMISMATCH">
            <summary>
            <p>
            Indicates entries have the same reader+fieldname but
            different cached values.  this can happen if different datatypes,
            or parsers are used -- and while it's not necessarily a bug
            it's typically an indication of a possible problem.
            </p>
            <p>
            <b>NOTE:</b> Only the reader, fieldname, and cached value are actually
            tested -- if two cache entries have different parsers or datatypes but
            the cached values are the same Object (== not just equal()) this method
            does not consider that a red flag.  this allows for subtle variations
            in the way a Parser is specified (null vs DEFAULT_INT64_PARSER, etc...)
            </p>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.FieldCacheSanityChecker.InsanityType.EXPECTED">
            <summary>
            Indicates an expected bit of "insanity".  this may be useful for
            clients that wish to preserve/log information about insane usage
            but indicate that it was expected.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.FilterIterator`1" -->
        <member name="M:Lucene.Net.Util.FilterIterator`1.PredicateFunction(`0)">
            <summary>
            returns true, if this element should be returned by <seealso cref="!:#next()"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.FixedBitSet">
             <summary>
             BitSet of fixed length (numBits), backed by accessible (<seealso cref="!:#getBits"/>)
             long[], accessed with an int index, implementing <seealso cref="M:Lucene.Net.Util.FixedBitSet.GetBits"/> and
             <seealso cref="T:Lucene.Net.Search.DocIdSet"/>. If you need to manage more than 2.1B bits, use
             <seealso cref="T:Lucene.Net.Util.Int64BitSet"/>.
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator">
            <summary>
            A <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> which iterates over set bits in a
            <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.#ctor(Lucene.Net.Util.FixedBitSet)">
            <summary>
            Creates an iterator over the given <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.FixedBitSetIterator.#ctor(System.Int64[],System.Int32,System.Int32)">
            <summary>
            Creates an iterator over the given array of bits. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.FixedBitSet.EnsureCapacity(Lucene.Net.Util.FixedBitSet,System.Int32)" -->
        <member name="M:Lucene.Net.Util.FixedBitSet.Bits2words(System.Int32)">
            <summary>
            returns the number of 64 bit words it would take to hold numBits </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.IntersectionCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of the intersection of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.UnionCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of the union of the two sets. Neither
            set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNotCount(Lucene.Net.Util.FixedBitSet,Lucene.Net.Util.FixedBitSet)">
            <summary>
            Returns the popcount or cardinality of "a and not b" or
            "intersection(a, not(b))". Neither set is modified.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.FixedBitSet.IsCacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.GetBits">
            <summary>
            Expert. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Cardinality">
            <summary>
            Returns number of set bits.  NOTE: this visits every
             long in the backing bits array, and the result is not
             internally cached!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.NextSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.PrevSetBit(System.Int32)">
            <summary>
            Returns the index of the last set bit before or on the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Or(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place OR of the bits provided by the
             iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Or(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Xor(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Xor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place XOR of the bits provided by the iterator. </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.And(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place AND of the bits provided by the
             iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Intersects(Lucene.Net.Util.FixedBitSet)">
            <summary>
            returns true if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.And(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNot(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Does in-place AND NOT of the bits provided by the
             iterator.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.AndNot(Lucene.Net.Util.FixedBitSet)">
            <summary>
            this = this AND NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Flip(System.Int32,System.Int32)">
            <summary>
            Flips a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Set(System.Int32,System.Int32)">
            <summary>
            Sets a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Clear(System.Int32,System.Int32)">
            <summary>
            Clears a range of bits.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.FixedBitSet.Equals(System.Object)">
            <summary>
            returns true if both sets have the same bits set </summary>
        </member>
        <member name="T:Lucene.Net.Util.GrowableByteArrayDataOutput">
            <summary>
            A <seealso cref="T:Lucene.Net.Store.DataOutput"/> that can be used to build a byte[].
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.GrowableByteArrayDataOutput.Bytes">
            <summary>
            The bytes </summary>
        </member>
        <member name="P:Lucene.Net.Util.GrowableByteArrayDataOutput.Length">
            <summary>
            The length </summary>
        </member>
        <member name="M:Lucene.Net.Util.GrowableByteArrayDataOutput.#ctor(System.Int32)">
            <summary>
            Create a <seealso cref="T:Lucene.Net.Util.GrowableByteArrayDataOutput"/> with the given initial capacity. </summary>
        </member>
        <member name="T:Lucene.Net.Util.IndexableBinaryStringTools">
             <summary>
             Provides support for converting byte sequences to Strings and back again.
             The resulting Strings preserve the original byte sequences' sort order.
             <p/>
             The Strings are constructed using a Base 8000h encoding of the original
             binary data - each char of an encoded String represents a 15-bit chunk
             from the byte sequence.  Base 8000h was chosen because it allows for all
             lower 15 bits of char to be used without restriction; the surrogate range
             [U+D8000-U+DFFF] does not represent valid chars, and would require
             complicated handling to avoid them and allow use of char's high bit.
             <p/>
             Although unset bits are used as padding in the final char, the original
             byte sequence could contain trailing bytes with no set bits (null bytes):
             padding is indistinguishable from valid information.  To overcome this
             problem, a char is appended, indicating the number of encoded bytes in the
             final content char.
             <p/>
            
             @lucene.experimental </summary>
             @deprecated Implement <seealso cref="!:ITermToBytesRefAttribute"/> and store bytes directly
             instead. this class will be removed in Lucene 5.0
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetEncodedLength(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns the number of chars required to encode the given bytes.
            </summary>
            <param name="inputArray"> byte sequence to be encoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of bytes in inputArray </param>
            <returns> The number of chars required to encode the number of bytes. </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetEncodedLength(System.SByte[],System.Int32,System.Int32)">
            <summary>
            Returns the number of chars required to encode the given sbytes.
            </summary>
            <param name="inputArray"> sbyte sequence to be encoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of sbytes in inputArray </param>
            <returns> The number of chars required to encode the number of sbytes. </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.GetDecodedLength(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns the number of bytes required to decode the given char sequence.
            </summary>
            <param name="encoded"> char sequence to be decoded </param>
            <param name="offset"> initial offset </param>
            <param name="length"> number of characters </param>
            <returns> The number of bytes required to decode the given char sequence </returns>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Encode(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Encodes the input sbyte sequence into the output char sequence.  Before
            calling this method, ensure that the output array has sufficient
            capacity by calling <seealso cref="!:#getEncodedLength(byte[], int, int)"/>.
            </summary>
            <param name="inputArray"> sbyte sequence to be encoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of bytes in inputArray </param>
            <param name="outputArray"> char sequence to store encoded result </param>
            <param name="outputOffset"> initial offset into outputArray </param>
            <param name="outputLength"> length of output, must be getEncodedLength </param>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Encode(System.SByte[],System.Int32,System.Int32,System.Char[],System.Int32,System.Int32)">
            <summary>
            Encodes the input sbyte sequence into the output char sequence.  Before
            calling this method, ensure that the output array has sufficient
            capacity by calling <seealso cref="!:#getEncodedLength(byte[], int, int)"/>.
            </summary>
            <param name="inputArray"> sbyte sequence to be encoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of bytes in inputArray </param>
            <param name="outputArray"> char sequence to store encoded result </param>
            <param name="outputOffset"> initial offset into outputArray </param>
            <param name="outputLength"> length of output, must be getEncodedLength </param>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Decode(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Decodes the input char sequence into the output byte sequence. Before
            calling this method, ensure that the output array has sufficient capacity
            by calling <seealso cref="!:#getDecodedLength(char[], int, int)"/>.
            </summary>
            <param name="inputArray"> char sequence to be decoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of chars in inputArray </param>
            <param name="outputArray"> byte sequence to store encoded result </param>
            <param name="outputOffset"> initial offset into outputArray </param>
            <param name="outputLength"> length of output, must be
                   getDecodedLength(inputArray, inputOffset, inputLength) </param>
        </member>
        <member name="M:Lucene.Net.Util.IndexableBinaryStringTools.Decode(System.Char[],System.Int32,System.Int32,System.SByte[],System.Int32,System.Int32)">
            <summary>
            Decodes the input char sequence into the output sbyte sequence. Before
            calling this method, ensure that the output array has sufficient capacity
            by calling <seealso cref="!:#getDecodedLength(char[], int, int)"/>.
            </summary>
            <param name="inputArray"> char sequence to be decoded </param>
            <param name="inputOffset"> initial offset into inputArray </param>
            <param name="inputLength"> number of chars in inputArray </param>
            <param name="outputArray"> byte sequence to store encoded result </param>
            <param name="outputOffset"> initial offset into outputArray </param>
            <param name="outputLength"> length of output, must be
                   getDecodedLength(inputArray, inputOffset, inputLength) </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.InfoStream" -->
        <member name="F:Lucene.Net.Util.InfoStream.NO_OUTPUT">
            <summary>
            Instance of InfoStream that does no logging at all. </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.Message(System.String,System.String)">
            <summary>
            prints a message </summary>
        </member>
        <member name="M:Lucene.Net.Util.InfoStream.IsEnabled(System.String)">
            <summary>
            returns true if messages are enabled and should be posted to <seealso cref="!:#message"/>. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.InfoStream.Default" -->
        <member name="T:Lucene.Net.Util.InPlaceMergeSorter">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Sorter"/> implementation based on the merge-sort algorithm that merges
             in place (no extra memory will be allocated). Small arrays are sorted with
             insertion sort.
             @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.InPlaceMergeSorter.#ctor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.InPlaceMergeSorter"/> </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool">
            <summary>
            A pool for int blocks similar to <seealso cref="T:Lucene.Net.Util.ByteBlockPool"/>.
            <para/>
            NOTE: This was IntBlockPool in Lucene
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_SHIFT">
            <summary>
            NOTE: This was INT_BLOCK_SHIFT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_SIZE">
            <summary>
            NOTE: This was INT_BLOCK_SIZE in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_MASK">
            <summary>
            NOTE: This was INT_BLOCK_MASK in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool.Allocator">
            <summary>
            Abstract class for allocating and freeing int
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.Allocator.RecycleInt32Blocks(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            NOTE: This was recycleIntBlocks() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.Allocator.GetInt32Block">
            <summary>
            NOTE: This was getIntBlock() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool.DirectAllocator">
            <summary>
            A simple <seealso cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/> that never recycles. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.DirectAllocator.#ctor">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.Int32BlockPool.DirectAllocator"/> with a default block size
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.DirectAllocator.RecycleInt32Blocks(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            NOTE: This was recycleIntBlocks() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Buffers">
            <summary>
            array of buffers currently used in the pool. Buffers are allocated if needed don't modify this outside of this class </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.bufferUpto">
            <summary>
            index into the buffers array pointing to the current buffer used as the head </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Int32Upto">
            <summary>
            Pointer to the current position in head buffer
            <para/>
            NOTE: This was intUpto in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Buffer">
            <summary>
            Current head buffer </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.Int32Offset">
            <summary>
            Current head offset 
            <para/>
            NOTE: This was intOffset in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int32BlockPool.#ctor" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int32BlockPool.#ctor(Lucene.Net.Util.Int32BlockPool.Allocator)" -->
        <member name="M:Lucene.Net.Util.Int32BlockPool.Reset">
            <summary>
            Resets the pool to its initial state reusing the first buffer. Calling
            <seealso cref="!:Int32BlockPool#nextBuffer()"/> is not needed after reset.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.Reset(System.Boolean,System.Boolean)">
            <summary>
            Expert: Resets the pool to its initial state reusing the first buffer. </summary>
            <param name="zeroFillBuffers"> if <code>true</code> the buffers are filled with <tt>0</tt>.
                   this should be set to <code>true</code> if this pool is used with
                   <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceWriter"/>. </param>
            <param name="reuseFirst"> if <code>true</code> the first buffer will be reused and calling
                   <seealso cref="!:Int32BlockPool#nextBuffer()"/> is not needed after reset iff the
                   block pool was used before ie. <seealso cref="!:Int32BlockPool#nextBuffer()"/> was called before. </param>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.NextBuffer">
            <summary>
            Advances the pool to its next buffer. this method should be called once
            after the constructor to initialize the pool. In contrast to the
            constructor a <seealso cref="!:Int32BlockPool#reset()"/> call will advance the pool to
            its first buffer immediately.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int32BlockPool.NewSlice(System.Int32)" -->
        <member name="F:Lucene.Net.Util.Int32BlockPool.NEXT_LEVEL_ARRAY">
            <summary>
            An array holding the offset into the <seealso cref="!:Int32BlockPool#LEVEL_SIZE_ARRAY"/>
            to quickly navigate to the next slice level.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.LEVEL_SIZE_ARRAY">
            <summary>
            An array holding the level sizes for int slices.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32BlockPool.FIRST_LEVEL_SIZE">
            <summary>
            The first level size for new slices
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.AllocSlice(System.Int32[],System.Int32)">
            <summary>
            Allocates a new slice from the given offset
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Int32BlockPool.SliceWriter" -->
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceWriter.Reset(System.Int32)">
            
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceWriter.WriteInt32(System.Int32)">
            <summary>
            Writes the given value into the slice and resizes the slice if needed
            <para/>
            NOTE: This was writeInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceWriter.StartNewSlice">
            <summary>
            starts a new slice and returns the start offset. The returned value
            should be used as the start offset to initialize a <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.SliceWriter.CurrentOffset">
            <summary>
            Returns the offset of the currently written slice. The returned value
            should be used as the end offset to initialize a <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/> once
            this slice is fully written or to reset the this writer if another slice
            needs to be written.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32BlockPool.SliceReader">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/> that can read int slices written by a <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceWriter"/>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceReader.#ctor(Lucene.Net.Util.Int32BlockPool)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.Int32BlockPool.SliceReader"/> on the given pool
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32BlockPool.SliceReader.Reset(System.Int32,System.Int32)">
            <summary>
            Resets the reader to a slice give the slices absolute start and end offset in the pool
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32BlockPool.SliceReader.IsEndOfSlice">
            <summary>
            Returns <code>true</code> iff the current slice is fully read. If this
            method returns <code>true</code> <seealso cref="!:SliceReader#readInt()"/> should not
            be called again on this slice.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int32BlockPool.SliceReader.ReadInt32" -->
        <member name="T:Lucene.Net.Util.IntroSorter">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Sorter"/> implementation based on a variant of the quicksort algorithm
            called <a href="http://en.wikipedia.org/wiki/Introsort">introsort</a>: when
            the recursion level exceeds the log of the length of the array to sort, it
            falls back to heapsort. this prevents quicksort from running into its
            worst-case quadratic runtime. Small arrays are sorted with
            insertion sort.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.#ctor">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.IntroSorter"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.SetPivot(System.Int32)">
            <summary>
            Save the value at slot <code>i</code> so that it can later be used as a
            pivot, see <seealso cref="!:#comparePivot(int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IntroSorter.ComparePivot(System.Int32)">
            <summary>
            Compare the pivot with the slot at <code>j</code>, similarly to
             <seealso cref="!:#compare(int, int) compare(i, j)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int32sRef">
            <summary>
            Represents <see cref="T:int[]"/>, as a slice (offset + length) into an
            existing <see cref="T:int[]"/>.  The <see cref="P:Lucene.Net.Util.Int32sRef.Int32s"/> member should never be null; use
            <see cref="F:Lucene.Net.Util.Int32sRef.EMPTY_INT32S"/> if necessary.
            <para/>
            NOTE: This was IntsRef in Lucene
            
             @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int32sRef.EMPTY_INT32S">
            <summary>
            An empty integer array for convenience
            <para/>
            NOTE: This was EMPTY_INTS in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32sRef.Int32s">
            <summary>
            The contents of the IntsRef. Should never be {@code null}. 
            <para/>
            NOTE: This was ints (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32sRef.Offset">
            <summary>
            Offset of first valid integer. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int32sRef.Length">
            <summary>
            Length of used ints. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.#ctor">
            <summary>
            Create a IntsRef with <see cref="F:Lucene.Net.Util.Int32sRef.EMPTY_INT32S"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.#ctor(System.Int32)">
            <summary>
            Create a IntsRef pointing to a new array of size <code>capacity</code>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.#ctor(System.Int32[],System.Int32,System.Int32)">
            <summary>
            this instance will directly reference ints w/o making a copy.
            ints should not be null.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int32sRef.Clone" -->
        <member name="M:Lucene.Net.Util.Int32sRef.Int32sEquals(Lucene.Net.Util.Int32sRef)">
            <summary>
            NOTE: This was intsEquals() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.CompareTo(Lucene.Net.Util.Int32sRef)">
            <summary>
            Signed int order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.CopyInt32s(Lucene.Net.Util.Int32sRef)">
            <summary>
            NOTE: This was copyInts() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int32sRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int32sRef.DeepCopyOf(Lucene.Net.Util.Int32sRef)" -->
        <member name="M:Lucene.Net.Util.Int32sRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.IOUtils">
            <summary>
            this class emulates the new Java 7 "Try-With-Resources" statement.
            Remove once Lucene is on Java 7.
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.IOUtils.CHARSET_UTF_8">
            <summary>
            UTF-8 <seealso cref="!:Charset"/> instance to prevent repeated
            <seealso cref="!:Charset#forName(String)"/> lookups </summary>
            @deprecated Use <seealso cref="!:StandardCharsets#UTF_8"/> instead.
        </member>
        <member name="F:Lucene.Net.Util.IOUtils.UTF_8">
            <summary>
            UTF-8 charset string.
            <para/>Where possible, use <see cref="P:System.Text.Encoding.UTF8"/> instead,
            as using the String constant may slow things down. </summary>
            <seealso cref="P:System.Text.Encoding.UTF8"/>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Exception,System.IDisposable[])">
            <summary>
            <p>Closes all given <tt>IDisposable</tt>s, suppressing all thrown exceptions. Some of the <tt>IDisposable</tt>s
            may be null, they are ignored. After everything is closed, method either throws <tt>priorException</tt>,
            if one is supplied, or the first of suppressed exceptions, or completes normally.</p>
            <p>Sample usage:<br/>
            <pre class="prettyprint">
            IDisposable resource1 = null, resource2 = null, resource3 = null;
            ExpectedException priorE = null;
            try {
              resource1 = ...; resource2 = ...; resource3 = ...; // Acquisition may throw ExpectedException
              ..do..stuff.. // May throw ExpectedException
            } catch (ExpectedException e) {
              priorE = e;
            } finally {
              closeWhileHandlingException(priorE, resource1, resource2, resource3);
            }
            </pre>
            </p> </summary>
            <param name="priorException">  <tt>null</tt> or an exception that will be rethrown after method completion </param>
            <param name="objects">         objects to call <tt>close()</tt> on </param>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Exception,System.Collections.Generic.IEnumerable{System.IDisposable})">
            <summary>
            Closes all given <tt>IDisposable</tt>s, suppressing all thrown exceptions. </summary>
            <seealso> cref= #closeWhileHandlingException(Exception, IDisposable...)  </seealso>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Close(System.IDisposable[])">
            <summary>
            Closes all given <tt>IDisposable</tt>s.  Some of the
            <tt>IDisposable</tt>s may be null; they are
            ignored.  After everything is closed, the method either
            throws the first exception it hit while closing, or
            completes normally if there were no exceptions.
            </summary>
            <param name="objects">
                     objects to call <tt>close()</tt> on </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.Close(System.Collections.Generic.IEnumerable{System.IDisposable})" -->
        <member name="M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.IDisposable[])">
            <summary>
            Closes all given <tt>IDisposable</tt>s, suppressing all thrown exceptions.
            Some of the <tt>IDisposable</tt>s may be null, they are ignored.
            </summary>
            <param name="objects">
                     objects to call <tt>close()</tt> on </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.CloseWhileHandlingException(System.Collections.Generic.IEnumerable{System.IDisposable})" -->
        <member name="M:Lucene.Net.Util.IOUtils.AddSuppressed(System.Exception,System.Exception)">
            <summary>
            Since there's no C# equivalent of Java's Exception.AddSuppressed, we add the
            suppressed exceptions to a data field via the 
            <see cref="M:Lucene.Net.Support.ExceptionExtensions.AddSuppressed(System.Exception,System.Exception)"/> method.
            <para/>
            The exceptions can be retrieved by calling <see cref="M:Lucene.Net.Support.ExceptionExtensions.GetSuppressed(System.Exception)"/>
            or <see cref="M:Lucene.Net.Support.ExceptionExtensions.GetSuppressedAsList(System.Exception)"/>.
            </summary>
            <param name="exception"> this exception should get the suppressed one added </param>
            <param name="suppressed"> the suppressed exception </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.IO.Stream,System.Text.Encoding)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.IO.FileInfo,System.Text.Encoding)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.GetDecodingReader(System.Type,System.String,System.Text.Encoding)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.IOUtils.DeleteFilesIgnoringExceptions(Lucene.Net.Store.Directory,System.String[])" -->
        <member name="M:Lucene.Net.Util.IOUtils.Copy(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Copy one file's contents to another file. The target will be overwritten
            if it exists. The source must exist.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.ReThrow(System.Exception)">
            <summary>
            Simple utilty method that takes a previously caught
            {@code Throwable} and rethrows either {@code
            IOException} or an unchecked exception.  If the
            argument is null then this method does nothing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.ReThrowUnchecked(System.Exception)">
            <summary>
            Simple utilty method that takes a previously caught
            {@code Throwable} and rethrows it as an unchecked exception.
            If the argument is null then this method does nothing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IOUtils.Fsync(System.String,System.Boolean)">
            <summary>
            Ensure that any writes to the given file is written to the storage device that contains it. </summary>
            <param name="fileToSync"> the file to fsync </param>
            <param name="isDir"> if true, the given file is a directory (we open for read and ignore IOExceptions,
             because not all file systems and operating systems allow to fsync on a directory) </param>
        </member>
        <member name="T:Lucene.Net.Util.Int64BitSet">
             <summary>
             BitSet of fixed length (numBits), backed by accessible (<seealso cref="!:#getBits"/>)
             long[], accessed with a long index. Use it only if you intend to store more
             than 2.1B bits, otherwise you should use <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>.
             <para/>
             NOTE: This was LongBitSet in Lucene
            
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int64BitSet.EnsureCapacity(Lucene.Net.Util.Int64BitSet,System.Int64)" -->
        <member name="M:Lucene.Net.Util.Int64BitSet.Bits2words(System.Int64)">
            <summary>
            returns the number of 64 bit words it would take to hold numBits </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64BitSet.Length">
            <summary>
            Returns the number of bits stored in this bitset. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.GetBits">
            <summary>
            Expert. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Cardinality">
            <summary>
            Returns number of set bits.  NOTE: this visits every
             long in the backing bits array, and the result is not
             internally cached!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.NextSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.PrevSetBit(System.Int64)">
            <summary>
            Returns the index of the last set bit before or on the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Or(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Xor(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Intersects(Lucene.Net.Util.Int64BitSet)">
            <summary>
            returns true if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.And(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.AndNot(Lucene.Net.Util.Int64BitSet)">
            <summary>
            this = this AND NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Flip(System.Int64,System.Int64)">
            <summary>
            Flips a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Set(System.Int64,System.Int64)">
            <summary>
            Sets a range of bits
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Clear(System.Int64,System.Int64)">
            <summary>
            Clears a range of bits.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.Int64BitSet.Equals(System.Object)">
            <summary>
            returns true if both sets have the same bits set </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int64sRef">
             <summary>
             Represents <see cref="T:long[]"/>, as a slice (offset + length) into an
             existing <see cref="T:long[]"/>.  The <see cref="P:Lucene.Net.Util.Int64sRef.Int64s"/> member should never be null; use
             <see cref="F:Lucene.Net.Util.Int64sRef.EMPTY_INT64S"/> if necessary.
             <para/>
             NOTE: This was LongsRef in Lucene
            
              @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.Int64sRef.EMPTY_INT64S">
            <summary>
            An empty long array for convenience
            <para/>
            NOTE: This was EMPTY_LONGS in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64sRef.Int64s">
            <summary>
            The contents of the LongsRef. Should never be {@code null}. 
            <para/>
            NOTE: This was longs (field) in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64sRef.Offset">
            <summary>
            Offset of first valid long. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Int64sRef.Length">
            <summary>
            Length of used longs. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.#ctor">
            <summary>
            Create a LongsRef with <see cref="F:Lucene.Net.Util.Int64sRef.EMPTY_INT64S"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.#ctor(System.Int32)">
            <summary>
            Create a LongsRef pointing to a new array of size <code>capacity</code>.
            Offset and length will both be zero.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.#ctor(System.Int64[],System.Int32,System.Int32)">
            <summary>
            this instance will directly reference longs w/o making a copy.
            longs should not be null
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int64sRef.Clone" -->
        <member name="M:Lucene.Net.Util.Int64sRef.Int64sEquals(Lucene.Net.Util.Int64sRef)">
            <summary>
            NOTE: This was longsEquals() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.CompareTo(Lucene.Net.Util.Int64sRef)">
            <summary>
            Signed int order comparison </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.CopyInt64s(Lucene.Net.Util.Int64sRef)">
            <summary>
            NOTE: This was copyLongs() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64sRef.Grow(System.Int32)">
             <summary>
             Used to grow the reference array.
            
             In general this should not be used as it does not take the offset into account.
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Int64sRef.DeepCopyOf(Lucene.Net.Util.Int64sRef)" -->
        <member name="M:Lucene.Net.Util.Int64sRef.IsValid">
            <summary>
            Performs internal consistency checks.
            Always returns true (or throws InvalidOperationException)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Int64Values">
            <summary>
            Abstraction over an array of longs.
             this class extends NumericDocValues so that we don't need to add another
             level of abstraction every time we want eg. to use the <seealso cref="T:Lucene.Net.Util.Packed.PackedInt32s"/>
             utility classes to represent a <seealso cref="T:Lucene.Net.Index.NumericDocValues"/> instance.
            <para/>
            NOTE: This was LongValues in Lucene
            
             @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Int64Values.Get(System.Int64)">
            <summary>
            Get value at <code>index</code>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.MapOfSets`2">
            <summary>
            Helper class for keeping Lists of Objects associated with keys. <b>WARNING: this CLASS IS NOT THREAD SAFE</b>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.#ctor(System.Collections.Generic.IDictionary{`0,System.Collections.Generic.HashSet{`1}})">
            <param name="m"> the backing store for this object </param>
        </member>
        <member name="P:Lucene.Net.Util.MapOfSets`2.Map">
            <returns> direct access to the map backing this object. </returns>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.Put(`0,`1)">
            <summary>
            Adds val to the Set associated with key in the Map.  If key is not
            already in the map, a new Set will first be created. </summary>
            <returns> the size of the Set associated with key once val is added to it. </returns>
        </member>
        <member name="M:Lucene.Net.Util.MapOfSets`2.PutAll(`0,System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Adds multiple vals to the Set associated with key in the Map.
            If key is not
            already in the map, a new Set will first be created. </summary>
            <returns> the size of the Set associated with key once val is added to it. </returns>
        </member>
        <member name="T:Lucene.Net.Util.MathUtil">
            <summary>
            Math static utility methods.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Log(System.Int64,System.Int32)" -->
        <member name="M:Lucene.Net.Util.MathUtil.Log(System.Double,System.Double)">
            <summary>
            Calculates logarithm in a given base with doubles.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Gcd(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Asinh(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Acosh(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.MathUtil.Atanh(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.MergedIterator`1" -->
        <member name="T:Lucene.Net.Util.IMutableBits">
            <summary>
            Extension of Bits for live documents.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.IMutableBits.Clear(System.Int32)">
            <summary>
            Sets the bit specified by <code>index</code> to false. </summary>
            <param name="index"> index, should be non-negative and &lt; <seealso cref="!:#length()"/>.
                   The result of passing negative or out of bounds values is undefined
                   by this interface, <b>just don't do it!</b> </param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.NumericUtils" -->
        <member name="F:Lucene.Net.Util.NumericUtils.PRECISION_STEP_DEFAULT">
            <summary>
            The default precision step used by <seealso cref="!:IntField"/>,
            <seealso cref="!:FloatField"/>, <seealso cref="!:LongField"/>, {@link
            DoubleField}, <seealso cref="!:NumericTokenStream"/>, {@link
            NumericRangeQuery}, and <seealso cref="!:NumericRangeFilter"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.SHIFT_START_INT64">
            <summary>
            Longs are stored at lower precision by shifting off lower bits. The shift count is
            stored as <c>SHIFT_START_INT64+shift</c> in the first byte
            <para/>
            NOTE: This was SHIFT_START_LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.BUF_SIZE_INT64">
            <summary>
            The maximum term length (used for <code>byte[]</code> buffer size)
            for encoding <see cref="T:System.Int64"/> values.
            <para/>
            NOTE: This was BUF_SIZE_LONG in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.Int64ToPrefixCodedBytes(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.SHIFT_START_INT32">
            <summary>
            Integers are stored at lower precision by shifting off lower bits. The shift count is
            stored as <code>SHIFT_START_INT32+shift</code> in the first byte
            <para/>
            NOTE: This was SHIFT_START_INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.NumericUtils.BUF_SIZE_INT32">
            <summary>
            The maximum term length (used for <see cref="T:byte[]"/> buffer size)
            for encoding <see cref="T:System.Int32"/> values.
            <para/>
            NOTE: This was BUF_SIZE_INT in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.Int32ToPrefixCodedBytes(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64ToPrefixCoded(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="!:NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. 
            <para/>
            NOTE: This was longToPrefixCoded() in Lucene
            </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32ToPrefixCoded(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="!:NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. 
            <para/>
            NOTE: This was intToPrefixCoded() in Lucene
            </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64ToPrefixCodedBytes(System.Int64,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="!:NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. 
            <para/>
            NOTE: This was longToPrefixCodedBytes() in Lucene
            </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32ToPrefixCodedBytes(System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns prefix coded bits after reducing the precision by <code>shift</code> bits.
            this is method is used by <seealso cref="!:NumericTokenStream"/>.
            After encoding, {@code bytes.offset} will always be 0. 
            <para/>
            NOTE: This was intToPrefixCodedBytes() in Lucene
            </summary>
            <param name="val"> the numeric value </param>
            <param name="shift"> how many bits to strip from the right </param>
            <param name="bytes"> will contain the encoded value </param>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.GetPrefixCodedInt64Shift(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the shift value from a prefix encoded {@code long}. 
            <para/>
            NOTE: This was getPrefixCodedLongShift() in Lucene
            </summary>
            <exception cref="!:NumberFormatException"> if the supplied <seealso cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.GetPrefixCodedInt32Shift(Lucene.Net.Util.BytesRef)">
            <summary>
            Returns the shift value from a prefix encoded {@code int}. 
            <para/>
            NOTE: This was getPrefixCodedIntShift() in Lucene
            </summary>
            <exception cref="!:NumberFormatException"> if the supplied <seealso cref="T:Lucene.Net.Util.BytesRef"/> is
            not correctly prefix encoded. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.PrefixCodedToInt64(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.PrefixCodedToInt32(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.DoubleToSortableInt64(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.SortableInt64ToDouble(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.NumericUtils.SingleToSortableInt32(System.Single)" -->
        <member name="M:Lucene.Net.Util.NumericUtils.SortableInt32ToSingle(System.Int32)">
            <summary>
            Converts a sortable <see cref="T:System.Int32"/> back to a <see cref="T:System.Single"/>. 
            <para/>
            NOTE: This was sortableIntToFloat() in Lucene
            </summary>
            <seealso cref="M:Lucene.Net.Util.NumericUtils.SingleToSortableInt32(System.Single)"/>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SplitInt64Range(Lucene.Net.Util.NumericUtils.Int64RangeBuilder,System.Int32,System.Int64,System.Int64)">
            <summary>
            Splits a long range recursively.
            You may implement a builder that adds clauses to a
            <seealso cref="T:Lucene.Net.Search.BooleanQuery"/> for each call to its
            <seealso cref="!:Int64RangeBuilder#addRange(BytesRef,BytesRef)"/>
            method.
            <para/>
            this method is used by <seealso cref="!:NumericRangeQuery"/>.
            <para/>
            NOTE: This was splitLongRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SplitInt32Range(Lucene.Net.Util.NumericUtils.Int32RangeBuilder,System.Int32,System.Int32,System.Int32)">
            <summary>
            Splits an int range recursively.
            You may implement a builder that adds clauses to a
            <seealso cref="T:Lucene.Net.Search.BooleanQuery"/> for each call to its
            <seealso cref="!:Int32RangeBuilder#addRange(BytesRef,BytesRef)"/>
            method.
            <para/>
            this method is used by <seealso cref="!:NumericRangeQuery"/>.
            <para/>
            NOTE: This was splitIntRange() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.SplitRange(System.Object,System.Int32,System.Int32,System.Int64,System.Int64)">
            <summary>
            this helper does the splitting for both 32 and 64 bit. </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.AddRange(System.Object,System.Int32,System.Int64,System.Int64,System.Int32)">
            <summary>
            Helper that delegates to correct range builder </summary>
        </member>
        <member name="T:Lucene.Net.Util.NumericUtils.Int64RangeBuilder">
            <summary>
            Callback for <seealso cref="!:#splitLongRange"/>.
            You need to overwrite only one of the methods.
            <para/>
            NOTE: This was LongRangeBuilder in Lucene
            
            @lucene.internal
            @since 2.9, API changed non backwards-compliant in 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64RangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Overwrite this method, if you like to receive the already prefix encoded range bounds.
            You can directly build classical (inclusive) range queries from them.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int64RangeBuilder.AddRange(System.Int64,System.Int64,System.Int32)">
            <summary>
            Overwrite this method, if you like to receive the raw long range bounds.
            You can use this for e.g. debugging purposes (print out range bounds).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.NumericUtils.Int32RangeBuilder">
            <summary>
            Callback for <seealso cref="!:#splitIntRange"/>.
            You need to overwrite only one of the methods.
            <para/>
            NOTE: This was IntRangeBuilder in Lucene
            
            @lucene.internal
            @since 2.9, API changed non backwards-compliant in 4.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32RangeBuilder.AddRange(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Overwrite this method, if you like to receive the already prefix encoded range bounds.
            You can directly build classical range (inclusive) queries from them.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.Int32RangeBuilder.AddRange(System.Int32,System.Int32,System.Int32)">
            <summary>
            Overwrite this method, if you like to receive the raw int range bounds.
            You can use this for e.g. debugging purposes (print out range bounds).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.FilterPrefixCodedInt64s(Lucene.Net.Index.TermsEnum)">
            <summary>
            Filters the given <seealso cref="T:Lucene.Net.Index.TermsEnum"/> by accepting only prefix coded 64 bit
            terms with a shift value of <tt>0</tt>.
            <para/>
            NOTE: This was filterPrefixCodedLongs() in Lucene
            </summary>
            <param name="termsEnum">
                     the terms enum to filter </param>
            <returns> a filtered <seealso cref="T:Lucene.Net.Index.TermsEnum"/> that only returns prefix coded 64 bit
                    terms with a shift value of <tt>0</tt>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.NumericUtils.FilterPrefixCodedInt32s(Lucene.Net.Index.TermsEnum)">
            <summary>
            Filters the given <seealso cref="T:Lucene.Net.Index.TermsEnum"/> by accepting only prefix coded 32 bit
            terms with a shift value of <tt>0</tt>.
            <para/>
            NOTE: This was filterPrefixCodedInts() in Lucene
            </summary>
            <param name="termsEnum">
                     the terms enum to filter </param>
            <returns> a filtered <seealso cref="T:Lucene.Net.Index.TermsEnum"/> that only returns prefix coded 32 bit
                    terms with a shift value of <tt>0</tt>. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.OfflineSorter" -->
        <member name="F:Lucene.Net.Util.OfflineSorter.MB">
            <summary>
            Convenience constant for megabytes </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.GB">
            <summary>
            Convenience constant for gigabytes </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.MIN_BUFFER_SIZE_MB">
            <summary>
            Minimum recommended buffer size for sorting.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.ABSOLUTE_MIN_SORT_BUFFER_SIZE">
            <summary>
            Absolute minimum required buffer size for sorting.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.MAX_TEMPFILES">
            <summary>
            Maximum number of temporary files before doing an intermediate merge.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.OfflineSorter.BufferSize" -->
        <member name="M:Lucene.Net.Util.OfflineSorter.BufferSize.Megabytes(System.Int64)">
            <summary>
            Creates a <seealso cref="T:Lucene.Net.Util.OfflineSorter.BufferSize"/> in MB. The given
            values must be &gt; 0 and &lt; 2048.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.BufferSize.Automatic">
            <summary>
            Approximately half of the currently available free heap, but no less
            than <seealso cref="!:#ABSOLUTE_MIN_SORT_BUFFER_SIZE"/>. However if current heap allocation
            is insufficient or if there is a large portion of unallocated heap-space available
            for sorting consult with max allowed heap size.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter.SortInfo">
            <summary>
            Sort info (debugging mostly).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.TempMergeFiles">
            <summary>
            number of temporary files created when merging partitions </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.MergeRounds">
            <summary>
            number of partition merges </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.Lines">
            <summary>
            number of lines of data read </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.MergeTime">
            <summary>
            time spent merging sorted partitions (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.SortTime">
            <summary>
            time spent sorting data (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.TotalTime">
            <summary>
            total time spent (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.ReadTime">
            <summary>
            time spent in i/o read (in milliseconds) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.SortInfo.BufferSize">
            <summary>
            read buffer size (in bytes) </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.SortInfo.#ctor(Lucene.Net.Util.OfflineSorter)">
            <summary>
            create a new SortInfo (with empty statistics) for debugging </summary>
        </member>
        <member name="F:Lucene.Net.Util.OfflineSorter.DEFAULT_COMPARER">
            <summary>
            Default comparer: sorts in binary (codepoint) order </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.#ctor" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.#ctor(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef})" -->
        <member name="M:Lucene.Net.Util.OfflineSorter.#ctor(System.Collections.Generic.IComparer{Lucene.Net.Util.BytesRef},Lucene.Net.Util.OfflineSorter.BufferSize,System.IO.DirectoryInfo,System.Int32)">
            <summary>
            All-details constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.Sort(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Sort input to output, explicit hint for the buffer size. The amount of allocated
            memory may deviate from the hint (may be smaller or larger).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.DefaultTempDir">
            <summary>
            Returns the default temporary directory. By default, the System's temp folder. If not accessible
            or not available, an IOException is thrown
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.Copy(System.IO.FileInfo,System.IO.FileInfo)">
            <summary>
            Copies one file to another.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.SortPartition(System.Int32)">
            <summary>
            Sort a single partition in-memory. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.MergePartitions(System.Collections.Generic.IEnumerable{System.IO.FileInfo},System.IO.FileInfo)">
            <summary>
            Merge a list of sorted temporary files (partitions) into an output file </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ReadPartition(Lucene.Net.Util.OfflineSorter.ByteSequencesReader)">
            <summary>
            Read in a single partition of data </summary>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter">
            <summary>
            Utility class to emit length-prefixed byte[] entries to an output stream for sorting.
            Complementary to <seealso cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesReader"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.#ctor(System.IO.FileInfo)">
            <summary>
            Constructs a ByteSequencesWriter to the provided File </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.#ctor(Lucene.Net.Store.DataOutput)">
            <summary>
            Constructs a ByteSequencesWriter to the provided DataOutput </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.NewBinaryWriterDataOutput(System.IO.FileInfo)">
            <summary>
            LUCENENET specific - ensures the file has been created with no BOM
            if it doesn't already exist and opens the file for writing.
            Java doesn't use a BOM by default.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[])" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Write(System.Byte[],System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter.Dispose">
            <summary>
            Closes the provided <seealso cref="T:Lucene.Net.Store.DataOutput"/> if it is <seealso cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OfflineSorter.ByteSequencesReader">
            <summary>
            Utility class to read length-prefixed byte[] entries from an input.
            Complementary to <seealso cref="T:Lucene.Net.Util.OfflineSorter.ByteSequencesWriter"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.#ctor(System.IO.FileInfo)">
            <summary>
            Constructs a ByteSequencesReader from the provided File </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Constructs a ByteSequencesReader from the provided DataInput </summary>
        </member>
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.Read(Lucene.Net.Util.BytesRef)">
            <summary>
            Reads the next entry into the provided <seealso cref="T:Lucene.Net.Util.BytesRef"/>. The internal
            storage is resized if needed.
            </summary>
            <returns> Returns <code>false</code> if EOF occurred when trying to read
            the header of the next sequence. Returns <code>true</code> otherwise. </returns>
            <exception cref="!:EOFException"> if the file ends before the full sequence is read. </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.Read" -->
        <member name="M:Lucene.Net.Util.OfflineSorter.ByteSequencesReader.Dispose">
            <summary>
            Closes the provided <seealso cref="T:Lucene.Net.Store.DataInput"/> if it is <seealso cref="T:System.IDisposable"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.OfflineSorter.Comparer">
            <summary>
            Returns the comparer in use to sort entries </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.OpenBitSet" -->
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64)">
            <summary>
            Constructs an OpenBitSet large enough to hold {@code numBits}. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.#ctor">
            <summary>
            Constructor: allocates enough space for 64 bits. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OpenBitSet.#ctor(System.Int64[],System.Int32)" -->
        <member name="P:Lucene.Net.Util.OpenBitSet.IsCacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.Capacity">
            <summary>
            Returns the current capacity in bits (1 greater than the index of the last bit) </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.Length">
            <summary>
            Returns the current capacity of this set. This is *not* equal to <seealso cref="!:#cardinality"/>.
            NOTE: This is equivalent to size() or length() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.IsEmpty">
            <summary>
            Returns true if there are no set bits </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetBits">
            <summary>
            Expert: returns the long[] storing the bits </summary>
        </member>
        <member name="P:Lucene.Net.Util.OpenBitSet.NumWords">
            <summary>
            Expert: gets the number of longs in the array that are in use </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int32)">
            <summary>
            Returns true or false for the specified bit index. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int32)">
            <summary>
            Returns true or false for the specified bit index.
            The index should be less than the OpenBitSet size
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Get(System.Int64)">
            <summary>
            Returns true or false for the specified bit index
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastGet(System.Int64)">
            <summary>
            Returns true or false for the specified bit index.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetBit(System.Int32)">
            <summary>
            returns 1 if the bit is set, 0 if not.
            The index should be less than the OpenBitSet size
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64)">
            <summary>
            sets a bit, expanding the set size if necessary </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int32)">
            <summary>
            Sets the bit at the specified index.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastSet(System.Int64)">
            <summary>
            Sets the bit at the specified index.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Set(System.Int64,System.Int64)">
            <summary>
            Sets a range of bits, expanding the set size if necessary
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to set </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int32)">
            <summary>
            clears a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastClear(System.Int64)">
            <summary>
            clears a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64)">
            <summary>
            clears a bit, allowing access beyond the current set size without changing the size. </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int32,System.Int32)">
            <summary>
            Clears a range of bits.  Clearing past the end does not change the size of the set.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Clear(System.Int64,System.Int64)">
            <summary>
            Clears a range of bits.  Clearing past the end does not change the size of the set.
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to clear </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int32)">
            <summary>
            Sets a bit and returns the previous value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.GetAndSet(System.Int64)">
            <summary>
            Sets a bit and returns the previous value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int32)">
            <summary>
            flips a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FastFlip(System.Int64)">
            <summary>
            flips a bit.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64)">
            <summary>
            flips a bit, expanding the set size if necessary </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int32)">
            <summary>
            flips a bit and returns the resulting bit value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.FlipAndGet(System.Int64)">
            <summary>
            flips a bit and returns the resulting bit value.
            The index should be less than the OpenBitSet size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Flip(System.Int64,System.Int64)">
            <summary>
            Flips a range of bits, expanding the set size if necessary
            </summary>
            <param name="startIndex"> lower index </param>
            <param name="endIndex"> one-past the last bit to flip </param>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Cardinality">
            <returns> the number of set bits </returns>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.IntersectionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the intersection of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.UnionCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the union of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.AndNotCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of "a and not b"
            or "intersection(a, not(b))".
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.XorCount(Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Returns the popcount or cardinality of the exclusive-or of the two sets.
            Neither set is modified.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.NextSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting at the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.PrevSetBit(System.Int32)">
            <summary>
            Returns the index of the first set bit starting downwards at
             the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.PrevSetBit(System.Int64)">
            <summary>
            Returns the index of the first set bit starting downwards at
             the index specified.
             -1 is returned if there are no more set bits.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersect(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this AND other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Union(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this OR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Remove(Lucene.Net.Util.OpenBitSet)">
            <summary>
            Remove all elements set in other. this = this AND_NOT other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Xor(Lucene.Net.Util.OpenBitSet)">
            <summary>
            this = this XOR other </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Intersects(Lucene.Net.Util.OpenBitSet)">
            <summary>
            returns true if the sets have any elements in common </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacityWords(System.Int32)">
            <summary>
            Expand the long[] with the size given as a number of words (64 bit longs). </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.EnsureCapacity(System.Int64)">
            <summary>
            Ensure that the long[] is big enough to hold numBits, expanding it if
            necessary.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.TrimTrailingZeros">
            <summary>
            Lowers numWords, the number of words in use,
            by checking for trailing zero words.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Bits2words(System.Int64)">
            <summary>
            returns the number of 64 bit words it would take to hold numBits </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSet.Equals(System.Object)">
            <summary>
            returns true if both sets have the same bits set </summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSetDISI">
            <summary>
            OpenBitSet with added methods to bulk-update the bits
             from a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(Lucene.Net.Search.DocIdSetIterator,System.Int32)">
            <summary>
            Construct an OpenBitSetDISI with its bits set
            from the doc ids of the given DocIdSetIterator.
            Also give a maximum size one larger than the largest doc id for which a
            bit may ever be set on this OpenBitSetDISI.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.#ctor(System.Int32)">
            <summary>
            Construct an OpenBitSetDISI with no bits set, and a given maximum size
            one larger than the largest doc id for which a bit may ever be set
            on this OpenBitSetDISI.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceOr(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace OR with the doc ids from a given DocIdSetIterator,
            setting the bit for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceAnd(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace AND with the doc ids from a given DocIdSetIterator,
            leaving only the bits set for which the doc ids are in common.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceNot(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace NOT with the doc ids from a given DocIdSetIterator,
            clearing all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.OpenBitSetDISI.InPlaceXor(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Perform an inplace XOR with the doc ids from a given DocIdSetIterator,
            flipping all the bits for each such doc id.
            These doc ids should be smaller than the maximum size passed to the
            constructor.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.OpenBitSetIterator">
            <summary>
            An iterator to iterate over set bits in an OpenBitSet.
            this is faster than nextSetBit() for iterating over the complete set of bits,
            especially when the density of the bits set is high.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.OpenBitSetIterator.NextDoc" -->
        <member name="T:Lucene.Net.Util.PagedBytes">
             <summary>
             Represents a logical byte[] as a series of pages.  You
              can write-once into the logical byte[] (append only),
              using copy, and then retrieve slices (BytesRef) into it
              using fill.
            
             @lucene.internal
            
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.PagedBytes.Reader" -->
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.FillSlice(Lucene.Net.Util.BytesRef,System.Int64,System.Int32)">
             <summary>
             Gets a slice out of <seealso cref="T:Lucene.Net.Util.PagedBytes"/> starting at <i>start</i> with a
             given length. Iff the slice spans across a block border this method will
             allocate sufficient resources and copy the paged data.
             <p>
             Slices spanning more than two blocks are not supported.
             </p>
             @lucene.internal
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.Fill(Lucene.Net.Util.BytesRef,System.Int64)">
             <summary>
             Reads length as 1 or 2 byte vInt prefix, starting at <i>start</i>.
             <p>
             <b>Note:</b> this method does not support slices spanning across block
             borders.
             </p>
            
             @lucene.internal
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Reader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.#ctor(System.Int32)">
            <summary>
            1&lt;&lt;blockBits must be bigger than biggest single
             BytesRef slice that will be pulled
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.Copy(Lucene.Net.Store.IndexInput,System.Int64)">
            <summary>
            Read this many bytes from in </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.PagedBytes.Copy(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)" -->
        <member name="M:Lucene.Net.Util.PagedBytes.Freeze(System.Boolean)">
            <summary>
            Commits final byte[], trimming it if necessary and if trim=true </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.RamBytesUsed">
            <summary>
            Return approx RAM usage in bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.CopyUsingLengthPrefix(Lucene.Net.Util.BytesRef)">
            <summary>
            Copy bytes in, writing the length as a 1 or 2 byte
             vInt prefix.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.PagedBytes.PagedBytesDataInput.Position">
            <summary>
            Returns the current byte position. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.PagedBytesDataInput.SetPosition(System.Int64)">
            <summary>
            Seek to a position previously obtained from <see cref="P:Lucene.Net.Util.PagedBytes.PagedBytesDataInput.Position"/>.
            </summary>
            <param name="position"></param>
        </member>
        <member name="P:Lucene.Net.Util.PagedBytes.PagedBytesDataOutput.Position">
            <summary>
            Return the current byte position. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.GetDataInput">
            <summary>
            Returns a DataInput to read values from this
             PagedBytes instance.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PagedBytes.GetDataOutput">
            <summary>
            Returns a DataOutput that you may use to write into
             this PagedBytes instance.  If you do this, you should
             not call the other writing methods (eg, copy);
             results are undefined.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.PForDeltaDocIdSet">
            <summary>
            <seealso cref="T:Lucene.Net.Search.DocIdSet"/> implementation based on pfor-delta encoding.
            <p>this implementation is inspired from LinkedIn's Kamikaze
            (http://data.linkedin.com/opensource/kamikaze) and Daniel Lemire's JavaFastPFOR
            (https://github.com/lemire/JavaFastPFOR).</p>
            <p>On the contrary to the original PFOR paper, exceptions are encoded with
            FOR instead of Simple16.</p>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.PForDeltaDocIdSet.Builder">
            <summary>
            A builder for <seealso cref="T:Lucene.Net.Util.PForDeltaDocIdSet"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.#ctor">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.SetIndexInterval(System.Int32)">
            <summary>
            Set the index interval. Every <code>indexInterval</code>-th block will
            be stored in the index. Set to <see cref="F:System.Int32.MaxValue"/> to disable indexing.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Add(System.Int32)">
            <summary>
            Add a document to this builder. Documents must be added in order. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Add(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Convenience method to add the content of a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> to this builder. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Builder.Build">
            <summary>
            Build the <seealso cref="T:Lucene.Net.Util.PForDeltaDocIdSet"/> instance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.Cardinality">
            <summary>
            Return the number of documents in this <seealso cref="T:Lucene.Net.Search.DocIdSet"/> in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PForDeltaDocIdSet.RamBytesUsed">
            <summary>
            Return the memory usage of this instance. </summary>
        </member>
        <member name="T:Lucene.Net.Util.PrintStreamInfoStream">
             <summary>
             InfoStream implementation over a <seealso cref="!:PrintStream"/>
             such as <code>System.out</code>.
            
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.PriorityQueue`1" -->
        <member name="M:Lucene.Net.Util.PriorityQueue`1.LessThan(`0,`0)">
            <summary>
            Determines the ordering of objects in this priority queue.  Subclasses
             must define this one method. </summary>
             <returns> <code>true</code> iff parameter <tt>a</tt> is less than parameter <tt>b</tt>. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.PriorityQueue`1.GetSentinelObject" -->
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Add(`0)">
            <summary>
            Adds an Object to a PriorityQueue in log(size) time. If one tries to add
            more objects than maxSize from initialize and it is not possible to resize
            the heap, an <seealso cref="T:System.IndexOutOfRangeException"/> is thrown.
            </summary>
            <returns> the new 'top' element in the queue. </returns>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.InsertWithOverflow(`0)">
            <summary>
            Adds an Object to a PriorityQueue in log(size) time.
            It returns the object (if any) that was
            dropped off the heap because it was full. this can be
            the given parameter (in case it is smaller than the
            full heap's minimum, and couldn't be added), or another
            object that was previously the smallest value in the
            heap and now has been replaced by a larger one, or null
            if the queue wasn't yet full with maxSize elements.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.PriorityQueue`1.Top">
            <summary>
            Returns the least element of the PriorityQueue in constant time.
            Returns null if the queue is empty. </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Pop">
            <summary>
            Removes and returns the least element of the PriorityQueue in log(size)
             time.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.UpdateTop">
             <summary>
             Should be called when the Object at top changes values. Still log(n) worst
             case, but it's at least twice as fast to
            
             <pre class="prettyprint">
             pq.top().change();
             pq.updateTop();
             </pre>
            
             instead of
            
             <pre class="prettyprint">
             o = pq.pop();
             o.change();
             pq.push(o);
             </pre>
             </summary>
             <returns> the new 'top' element. </returns>
        </member>
        <member name="P:Lucene.Net.Util.PriorityQueue`1.Count">
            <summary>
            Returns the number of elements currently stored in the PriorityQueue.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.PriorityQueue`1.Clear">
            <summary>
            Removes all entries from the PriorityQueue. </summary>
        </member>
        <member name="P:Lucene.Net.Util.PriorityQueue`1.HeapArray">
            <summary>
            this method returns the internal heap array as T[].
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.QueryBuilder" -->
        <member name="M:Lucene.Net.Util.QueryBuilder.#ctor(Lucene.Net.Analysis.Analyzer)">
            <summary>
            Creates a new QueryBuilder using the given analyzer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateBooleanQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateBooleanQuery(System.String,System.String,Lucene.Net.Search.Occur)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreatePhraseQuery(System.String,System.String)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreatePhraseQuery(System.String,System.String,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateMinShouldMatchQuery(System.String,System.String,System.Single)" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.QueryBuilder.Analyzer" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.QueryBuilder.EnablePositionIncrements" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.CreateFieldQuery(Lucene.Net.Analysis.Analyzer,Lucene.Net.Search.Occur,System.String,System.String,System.Boolean,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewBooleanQuery(System.Boolean)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewTermQuery(Lucene.Net.Index.Term)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewPhraseQuery" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.QueryBuilder.NewMultiPhraseQuery" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.RamUsageEstimator" -->
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_KB">
            <summary>
            One kilobyte bytes. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_MB">
            <summary>
            One megabyte bytes. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.ONE_GB">
            <summary>
            One gigabyte bytes. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.#ctor">
            <summary>
            No instantiation. </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_INT16">
            <summary>
            NOTE: This was NUM_BYTES_SHORT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_INT32">
            <summary>
            NOTE: This was NUM_BYTES_INT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_SINGLE">
            <summary>
            NOTE: This was NUM_BYTES_FLOAT in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_INT64">
            <summary>
            NOTE: This was NUM_BYTES_LONG in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_REF">
            <summary>
            Number of bytes this jvm uses to represent an object reference.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_HEADER">
            <summary>
            Number of bytes to represent an object header (no fields, no alignments).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_ARRAY_HEADER">
            <summary>
            Number of bytes to represent an array header (no content, but with alignments).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.NUM_BYTES_OBJECT_ALIGNMENT">
            <summary>
            A constant specifying the object alignment boundary inside the JVM. Objects will
            always take a full multiple of this constant, possibly wasting some space.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.primitiveSizes">
            <summary>
            Sizes of primitive classes.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RamUsageEstimator.ClassCache">
            <summary>
            Cached information about a given class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.AlignObjectSize(System.Int64)">
            <summary>
            Aligns an object size to be the next multiple of <seealso cref="!:#NUM_BYTES_OBJECT_ALIGNMENT"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Byte[])">
            <summary>
            Returns the size in bytes of the byte[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.SByte[])">
            <summary>
            Returns the size in bytes of the sbyte[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Boolean[])">
            <summary>
            Returns the size in bytes of the boolean[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Char[])">
            <summary>
            Returns the size in bytes of the char[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int16[])">
            <summary>
            Returns the size in bytes of the short[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int32[])">
            <summary>
            Returns the size in bytes of the int[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Single[])">
            <summary>
            Returns the size in bytes of the float[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Int64[])">
            <summary>
            Returns the size in bytes of the long[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Double[])">
            <summary>
            Returns the size in bytes of the double[] object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.SizeOf(System.Object)">
             <summary>
             Estimates the RAM usage by the given object. It will
             walk the object tree and sum up all referenced objects.
            
             <p><b>Resource Usage:</b> this method internally uses a set of
             every object seen during traversals so it does allocate memory
             (it isn't side-effect free). After the method exits, this memory
             should be GCed.</p>
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOf(System.Object)">
             <summary>
             Estimates a "shallow" memory usage of the given object. For arrays, this will be the
             memory taken by array storage (no subreferences will be followed). For objects, this
             will be the memory taken by the fields.
            
             JVM object alignments are also applied.
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOfInstance(System.Type)" -->
        <member name="M:Lucene.Net.Util.RamUsageEstimator.ShallowSizeOfArray(System.Array)">
            <summary>
            Return shallow size of any <code>array</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.CreateCacheEntry(System.Type)">
            <summary>
            Create a cached information about shallow size and reference fields for
            a given class.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.AdjustForField(System.Int64,System.Reflection.FieldInfo)" -->
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64)">
            <summary>
            Returns <code>size</code> in human-readable units (GB, MB, KB or bytes).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.HumanReadableUnits(System.Int64,System.IFormatProvider)">
            <summary>
            Returns <code>size</code> in human-readable units (GB, MB, KB or bytes).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.HumanSizeOf(System.Object)" -->
        <member name="T:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1">
             <summary>
             An identity hash set implemented using open addressing. No null keys are allowed.
            
             TODO: If this is useful outside this class, make it public - needs some work
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.DEFAULT_LOAD_FACTOR">
            <summary>
            Default load factor.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.MIN_CAPACITY">
            <summary>
            Minimum capacity for the set.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Keys">
            <summary>
            All of set entries. Always of power of two length.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Assigned">
            <summary>
            Cached number of assigned slots.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.LoadFactor">
            <summary>
            The load factor for this set (fraction of allocated or deleted slots before
            the buffers must be rehashed or reallocated).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.resizeThreshold">
            <summary>
            Cached capacity threshold at which we must resize the buffers.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor">
            <summary>
            Creates a hash set with the default capacity of 16.
            load factor of {@value #DEFAULT_LOAD_FACTOR}. `
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor(System.Int32)">
            <summary>
            Creates a hash set with the given capacity, load factor of
            {@value #DEFAULT_LOAD_FACTOR}.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.#ctor(System.Int32,System.Single)">
            <summary>
            Creates a hash set with the given capacity and load factor.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Add(`0)">
            <summary>
            Adds a reference to the set. Null keys are not allowed.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Contains(`0)">
            <summary>
            Checks if the set contains a given ref.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.Rehash(System.Object)" -->
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.ExpandAndRehash">
            <summary>
            Expand the internal storage buffers (capacity) or rehash current keys and
            values if there are a lot of deleted slots.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.AllocateBuffers(System.Int32)">
            <summary>
            Allocate internal buffers for a given capacity.
            </summary>
            <param name="capacity">
                     New capacity (must be a power of two). </param>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.NextCapacity(System.Int32)">
            <summary>
            Return the next possible capacity, counting from the current buffers' size.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RamUsageEstimator.IdentityHashSet`1.RoundCapacity(System.Int32)">
            <summary>
            Round the capacity to the next allowed value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RecyclingByteBlockAllocator">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.ByteBlockPool.Allocator"/> implementation that recycles unused byte
            blocks in a buffer and reuses them in subsequent calls to
            <seealso cref="!:#getByteBlock()"/>.
            <p>
            Note: this class is not thread-safe
            </p>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/>
            </summary>
            <param name="blockSize">
                     the block size in bytes </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered byte block </param>
            <param name="bytesUsed">
                     <seealso cref="T:Lucene.Net.Util.Counter"/> reference counting internally allocated bytes </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/>.
            </summary>
            <param name="blockSize">
                     the block size in bytes </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered byte block </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.#ctor">
             <summary>
             Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingByteBlockAllocator"/> with a block size of
             <seealso cref="!:ByteBlockPool#BYTE_BLOCK_SIZE"/>, upper buffered docs limit of
             <seealso cref="!:#DEFAULT_BUFFERED_BLOCKS"/> ({@value #DEFAULT_BUFFERED_BLOCKS}).
            
             </summary>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingByteBlockAllocator.NumBufferedBlocks">
            <returns> the number of currently buffered blocks </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingByteBlockAllocator.BytesUsed">
            <returns> the number of bytes currently allocated by this <seealso cref="!:Allocator"/> </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingByteBlockAllocator.MaxBufferedBlocks">
            <returns> the maximum number of buffered byte blocks </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingByteBlockAllocator.FreeBlocks(System.Int32)">
            <summary>
            Removes the given number of byte blocks from the buffer if possible.
            </summary>
            <param name="num">
                     the number of byte blocks to remove </param>
            <returns> the number of actually removed buffers </returns>
        </member>
        <member name="T:Lucene.Net.Util.RecyclingInt32BlockAllocator">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/> implementation that recycles unused int
            blocks in a buffer and reuses them in subsequent calls to
            <seealso cref="!:#getIntBlock()"/>.
            <para>
            Note: this class is not thread-safe
            </para>
            <para>
            NOTE: This was RecyclingIntBlockAllocator in Lucene
            </para>
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Counter)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingInt32BlockAllocator"/>
            </summary>
            <param name="blockSize">
                     the block size in bytes </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered int block </param>
            <param name="bytesUsed">
                     <seealso cref="T:Lucene.Net.Util.Counter"/> reference counting internally allocated bytes </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <seealso cref="T:Lucene.Net.Util.RecyclingInt32BlockAllocator"/>.
            </summary>
            <param name="blockSize">
                     the size of each block returned by this allocator </param>
            <param name="maxBufferedBlocks">
                     maximum number of buffered int blocks </param>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.#ctor">
             <summary>
             Creates a new <see cref="T:Lucene.Net.Util.RecyclingInt32BlockAllocator"/> with a block size of
             <see cref="F:Lucene.Net.Util.Int32BlockPool.INT32_BLOCK_SIZE"/>, upper buffered docs limit of
             <see cref="F:Lucene.Net.Util.RecyclingInt32BlockAllocator.DEFAULT_BUFFERED_BLOCKS"/>.
            
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.GetInt32Block">
            <summary>
            NOTE: This was getIntBlock() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.RecycleInt32Blocks(System.Int32[][],System.Int32,System.Int32)">
            <summary>
            NOTE: This was recycleIntBlocks in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingInt32BlockAllocator.NumBufferedBlocks">
            <returns> the number of currently buffered blocks </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingInt32BlockAllocator.BytesUsed">
            <returns> the number of bytes currently allocated by this <seealso cref="T:Lucene.Net.Util.Int32BlockPool.Allocator"/> </returns>
        </member>
        <member name="P:Lucene.Net.Util.RecyclingInt32BlockAllocator.MaxBufferedBlocks">
            <returns> the maximum number of buffered byte blocks </returns>
        </member>
        <member name="M:Lucene.Net.Util.RecyclingInt32BlockAllocator.FreeBlocks(System.Int32)">
            <summary>
            Removes the given number of int blocks from the buffer if possible.
            </summary>
            <param name="num">
                     the number of int blocks to remove </param>
            <returns> the number of actually removed buffers </returns>
        </member>
        <member name="T:Lucene.Net.Util.RefCount`1">
            <summary>
            Manages reference counting for a given object. Extensions can override
            <see cref="M:Lucene.Net.Util.RefCount`1.Release"/> to do custom logic when reference counting hits 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.Release">
            <summary>
            Called when reference counting hits 0. By default this method does nothing,
            but extensions can override to e.g. release resources attached to object
            that is managed by this class.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.DecRef">
            <summary>
            Decrements the reference counting of this object. When reference counting
            hits 0, calls <see cref="M:Lucene.Net.Util.RefCount`1.Release"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.GetRefCount">
            <summary>
            Returns the current reference count. </summary>
        </member>
        <member name="M:Lucene.Net.Util.RefCount`1.IncRef">
            <summary>
            Increments the reference count. Calls to this method must be matched with
            calls to <see cref="M:Lucene.Net.Util.RefCount`1.DecRef"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.RollingBuffer`1">
             <summary>
             Acts like forever growing T[], but internally uses a
              circular buffer to reuse instances of T.
            
              @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.RollingBuffer`1.Get(System.Int32)">
            <summary>
            Get T instance for this absolute position;
             this is allowed to be arbitrarily far "in the
             future" but cannot be before the last freeBefore.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.RollingBuffer`1.MaxPos">
            <summary>
            Returns the maximum position looked up, or -1 if no
             position has been looked up sinc reset/init.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.SentinelInt32Set">
             <summary>
             A native int hash-based set where one value is reserved to mean "EMPTY" internally. The space overhead is fairly low
             as there is only one power-of-two sized int[] to hold the values.  The set is re-hashed when adding a value that
             would make it >= 75% full.  Consider extending and over-riding <seealso cref="!:#hash(int)"/> if the values might be poor
             hash keys; Lucene docids should be fine.
             The internal fields are exposed publicly to enable more efficient use at the expense of better O-O principles.
             <para/>
             To iterate over the integers held in this set, simply use code like this:
             <code>
             SentinelIntSet set = ...
             for (int v : set.keys) {
               if (v == set.emptyVal)
                 continue;
               //use v...
             }</code>
             <para/>
             NOTE: This was SentinelIntSet in Lucene
            
             @lucene.internal
             </summary>
        </member>
        <member name="P:Lucene.Net.Util.SentinelInt32Set.Keys">
            <summary>
            A power-of-2 over-sized array holding the integers in the set along with empty values. </summary>
        </member>
        <member name="P:Lucene.Net.Util.SentinelInt32Set.Count">
            <summary>
            The number of integers in this set. </summary>
        </member>
        <member name="P:Lucene.Net.Util.SentinelInt32Set.RehashCount">
            <summary>
            the count at which a rehash should be done </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.#ctor(System.Int32,System.Int32)">
            
             <param name="size">  The minimum number of elements this set should be able to hold without rehashing
                          (i.e. the slots are guaranteed not to change) </param>
             <param name="emptyVal"> The integer value to use for EMPTY </param>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Hash(System.Int32)">
            <summary>
            (internal) Return the hash for the key. The default implementation just returns the key,
            which is not appropriate for general purpose use.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.GetSlot(System.Int32)">
            <summary>
            (internal) Returns the slot for this key </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Find(System.Int32)">
            <summary>
            (internal) Returns the slot for this key, or -slot-1 if not found </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Exists(System.Int32)">
            <summary>
            Does this set contain the specified integer? </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Put(System.Int32)">
            <summary>
            Puts this integer (key) in the set, and returns the slot index it was added to.
            It rehashes if adding it would make the set more than 75% full.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SentinelInt32Set.Rehash">
            <summary>
            (internal) Rehashes by doubling {@code int[] key} and filling with the old values. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SetOnce`1">
            <summary>
            A convenient class which offers a semi-immutable object wrapper
            implementation which allows one to set the value of an object exactly once,
            and retrieve it many times. If <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/> is called more than once,
            <see cref="T:Lucene.Net.Util.AlreadySetException"/> is thrown and the operation
            will fail.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.#ctor">
            <summary>
            A default constructor which does not set the internal object, and allows
            setting it by calling <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.#ctor(`0)">
            <summary>
            Creates a new instance with the internal object set to the given object.
            Note that any calls to <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/> afterwards will result in
            <see cref="T:Lucene.Net.Util.AlreadySetException"/>
            </summary>
            <exception cref="T:Lucene.Net.Util.AlreadySetException"> if called more than once </exception>
            <seealso cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.Set(`0)">
            <summary>
            Sets the given object. If the object has already been set, an exception is thrown. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SetOnce`1.Get">
            <summary>
            Returns the object set by <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.AlreadySetException">
            <summary>
            Thrown when <see cref="M:Lucene.Net.Util.SetOnce`1.Set(`0)"/> is called more than once. </summary>
        </member>
        <member name="M:Lucene.Net.Util.AlreadySetException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of this class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/> that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:Lucene.Net.Util.SloppyMath">
            <summary>
            Math functions that trade off accuracy for speed. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.Haversin(System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Returns the distance in kilometers between two points
            specified in decimal degrees (latitude/longitude). </summary>
            <param name="lat1"> Latitude of the first point. </param>
            <param name="lon1"> Longitude of the first point. </param>
            <param name="lat2"> Latitude of the second point. </param>
            <param name="lon2"> Longitude of the second point. </param>
            <returns> distance in kilometers. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SloppyMath.Cos(System.Double)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SloppyMath.Asin(System.Double)" -->
        <member name="M:Lucene.Net.Util.SloppyMath.EarthDiameter(System.Double)">
            <summary>
            Return an approximate value of the diameter of the earth at the given latitude, in kilometers. </summary>
        </member>
        <member name="M:Lucene.Net.Util.SloppyMath.#cctor">
            <summary>
            Initializes look-up tables. </summary>
        </member>
        <member name="T:Lucene.Net.Util.SmallSingle">
             <summary>
             Floating point numbers smaller than 32 bits.
             <para/>
             NOTE: This was SmallFloat in Lucene
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.#ctor">
            <summary>
            No instance </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.SmallSingle.SingleToByte(System.Single,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToSByte(System.Single,System.Int32,System.Int32)">
            <summary>
            Converts a 32 bit <see cref="T:System.Single"/> to an 8 bit <see cref="T:System.Single"/>.
            <para/>Values less than zero are all mapped to zero.
            <para/>Values are truncated (rounded down) to the nearest 8 bit value.
            <para/>Values between zero and the smallest representable value
            are rounded up.
            <para/>
            NOTE: This was floatToByte() in Lucene
            </summary>
            <param name="f"> the 32 bit <see cref="T:System.Single"/> to be converted to an 8 bit <see cref="T:System.Single"/> (<see cref="T:System.SByte"/>) </param>
            <param name="numMantissaBits"> the number of mantissa bits to use in the byte, with the remainder to be used in the exponent </param>
            <param name="zeroExp"> the zero-point in the range of exponent values </param>
            <returns> the 8 bit float representation </returns>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.ByteToSingle(System.Byte,System.Int32,System.Int32)">
            <summary>
            Converts an 8 bit <see cref="T:System.Single"/> to a 32 bit <see cref="T:System.Single"/>. 
            <para/>
            NOTE: This was byteToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SByteToSingle(System.SByte,System.Int32,System.Int32)">
            <summary>
            Converts an 8 bit <see cref="T:System.Single"/> to a 32 bit <see cref="T:System.Single"/>. 
            <para/>
            NOTE: This was byteToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToByte315(System.Single)">
            <summary>
            SingleToSByte((byte)b, mantissaBits=3, zeroExponent=15)
            <para/>smallest non-zero value = 5.820766E-10
            <para/>largest value = 7.5161928E9
            <para/>epsilon = 0.125
            <para/>
            NOTE: This was floatToByte315() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToSByte315(System.Single)">
            <summary>
            SingleToSByte(b, mantissaBits=3, zeroExponent=15)
            <para/>smallest non-zero value = 5.820766E-10
            <para/>largest value = 7.5161928E9
            <para/>epsilon = 0.125
            <para/>
            NOTE: This was floatToByte315() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.Byte315ToSingle(System.Byte)">
            <summary>
            ByteToSingle(b, mantissaBits=3, zeroExponent=15) 
            <para/>
            NOTE: This was byte315ToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SByte315ToSingle(System.SByte)">
            <summary>
            SByteToSingle(b, mantissaBits=3, zeroExponent=15) 
            <para/>
            NOTE: This was byte315ToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToByte52(System.Single)">
            <summary>
            SingleToByte(b, mantissaBits=5, zeroExponent=2)
            <para/>smallest nonzero value = 0.033203125
            <para/>largest value = 1984.0
            <para/>epsilon = 0.03125
            <para/>
            NOTE: This was floatToByte52() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SingleToSByte52(System.Single)">
            <summary>
            SingleToSByte(b, mantissaBits=5, zeroExponent=2)
            <para/>smallest nonzero value = 0.033203125
            <para/>largest value = 1984.0
            <para/>epsilon = 0.03125
            <para/>
            NOTE: This was floatToByte52() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.Byte52ToSingle(System.Byte)">
            <summary>
            ByteToFloat(b, mantissaBits=5, zeroExponent=2) 
            <para/>
            NOTE: This was byte52ToFloat() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SmallSingle.SByte52ToSingle(System.SByte)">
            <summary>
            SByteToFloat(b, mantissaBits=5, zeroExponent=2) 
            <para/>
            NOTE: This was byte52ToFloat() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Sorter">
            <summary>
            Base class for sorting algorithms implementations.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.#ctor">
            <summary>
            Sole constructor, used for inheritance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Compare(System.Int32,System.Int32)">
            <summary>
            Compare entries found in slots <code>i</code> and <code>j</code>.
             The contract for the returned value is the same as
             <seealso cref="!:Comparer#compare(Object, Object)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Swap(System.Int32,System.Int32)">
            <summary>
            Swap values at slots <code>i</code> and <code>j</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Sorter.Sort(System.Int32,System.Int32)">
            <summary>
            Sort the slice which starts at <code>from</code> (inclusive) and ends at
             <code>to</code> (exclusive).
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.SPIClassIterator`1">
             <summary>
             Helper class for loading SPI classes from classpath (META-INF files).
             this is a light impl of <seealso cref="!:java.util.ServiceLoader"/> but is guaranteed to
             be bug-free regarding classpath order and does not instantiate or initialize
             the classes found.
            
             @lucene.internal
             </summary>
            
        </member>
        <member name="T:Lucene.Net.Util.SPIClassIterator`1.DotNetFrameworkFilter">
            <summary>
            Assembly filter logic from:
            https://raw.githubusercontent.com/Microsoft/dotnet-apiport/master/src/Microsoft.Fx.Portability/Analyzer/DotNetFrameworkFilter.cs
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.SPIClassIterator`1.DotNetFrameworkFilter.s_microsoftKeys">
            <summary>
            These keys are a collection of public key tokens derived from all the reference assemblies in
            "%ProgramFiles%\Reference Assemblies\Microsoft" on a Windows 10 machine with VS 2015 installed
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SPIClassIterator`1.DotNetFrameworkFilter.IsFrameworkAssembly(System.Reflection.Assembly)">
            <summary>
            Gets a best guess as to whether this assembly is a .NET Framework assembly or not.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.SPIClassIterator`1.DotNetFrameworkFilter.IsFrameworkAssembly(System.Reflection.AssemblyName)">
            <summary>
            Gets a best guess as to whether this assembly is a .NET Framework assembly or not.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.StringHelper">
             <summary>
             Methods for manipulating strings.
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.StringHelper.interner">
            <summary> Expert:
            The StringInterner implementation used by Lucene.
            This shouldn't be changed to an incompatible implementation after other Lucene APIs have been used.
            LUCENENET specific.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.Intern(System.String)">
            <summary>Returns the same string object for all equal strings.</summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.BytesDifference(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Compares two <seealso cref="T:Lucene.Net.Util.BytesRef"/>, element by element, and returns the
            number of elements common to both arrays.
            </summary>
            <param name="left"> The first <seealso cref="T:Lucene.Net.Util.BytesRef"/> to compare </param>
            <param name="right"> The second <seealso cref="T:Lucene.Net.Util.BytesRef"/> to compare </param>
            <returns> The number of common elements. </returns>
        </member>
        <member name="P:Lucene.Net.Util.StringHelper.VersionComparer">
            <returns> a Comparer over versioned strings such as X.YY.Z
            @lucene.internal </returns>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.StartsWith(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <code>true</code> iff the ref starts with the given prefix.
            Otherwise <code>false</code>.
            </summary>
            <param name="ref">
                     the <seealso cref="T:Lucene.Net.Util.BytesRef"/> to test </param>
            <param name="prefix">
                     the expected prefix </param>
            <returns> Returns <code>true</code> iff the ref starts with the given prefix.
                    Otherwise <code>false</code>. </returns>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.EndsWith(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Returns <code>true</code> iff the ref ends with the given suffix. Otherwise
            <code>false</code>.
            </summary>
            <param name="ref">
                     the <seealso cref="T:Lucene.Net.Util.BytesRef"/> to test </param>
            <param name="suffix">
                     the expected suffix </param>
            <returns> Returns <code>true</code> iff the ref ends with the given suffix.
                    Otherwise <code>false</code>. </returns>
        </member>
        <member name="F:Lucene.Net.Util.StringHelper.good_fast_hash_seed">
            <summary>
            Pass this as the seed to <seealso cref="!:#murmurhash3_x86_32"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.StringHelper.Murmurhash3_x86_32(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the MurmurHash3_x86_32 hash.
            Original source/tests at https://github.com/yonik/java_util/
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.TimSorter" -->
        <member name="M:Lucene.Net.Util.TimSorter.#ctor(System.Int32)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.TimSorter"/>. </summary>
            <param name="maxTempSlots"> the <a href="#maxTempSlots">maximum amount of extra memory to run merges</a> </param>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.MinRun(System.Int32)">
            <summary>
            Minimum run length for an array of length <code>length</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.NextRun">
            <summary>
            Compute the length of the next run, make the run sorted and return its
             length.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Copy(System.Int32,System.Int32)">
            <summary>
            Copy data from slot <code>src</code> to slot <code>dest</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Save(System.Int32,System.Int32)">
            <summary>
            Save all elements between slots <code>i</code> and <code>i+len</code>
             into the temporary storage.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.Restore(System.Int32,System.Int32)">
            <summary>
            Restore element <code>j</code> from the temporary storage into slot <code>i</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.TimSorter.CompareSaved(System.Int32,System.Int32)">
            <summary>
            Compare element <code>i</code> from the temporary storage with element
             <code>j</code> from the slice to sort, similarly to
             <seealso cref="!:#compare(int, int)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.ToStringUtils">
            <summary>
            Helper methods to ease implementing <seealso cref="!:Object#toString()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ToStringUtils.Boost(System.Single)">
            <summary>
            for printing boost only if not 1.0
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.ToStringUtils.Int64Hex(System.Int64)">
            <summary>
            NOTE: This was longHex() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.UnicodeUtil">
             <summary>
             Class to encode java's UTF16 char[] into UTF8 byte[]
             without always allocating a new byte[] as
             String.getBytes(StandardCharsets.UTF_8) does.
            
             @lucene.internal
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.UnicodeUtil.BIG_TERM" -->
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.Char[],System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from a char[] source, starting at
             offset for length chars. After encoding, result.offset will always be 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(Lucene.Net.Support.ICharSequence,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from this <see cref="T:Lucene.Net.Support.ICharSequence"/>, starting at offset
             for length characters. After encoding, result.offset will always be 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.UTF16toUTF8(System.String,System.Int32,System.Int32,Lucene.Net.Util.BytesRef)">
            <summary>
            Encode characters from this <see cref="T:System.String"/>, starting at offset
            for length characters. After encoding, result.offset will always be 0.
            LUCENENET specific.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.CodePointCount(Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF32(Lucene.Net.Util.BytesRef,Lucene.Net.Util.Int32sRef)" -->
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_SHIFT_">
            <summary>
            Shift value for lead surrogate to form a supplementary character. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.TRAIL_SURROGATE_MASK_">
            <summary>
            Mask to retrieve the significant value from a trail surrogate. </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.TRAIL_SURROGATE_MIN_VALUE">
            <summary>
            Trail surrogate minimum value </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_MIN_VALUE">
            <summary>
            Lead surrogate minimum value </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.SUPPLEMENTARY_MIN_VALUE">
            <summary>
            The minimum value for Supplementary code points </summary>
        </member>
        <member name="F:Lucene.Net.Util.UnicodeUtil.LEAD_SURROGATE_OFFSET_">
            <summary>
            Value that all lead surrogate starts with </summary>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.NewString(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Cover JDK 1.5 API. Create a String from an array of codePoints.
            </summary>
            <param name="codePoints"> The code array </param>
            <param name="offset"> The start of the text in the code point array </param>
            <param name="count"> The number of code points </param>
            <returns> a String representing the code points between offset and count </returns>
            <exception cref="!:IllegalArgumentException"> If an invalid code point is encountered </exception>
            <exception cref="!:IndexOutOfBoundsException"> If the offset or count are out of bounds. </exception>
        </member>
        <member name="M:Lucene.Net.Util.UnicodeUtil.ToCharArray(System.Int32[],System.Int32,System.Int32)">
            <summary>
            Generates char array that represents the provided input code points.
            
            LUCENENET specific.
            </summary>
            <param name="codePoints"> The code array </param>
            <param name="offset"> The start of the text in the code point array </param>
            <param name="count"> The number of code points </param>
            <returns> a char array representing the code points between offset and count </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(System.Byte[],System.Int32,System.Int32,Lucene.Net.Util.CharsRef)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.UnicodeUtil.UTF8toUTF16(Lucene.Net.Util.BytesRef,Lucene.Net.Util.CharsRef)" -->
        <member name="T:Lucene.Net.Util.LuceneVersion">
             <summary>
             Use by certain classes to match version compatibility
             across releases of Lucene.
            
             <p><b>WARNING</b>: When changing the version parameter
             that you supply to components in Lucene, do not simply
             change the version at search-time, but instead also adjust
             your indexing code to match, and re-index.</p>
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_30">
            <summary>
            Match settings and bugs in Lucene's 3.0 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_31">
            <summary>
            Match settings and bugs in Lucene's 3.1 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_32">
            <summary>
            Match settings and bugs in Lucene's 3.2 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_33">
            <summary>
            Match settings and bugs in Lucene's 3.3 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_34">
            <summary>
            Match settings and bugs in Lucene's 3.4 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_35">
            <summary>
            Match settings and bugs in Lucene's 3.5 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_36">
            <summary>
            Match settings and bugs in Lucene's 3.6 release. </summary>
            @deprecated (4.0) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_40">
            <summary>
            Match settings and bugs in Lucene's 3.6 release. </summary>
            @deprecated (4.1) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_41">
            <summary>
            Match settings and bugs in Lucene's 4.1 release. </summary>
            @deprecated (4.2) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_42">
            <summary>
            Match settings and bugs in Lucene's 4.2 release. </summary>
            @deprecated (4.3) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_43">
            <summary>
            Match settings and bugs in Lucene's 4.3 release. </summary>
            @deprecated (4.4) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_44">
            <summary>
            Match settings and bugs in Lucene's 4.4 release. </summary>
            @deprecated (4.5) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_45">
            <summary>
            Match settings and bugs in Lucene's 4.5 release. </summary>
            @deprecated (4.6) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_46">
            <summary>
            Match settings and bugs in Lucene's 4.6 release. </summary>
            @deprecated (4.7) Use latest
        </member>
        <member name="F:Lucene.Net.Util.LuceneVersion.LUCENE_47">
            <summary>
            Match settings and bugs in Lucene's 4.7 release. </summary>
            @deprecated (4.8) Use latest
        </member>
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.LuceneVersion.LUCENE_48" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.LuceneVersion.LUCENE_CURRENT" -->
        <member name="T:Lucene.Net.Util.LuceneVersionExtensions">
            <summary>
            Extension methods to the <see cref="T:Lucene.Net.Util.LuceneVersion"/> enumeration to provide
            version comparison and parsing functionality.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet">
            <summary>
            <seealso cref="T:Lucene.Net.Search.DocIdSet"/> implementation based on word-aligned hybrid encoding on
            words of 8 bits.
            <p>this implementation doesn't support random-access but has a fast
            <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> which can advance in logarithmic time thanks to
            an index.</p>
            <p>The compression scheme is simplistic and should work well with sparse and
            very dense doc id sets while being only slightly larger than a
            <seealso cref="T:Lucene.Net.Util.FixedBitSet"/> for incompressible sets (overhead&lt;2% in the worst
            case) in spite of the index.</p>
            <p><b>Format</b>: The format is byte-aligned. An 8-bits word is either clean,
            meaning composed only of zeros or ones, or dirty, meaning that it contains
            between 1 and 7 bits set. The idea is to encode sequences of clean words
            using run-length encoding and to leave sequences of dirty words as-is.</p>
            <table>
              <tr><th>Token</th><th>Clean length+</th><th>Dirty length+</th><th>Dirty words</th></tr>
              <tr><td>1 byte</td><td>0-n bytes</td><td>0-n bytes</td><td>0-n bytes</td></tr>
            </table>
            <ul>
              <li><b>Token</b> encodes whether clean means full of zeros or ones in the
            first bit, the number of clean words minus 2 on the next 3 bits and the
            number of dirty words on the last 4 bits. The higher-order bit is a
            continuation bit, meaning that the number is incomplete and needs additional
            bytes to be read.</li>
              <li><b>Clean length+</b>: If clean length has its higher-order bit set,
            you need to read a <seealso cref="!:DataInput#readVInt() vint"/>, shift it by 3 bits on
            the left side and add it to the 3 bits which have been read in the token.</li>
              <li><b>Dirty length+</b> works the same way as <b>Clean length+</b> but
            on 4 bits and for the length of dirty words.</li>
              <li><b>Dirty words</b> are the dirty words, there are <b>Dirty length</b>
            of them.</li>
            </ul>
            <p>this format cannot encode sequences of less than 2 clean words and 0 dirty
            word. The reason is that if you find a single clean word, you should rather
            encode it as a dirty word. this takes the same space as starting a new
            sequence (since you need one byte for the token) but will be lighter to
            decode. There is however an exception for the first sequence. Since the first
            sequence may start directly with a dirty word, the clean length is encoded
            directly, without subtracting 2.</p>
            <p>There is an additional restriction on the format: the sequence of dirty
            words is not allowed to contain two consecutive clean words. this restriction
            exists to make sure no space is wasted and to make sure iterators can read
            the next doc ID by reading at most 2 dirty words.</p>
            @lucene.experimental
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.WAH8DocIdSet.DEFAULT_INDEX_INTERVAL">
            <summary>
            Default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Intersect(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet})">
            <summary>
            Same as <seealso cref="!:#intersect(Collection, int)"/> with the default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Intersect(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)">
            <summary>
            Compute the intersection of the provided sets. this method is much faster than
            computing the intersection manually since it operates directly at the byte level.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet})">
            <summary>
            Same as <seealso cref="!:#union(Collection, int)"/> with the default index interval. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.WAH8DocIdSet},System.Int32)">
            <summary>
            Compute the union of the provided sets. this method is much faster than
            computing the union manually since it operates directly at the byte level.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet.WordBuilder">
            <summary>
            Word-based builder. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.WordBuilder.SetIndexInterval(System.Int32)">
            <summary>
            Set the index interval. Smaller index intervals improve performance of
             <seealso cref="!:DocIdSetIterator#advance(int)"/> but make the <seealso cref="T:Lucene.Net.Search.DocIdSet"/>
             larger. An index interval <code>i</code> makes the index add an overhead
             which is at most <code>4/i</code>, but likely much less.The default index
             interval is <code>8</code>, meaning the index has an overhead of at most
             50%. To disable indexing, you can pass <see cref="F:System.Int32.MaxValue"/> as an
             index interval.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.WordBuilder.Build">
            <summary>
            Build a new <seealso cref="T:Lucene.Net.Util.WAH8DocIdSet"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.WAH8DocIdSet.Builder">
            <summary>
            A builder for <seealso cref="T:Lucene.Net.Util.WAH8DocIdSet"/>s. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.#ctor">
            <summary>
            Sole constructor </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.Add(System.Int32)">
            <summary>
            Add a document to this builder. Documents must be added in order. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Builder.Add(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Add the content of the provided <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.Cardinality">
            <summary>
            Return the number of documents in this <seealso cref="T:Lucene.Net.Search.DocIdSet"/> in constant time. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WAH8DocIdSet.RamBytesUsed">
            <summary>
            Return the memory usage of this class in bytes. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.WeakIdentityMap`2" -->
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.NewHashMap">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a non-synchronized <seealso cref="!:HashMap"/>.
            The map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.NewHashMap(System.Boolean)">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a non-synchronized <seealso cref="!:HashMap"/>. </summary>
            <param name="reapOnRead"> controls if the map <a href="#reapInfo">cleans up the reference queue on every read operation</a>. </param>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.NewConcurrentHashMap">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a <seealso cref="!:ConcurrentHashMap"/>.
            The map <a href="#reapInfo">cleans up the reference queue on every read operation</a>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.NewConcurrentHashMap(System.Boolean)">
            <summary>
            Creates a new {@code WeakIdentityMap} based on a <seealso cref="!:ConcurrentHashMap"/>. </summary>
            <param name="reapOnRead"> controls if the map <a href="#reapInfo">cleans up the reference queue on every read operation</a>. </param>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.#ctor(System.Collections.Generic.IDictionary{Lucene.Net.Util.WeakIdentityMap{`0,`1}.IdentityWeakReference,`1},System.Boolean)">
            <summary>
            Private only constructor, to create use the static factory methods. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Clear">
            <summary>
            Removes all of the mappings from this map. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.ContainsKey(System.Object)">
            <summary>
            Returns {@code true} if this map contains a mapping for the specified key. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Get(System.Object)">
            <summary>
            Returns the value to which the specified key is mapped. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Put(`0,`1)">
            <summary>
            Associates the specified value with the specified key in this map.
            If the map previously contained a mapping for this key, the old value
            is replaced.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.WeakIdentityMap`2.KeyWrapper">
            <summary>
            LUCENENET specific class to allow the 
            GetEnumerator() method to be overridden
            for the keys so we can return an enumerator
            that is smart enough to clean up the dead keys
            and also so that MoveNext() returns false in the
            event there are no more values left (instead of returning
            a null value in an extra enumeration).
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.WeakIdentityMap`2.IsEmpty">
            <summary>
            Returns {@code true} if this map contains no key-value mappings. </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.Remove(System.Object)">
            <summary>
            Removes the mapping for a key from this weak hash map if it is present.
            Returns the value to which this map previously associated the key,
            or {@code null} if the map contained no mapping for the key.
            A return value of {@code null} does not necessarily indicate that
            the map contained.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.WeakIdentityMap`2.Count">
            <summary>
            Returns the number of key-value mappings in this map. this result is a snapshot,
            and may not reflect unprocessed entries that will be removed before next
            attempted access because they are no longer referenced.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.WeakIdentityMap`2.GetValueEnumerator">
            <summary>
            Returns an iterator over all values of this map.
            this iterator may return values whose key is already
            garbage collected while iterator is consumed,
            especially if {@code reapOnRead} is {@code false}.
            <para/>
            NOTE: This was valueIterator() in Lucene.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.WeakIdentityMap`2.Reap" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.Automaton" -->
        <!-- Badly formed XML comment ignored for member "F:Lucene.Net.Util.Automaton.Automaton.MINIMIZE_HOPCROFT" -->
        <member name="F:Lucene.Net.Util.Automaton.Automaton.minimization">
            <summary>
            Selects minimization algorithm (default: <code>MINIMIZE_HOPCROFT</code>). </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.initial">
            <summary>
            Initial state of this automaton. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.deterministic">
            <summary>
            If true, then this automaton is definitely deterministic (i.e., there are
            no choices for any run, but a run may crash).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.info">
            <summary>
            Extra data associated with this automaton. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.singleton">
            <summary>
            Singleton string. Null if not applicable. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.minimize_always">
            <summary>
            Minimize always flag. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.Automaton.allow_mutation">
            <summary>
            Selects whether operations may modify the input automata (default:
            <code>false</code>).
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.Automaton.#ctor(Lucene.Net.Util.Automaton.State)" -->
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SetMinimization(System.Int32)">
            <summary>
            Selects minimization algorithm (default: <code>MINIMIZE_HOPCROFT</code>).
            </summary>
            <param name="algorithm"> minimization algorithm </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SetMinimizeAlways(System.Boolean)">
            <summary>
            Sets or resets minimize always flag. If this flag is set, then
            <seealso cref="!:MinimizationOperations#minimize(Automaton)"/> will automatically be
            invoked after all operations that otherwise may produce non-minimal
            automata. By default, the flag is not set.
            </summary>
            <param name="flag"> if true, the flag is set </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SetAllowMutate(System.Boolean)">
            <summary>
            Sets or resets allow mutate flag. If this flag is set, then all automata
            operations may modify automata given as input; otherwise, operations will
            always leave input automata languages unmodified. By default, the flag is
            not set.
            </summary>
            <param name="flag"> if true, the flag is set </param>
            <returns> previous value of the flag </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.AllowMutate">
            <summary>
            Returns the state of the allow mutate flag. If this flag is set, then all
            automata operations may modify automata given as input; otherwise,
            operations will always leave input automata languages unmodified. By
            default, the flag is not set.
            </summary>
            <returns> current value of the flag </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Singleton">
            <summary>
            Returns the singleton string for this automaton. An automaton that accepts
            exactly one string <i>may</i> be represented in singleton mode. In that
            case, this method may be used to obtain the string.
            </summary>
            <returns> string, null if this automaton is not in singleton mode. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetInitialState">
            <summary>
            Gets initial state.
            </summary>
            <returns> state </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.IsDeterministic">
            <summary>
            Returns deterministic flag for this automaton.
            </summary>
            <returns> true if the automaton is definitely deterministic, false if the
                    automaton may be nondeterministic </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.Info">
            <summary>
            Associates extra information with this automaton.
            </summary>
            <param name="info"> extra information </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetAcceptStates">
            <summary>
            Returns the set of reachable accept states.
            </summary>
            <returns> set of <seealso cref="T:Lucene.Net.Util.Automaton.State"/> objects </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Totalize">
            <summary>
            Adds transitions to explicit crash state to ensure that transition function
            is total.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.Automaton.RestoreInvariant" -->
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Reduce">
            <summary>
            Reduces this automaton. An automaton is "reduced" by combining overlapping
            and adjacent edge intervals with same destination.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetStartPoints">
            <summary>
            Returns sorted array of all interval start points.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetLiveStates">
            <summary>
            Returns the set of live states. A state is "live" if an accept state is
            reachable from it.
            </summary>
            <returns> set of <seealso cref="T:Lucene.Net.Util.Automaton.State"/> objects </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.RemoveDeadTransitions">
            <summary>
            Removes transitions to dead states and calls <seealso cref="!:#reduce()"/>.
            (A state is "dead" if no accept state is
            reachable from it.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetSortedTransitions">
            <summary>
            Returns a sorted array of transitions for each state (and sets state
            numbers).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ExpandSingleton">
            <summary>
            Expands singleton representation to normal representation. Does nothing if
            not in singleton representation.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetNumberOfStates">
            <summary>
            Returns the number of states in this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.GetNumberOfTransitions">
            <summary>
            Returns the number of transitions in this automaton. this number is counted
            as the total number of edges, where one edge may be a character interval.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ToString">
            <summary>
            Returns a string representation of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.ToDot">
            <summary>
            Returns <a href="http://www.research.att.com/sw/tools/graphviz/"
            target="_top">Graphviz Dot</a> representation of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneExpanded">
            <summary>
            Returns a clone of this automaton, expands if singleton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneExpandedIfRequired">
            <summary>
            Returns a clone of this automaton unless <code>allow_mutation</code> is
            set, expands if singleton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Clone">
            <summary>
            Returns a clone of this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.CloneIfRequired">
            <summary>
            Returns a clone of this automaton, or this automaton itself if
            <code>allow_mutation</code> flag is set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Concatenate(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#concatenate(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Concatenate(System.Collections.Generic.IList{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            See <seealso cref="!:BasicOperations#concatenate(List)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Optional">
            <summary>
            See <seealso cref="!:BasicOperations#optional(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat">
            <summary>
            See <seealso cref="!:BasicOperations#repeat(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat(System.Int32)">
            <summary>
            See <seealso cref="!:BasicOperations#repeat(Automaton, int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Repeat(System.Int32,System.Int32)">
            <summary>
            See <seealso cref="!:BasicOperations#repeat(Automaton, int, int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Complement">
            <summary>
            See <seealso cref="!:BasicOperations#complement(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Minus(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#minus(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Intersection(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#intersection(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.SubsetOf(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#subsetOf(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Union(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:BasicOperations#union(Automaton, Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            See <seealso cref="!:BasicOperations#union(Collection)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Determinize">
            <summary>
            See <seealso cref="!:BasicOperations#determinize(Automaton)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Automaton.IsEmptyString">
            <summary>
            See <seealso cref="!:BasicOperations#isEmptyString(Automaton)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Automaton.Minimize(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            See <seealso cref="!:MinimizationOperations#minimize(Automaton)"/>. Returns the
            automaton being given as argument.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.IAutomatonProvider">
             <summary>
             Automaton provider for <code>RegExp.</code>
             <seealso cref="!:RegExp#toAutomaton(AutomatonProvider)"/>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.IAutomatonProvider.GetAutomaton(System.String)">
            <summary>
            Returns automaton of the given name.
            </summary>
            <param name="name"> automaton name </param>
            <returns> automaton </returns>
            <exception cref="!:IOException"> if errors occur </exception>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.BasicAutomata">
             <summary>
             Construction of basic automata.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeEmpty">
            <summary>
            Returns a new (deterministic) automaton with the empty language.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeEmptyString">
            <summary>
            Returns a new (deterministic) automaton that accepts only the empty string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeAnyString">
            <summary>
            Returns a new (deterministic) automaton that accepts all strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeAnyChar">
            <summary>
            Returns a new (deterministic) automaton that accepts any single codepoint.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeChar(System.Int32)">
            <summary>
            Returns a new (deterministic) automaton that accepts a single codepoint of
            the given value.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeCharRange(System.Int32,System.Int32)">
            <summary>
            Returns a new (deterministic) automaton that accepts a single codepoint whose
            value is in the given interval (including both end points).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AnyOfRightLength(System.String,System.Int32)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of length
            x.substring(n).length().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AtLeast(System.String,System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State},System.Boolean)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value at least
            x.substring(n) and length x.substring(n).length().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.AtMost(System.String,System.Int32)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value at most
            x.substring(n) and length x.substring(n).length().
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.Between(System.String,System.String,System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State},System.Boolean)">
            <summary>
            Constructs sub-automaton corresponding to decimal numbers of value between
            x.substring(n) and y.substring(n) and of length x.substring(n).length()
            (which must be equal to y.substring(n).length()).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeInterval(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns a new automaton that accepts strings representing decimal
            non-negative integers in the given interval.
            </summary>
            <param name="min"> minimal value of interval </param>
            <param name="max"> maximal value of interval (both end points are included in the
                     interval) </param>
            <param name="digits"> if >0, use fixed number of digits (strings must be prefixed
                     by 0's to obtain the right length) - otherwise, the number of
                     digits is not fixed </param>
            <exception cref="!:IllegalArgumentException"> if min>max or if numbers in the
                         interval cannot be expressed with the given fixed number of
                         digits </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeString(System.String)">
            <summary>
            Returns a new (deterministic) automaton that accepts the single given
            string.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicAutomata.MakeStringUnion(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})">
            <summary>
            Returns a new (deterministic and minimal) automaton that accepts the union
            of the given collection of <seealso cref="T:Lucene.Net.Util.BytesRef"/>s representing UTF-8 encoded
            strings.
            </summary>
            <param name="utf8Strings">
                     The input strings, UTF-8 encoded. The collection must be in sorted
                     order.
            </param>
            <returns> An <seealso cref="T:Lucene.Net.Util.Automaton.Automaton"/> accepting all input strings. The resulting
                    automaton is codepoint based (full unicode codepoints on
                    transitions). </returns>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.BasicOperations">
             <summary>
             Basic automata operations.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Concatenate(System.Collections.Generic.IList{Lucene.Net.Util.Automaton.Automaton})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Optional(Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Repeat(Lucene.Net.Util.Automaton.Automaton,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Complement(Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Minus(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Intersection(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.SameLanguage(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if these two automata accept exactly the
             same language.  this is a costly computation!  Note
             also that a1 and a2 will be determinized as a side
             effect.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.SubsetOf(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Union(Lucene.Net.Util.Automaton.Automaton,Lucene.Net.Util.Automaton.Automaton)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Union(System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.Automaton})" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Determinize(Lucene.Net.Util.Automaton.Automaton)" -->
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.AddEpsilons(Lucene.Net.Util.Automaton.Automaton,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.StatePair})">
            <summary>
            Adds epsilon transitions to the given automaton. this method adds extra
            character interval transitions that are equivalent to the given set of
            epsilon transitions.
            </summary>
            <param name="pairs"> collection of <seealso cref="T:Lucene.Net.Util.Automaton.StatePair"/> objects representing pairs of
                     source/destination states where epsilon transitions should be
                     added </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsEmptyString(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the given automaton accepts the empty string and nothing
            else.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsEmpty(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the given automaton accepts no strings.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.BasicOperations.IsTotal(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the given automaton accepts all strings.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.BasicOperations.Run(Lucene.Net.Util.Automaton.Automaton,System.String)" -->
        <member name="T:Lucene.Net.Util.Automaton.ByteRunAutomaton">
            <summary>
            Automaton representation for matching UTF-8 byte[].
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.ByteRunAutomaton.#ctor(Lucene.Net.Util.Automaton.Automaton,System.Boolean)">
            <summary>
            expert: if utf8 is true, the input is already byte-based </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.ByteRunAutomaton.Run(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Returns true if the given byte array is accepted by this automaton
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CharacterRunAutomaton">
            <summary>
            Automaton representation for matching char[].
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.CharacterRunAutomaton.Run(System.String)">
            <summary>
            Returns true if the given string is accepted by this automaton.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.CharacterRunAutomaton.Run(System.Char[],System.Int32,System.Int32)">
            <summary>
            Returns true if the given string is accepted by this automaton
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CompiledAutomaton">
             <summary>
             Immutable class holding compiled details for a given
             Automaton.  The Automaton is deterministic, must not have
             dead states but is not necessarily minimal.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE">
            <summary>
            Automata are compiled into different internal forms for the
            most efficient execution depending upon the language they accept.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NONE">
            <summary>
            Automaton that accepts no strings. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.ALL">
            <summary>
            Automaton that accepts all possible strings. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.SINGLE">
            <summary>
            Automaton that accepts only a single fixed string. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.PREFIX">
            <summary>
            Automaton that matches all Strings with a constant prefix. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.CompiledAutomaton.AUTOMATON_TYPE.NORMAL">
            <summary>
            Catch-all for any other automata. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.Term">
            <summary>
            For <seealso cref="!:AUTOMATON_TYPE#PREFIX"/>, this is the prefix term;
            for <seealso cref="!:AUTOMATON_TYPE#SINGLE"/> this is the singleton term.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.RunAutomaton">
            <summary>
            Matcher for quickly determining if a byte[] is accepted.
            only valid for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.SortedTransitions">
            <summary>
            Two dimensional array of transitions, indexed by state
            number for traversal. The state numbering is consistent with
            <seealso cref="!:#runAutomaton"/>.
            Only valid for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.CommonSuffixRef">
            <summary>
            Shared common suffix accepted by the automaton. Only valid
            for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>, and only when the
            automaton accepts an infinite language.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.CompiledAutomaton.Finite">
            <summary>
            Indicates if the automaton accepts a finite set of strings.
            Null if this was not computed.
            Only valid for <seealso cref="!:AUTOMATON_TYPE#NORMAL"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.CompiledAutomaton.Floor(Lucene.Net.Util.BytesRef,Lucene.Net.Util.BytesRef)" -->
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder" -->
        <member name="T:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State">
            <summary>
            DFSA state with <code>char</code> labels on transitions.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NO_LABELS">
            <summary>
            An empty set of labels. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NO_STATES">
            <summary>
            An empty set of states. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.labels">
            <summary>
            Labels of outgoing transitions. Indexed identically to <seealso cref="!:#states"/>.
            Labels must be sorted lexicographically.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.states">
            <summary>
            States reachable from outgoing transitions. Indexed identically to
            <seealso cref="!:#labels"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.is_final">
            <summary>
            <code>true</code> if this state corresponds to the end of at least one
            input sequence.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.GetState(System.Int32)">
            <summary>
            Returns the target state of a transition leaving this state and labeled
            with <code>label</code>. If no such transition exists, returns
            <code>null</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.Equals(System.Object)" -->
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.GetHashCode">
            <summary>
            Compute the hash code of the <i>current</i> status of this state.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.HasChildren">
            <summary>
            Return <code>true</code> if this state has any children (outgoing
            transitions).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.NewState(System.Int32)">
            <summary>
            Create a new outgoing transition labeled <code>label</code> and return
            the newly created target state for this transition.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.LastChild">
            <summary>
            Return the most recent transitions's target state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.LastChild(System.Int32)">
            <summary>
            Return the associated state if the most recent transition is labeled with
            <code>label</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.ReplaceLastChild(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State)">
            <summary>
            Replace the last added outgoing transition's target state with the given
            state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State.ReferenceEquals(System.Object[],System.Object[])">
            <summary>
            Compare two lists of objects for reference-equality.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.stateRegistry">
            <summary>
            A "registry" for state interning.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.root">
            <summary>
            Root automaton state.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.previous">
            <summary>
            Previous sequence added to the automaton in <seealso cref="!:#add(CharsRef)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.comparer">
            <summary>
            A comparer used for enforcing sorted UTF8 order, used in assertions only.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Add(Lucene.Net.Util.CharsRef)">
            <summary>
            Add another character sequence to this automaton. The sequence must be
            lexicographically larger or equal compared to any previous sequences added
            to this automaton (the input must be sorted).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Complete">
            <summary>
            Finalize the automaton and return the root state. No more strings can be
            added to the builder after this call.
            </summary>
            <returns> Root automaton state. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Convert(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,Lucene.Net.Support.IdentityHashMap{Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,Lucene.Net.Util.Automaton.State})">
            <summary>
            Internal recursive traversal for conversion.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.Build(System.Collections.Generic.ICollection{Lucene.Net.Util.BytesRef})">
            <summary>
            Build a minimal, deterministic automaton from a sorted list of <seealso cref="T:Lucene.Net.Util.BytesRef"/> representing
            strings in UTF-8. These strings must be binary-sorted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.SetPrevious(Lucene.Net.Util.CharsRef)">
            <summary>
            Copy <code>current</code> into an internal buffer.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.ReplaceOrRegister(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State)">
            <summary>
            Replace last child of <code>state</code> with an already registered state
            or stateRegistry the last child state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.AddSuffix(Lucene.Net.Util.Automaton.DaciukMihovAutomatonBuilder.State,Lucene.Net.Support.ICharSequence,System.Int32)">
            <summary>
            Add a suffix of <code>current</code> starting at <code>fromIndex</code>
            (inclusive) to state <code>state</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev1ParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 1 </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev1TParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 1,
               with transpositions as primitive edits
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev2ParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 2 </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.Lev2TParametricDescription">
            <summary>
            Parametric description for generating a Levenshtein automaton of degree 2,
               with transpositions as primitive edits
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.LevenshteinAutomata" -->
        <member name="F:Lucene.Net.Util.Automaton.LevenshteinAutomata.MAXIMUM_SUPPORTED_DISTANCE">
            <summary>
            @lucene.internal </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.#ctor(System.String,System.Boolean)">
            <summary>
            Create a new LevenshteinAutomata for some input String.
            Optionally count transpositions as a primitive edit.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.#ctor(System.Int32[],System.Int32,System.Boolean)">
            <summary>
            Expert: specify a custom maximum possible symbol
            (alphaMax); default is Character.MAX_CODE_POINT.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ToAutomaton(System.Int32)" -->
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.GetVector(System.Int32,System.Int32,System.Int32)">
            <summary>
            Get the characteristic vector <code>X(x, V)</code>
            where V is <code>substring(pos, end)</code>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription" -->
        <member name="P:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Count">
            <summary>
            Return the number of states needed to compute a Levenshtein DFA.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.IsAccept(System.Int32)">
            <summary>
            Returns true if the <code>state</code> in any Levenshtein DFA is an accept state (final state).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.GetPosition(System.Int32)">
            <summary>
            Returns the position in the input word for a given <code>state</code>.
            this is the minimal boundary for the state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.LevenshteinAutomata.ParametricDescription.Transition(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the state number for a transition from the given <code>state</code>,
            assuming <code>position</code> and characteristic vector <code>vector</code>
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.MinimizationOperations">
             <summary>
             Operations for minimizing automata.
            
             @lucene.experimental
             </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.MinimizationOperations.Minimize(Lucene.Net.Util.Automaton.Automaton)" -->
        <member name="M:Lucene.Net.Util.Automaton.MinimizationOperations.MinimizeHopcroft(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Minimizes the given automaton using Hopcroft's algorithm.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.MinimizationOperations.Int32Pair">
            <summary>
            NOTE: This was IntPair in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.INTERSECTION">
            <summary>
            Syntax flag, enables intersection (<c>&amp;</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.COMPLEMENT">
            <summary>
            Syntax flag, enables complement (<c>~</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.EMPTY">
            <summary>
            Syntax flag, enables empty language (<c>#</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.ANYSTRING">
            <summary>
            Syntax flag, enables anystring (<c>@</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.AUTOMATON">
            <summary>
            Syntax flag, enables named automata (<c>&lt;</c>identifier<c>&gt;</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.INTERVAL">
            <summary>
            Syntax flag, enables numerical intervals (
            <c>&lt;<i>n</i>-<i>m</i>&gt;</c>).
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.ALL">
            <summary>
            Syntax flag, enables all optional regexp syntax.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Automaton.RegExpSyntax.NONE">
            <summary>
            Syntax flag, enables no optional regexp syntax.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.RegExp" -->
        <member name="M:Lucene.Net.Util.Automaton.RegExp.#ctor(System.String)">
            <summary>
            Constructs new <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> from a string. Same as
            <c>RegExp(s, RegExpSyntax.ALL)</c>.
            </summary>
            <param name="s"> regexp string </param>
            <exception cref="T:System.ArgumentException"> if an error occured while parsing the
                         regular expression </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.#ctor(System.String,Lucene.Net.Util.Automaton.RegExpSyntax)">
            <summary>
            Constructs new <see cref="T:Lucene.Net.Util.Automaton.RegExp"/> from a string.
            </summary>
            <param name="s"> regexp string </param>
            <param name="syntax_flags"> boolean 'or' of optional <see cref="T:Lucene.Net.Util.Automaton.RegExpSyntax"/> constructs to be
                     enabled </param>
            <exception cref="T:System.ArgumentException"> if an error occured while parsing the
                         regular expression </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton">
            <summary>
            Constructs new <code>Automaton</code> from this <code>RegExp</code>. Same
            as <code>toAutomaton(null)</code> (empty automaton map).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton(Lucene.Net.Util.Automaton.IAutomatonProvider)">
            <summary>
            Constructs new <code>Automaton</code> from this <code>RegExp</code>. The
            constructed automaton is minimal and deterministic and has no transitions
            to dead states.
            </summary>
            <param name="automaton_provider"> provider of automata for named identifiers </param>
            <exception cref="!:IllegalArgumentException"> if this regular expression uses a named
                         identifier that is not available from the automaton provider </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToAutomaton(System.Collections.Generic.IDictionary{System.String,Lucene.Net.Util.Automaton.Automaton})">
            <summary>
            Constructs new <code>Automaton</code> from this <code>RegExp</code>. The
            constructed automaton is minimal and deterministic and has no transitions
            to dead states.
            </summary>
            <param name="automata"> a map from automaton identifiers to automata (of type
                     <code>Automaton</code>). </param>
            <exception cref="!:IllegalArgumentException"> if this regular expression uses a named
                         identifier that does not occur in the automaton map </exception>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.SetAllowMutate(System.Boolean)">
            <summary>
            Sets or resets allow mutate flag. If this flag is set, then automata
            construction uses mutable automata, which is slightly faster but not thread
            safe. By default, the flag is not set.
            </summary>
            <param name="flag"> if true, the flag is set </param>
            <returns> previous value of the flag </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.ToString">
            <summary>
            Constructs string from parsed regular expression.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RegExp.GetIdentifiers">
            <summary>
            Returns set of automaton identifiers that occur in this regular expression.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.RunAutomaton">
             <summary>
             Finite-state automaton with fast run operation.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.ToString">
            <summary>
            Returns a string representation of this automaton.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RunAutomaton.Count">
            <summary>
            Returns number of states in automaton.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.IsAccept(System.Int32)">
            <summary>
            Returns acceptance status for given state.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.RunAutomaton.InitialState">
            <summary>
            Returns initial state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.GetCharIntervals">
            <summary>
            Returns array of codepoint class interval start points. The array should
            not be modified by the caller.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.GetCharClass(System.Int32)">
            <summary>
            Gets character class of given codepoint
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.#ctor(Lucene.Net.Util.Automaton.Automaton,System.Int32,System.Boolean)">
            <summary>
            Constructs a new <code>RunAutomaton</code> from a deterministic
            <code>Automaton</code>.
            </summary>
            <param name="a"> an automaton </param>
            <param name="maxInterval"></param>
            <param name="tableize"></param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.RunAutomaton.Step(System.Int32,System.Int32)">
            <summary>
            Returns the state obtained by reading the given char from the given state.
            Returns -1 if not obtaining any such state. (If the original
            <code>Automaton</code> had no dead states, -1 is returned here if and only
            if a dead state is entered in an equivalent automaton with a total
            transition function.)
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.SortedInt32Set">
            <summary>
            Just holds a set of int[] states, plus a corresponding
            int[] count per state.  Used by
            BasicOperations.determinize
            <para/>
            NOTE: This was SortedIntSet in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.SortedInt32Set.FrozenInt32Set">
            <summary>
            NOTE: This was FrozenIntSet in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.SpecialOperations">
             <summary>
             Special automata operations.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.FindIndex(System.Int32,System.Int32[])">
            <summary>
            Finds the largest entry whose value is less than or equal to c, or 0 if
            there is no such entry.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.IsFinite(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns true if the language of this automaton is finite.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.IsFinite(Lucene.Net.Util.Automaton.State,Lucene.Net.Util.OpenBitSet,Lucene.Net.Util.OpenBitSet)">
            <summary>
            Checks whether there is a loop containing s. (this is sufficient since
            there are never transitions to dead states.)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetCommonPrefix(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns the longest string that is a prefix of all accepted strings and
            visits each state at most once.
            </summary>
            <returns> common prefix </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetCommonSuffix(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Returns the longest string that is a suffix of all accepted strings and
            visits each state at most once.
            </summary>
            <returns> common suffix </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.Reverse(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Reverses the language of the given (non-singleton) automaton while returning
            the set of new initial states.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetFiniteStrings(Lucene.Net.Util.Automaton.Automaton,System.Int32)">
            <summary>
            Returns the set of accepted strings, assuming that at most
            <code>limit</code> strings are accepted. If more than <code>limit</code>
            strings are accepted, the first limit strings found are returned. If <code>limit</code>&lt;0, then
            the limit is infinite.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.SpecialOperations.GetFiniteStrings(Lucene.Net.Util.Automaton.State,System.Collections.Generic.HashSet{Lucene.Net.Util.Automaton.State},System.Collections.Generic.HashSet{Lucene.Net.Util.Int32sRef},Lucene.Net.Util.Int32sRef,System.Int32)">
            <summary>
            Returns the strings that can be produced from the given state, or
            false if more than <code>limit</code> strings are found.
            <code>limit</code>&lt;0 means "infinite".
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.State">
             <summary>
             <tt>Automaton</tt> state.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.#ctor">
            <summary>
            Constructs a new state. Initially, the new state is a reject state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.ResetTransitions">
            <summary>
            Resets transition set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.GetTransitions">
            <summary>
            Returns the set of outgoing transitions. Subsequent changes are reflected
            in the automaton.
            </summary>
            <returns> transition set </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.AddTransition(Lucene.Net.Util.Automaton.Transition)">
            <summary>
            Adds an outgoing transition.
            </summary>
            <param name="t"> transition </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.State.Accept">
            <summary>
            Sets acceptance for this state.
            </summary>
            <param name="accept"> if true, this state is an accept state </param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.State.Step(System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Automaton.State.Step(System.Int32,System.Collections.Generic.ICollection{Lucene.Net.Util.Automaton.State})" -->
        <member name="M:Lucene.Net.Util.Automaton.State.AddEpsilon(Lucene.Net.Util.Automaton.State)">
            <summary>
            Virtually adds an epsilon transition to the target
             {@code to} state.  this is implemented by copying all
             transitions from {@code to} to this state, and if {@code
             to} is an accept state then set accept for this state.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.TrimTransitionsArray">
            <summary>
            Downsizes transitionArray to numTransitions </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.Reduce">
            <summary>
            Reduces this state. A state is "reduced" by combining overlapping
            and adjacent edge intervals with same destination.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.SortTransitions(System.Collections.Generic.IComparer{Lucene.Net.Util.Automaton.Transition})">
            <summary>
            Returns sorted list of outgoing transitions.
            </summary>
            <param name="to_first"> if true, order by (to, min, reverse max); otherwise (min,
                     reverse max, to) </param>
            <returns> transition list </returns>
            <summary>
            Sorts transitions array in-place. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.Automaton.State.Number" -->
        <member name="M:Lucene.Net.Util.Automaton.State.ToString">
            <summary>
            Returns string describing this state. Normally invoked via
            <seealso cref="!:Automaton#toString()"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.State.CompareTo(Lucene.Net.Util.Automaton.State)">
            <summary>
            Compares this object with the specified object for order. States are
            ordered by the time of construction.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.StatePair">
             <summary>
             Pair of states.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.#ctor(Lucene.Net.Util.Automaton.State,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new state pair.
            </summary>
            <param name="s1"> first state </param>
            <param name="s2"> second state </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.StatePair.FirstState">
            <summary>
            Returns first component of this pair.
            </summary>
            <returns> first state </returns>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.StatePair.SecondState">
            <summary>
            Returns second component of this pair.
            </summary>
            <returns> second state </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.Equals(System.Object)">
            <summary>
            Checks for equality.
            </summary>
            <param name="obj"> object to compare with </param>
            <returns> true if <tt>obj</tt> represents the same pair of states as this
                    pair </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.StatePair.GetHashCode">
            <summary>
            Returns hash code.
            </summary>
            <returns> hash code </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Automaton.Transition" -->
        <member name="M:Lucene.Net.Util.Automaton.Transition.#ctor(System.Int32,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new singleton interval transition.
            </summary>
            <param name="c"> transition codepoint </param>
            <param name="to"> destination state </param>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.#ctor(System.Int32,System.Int32,Lucene.Net.Util.Automaton.State)">
            <summary>
            Constructs a new transition. Both end points are included in the interval.
            </summary>
            <param name="min"> transition interval minimum </param>
            <param name="max"> transition interval maximum </param>
            <param name="to"> destination state </param>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Min">
            <summary>
            Returns minimum of this transition interval. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Max">
            <summary>
            Returns maximum of this transition interval. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Automaton.Transition.Dest">
            <summary>
            Returns destination of this transition. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.Equals(System.Object)">
            <summary>
            Checks for equality.
            </summary>
            <param name="obj"> object to compare with </param>
            <returns> true if <tt>obj</tt> is a transition with same character interval
                    and destination state as this transition. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.GetHashCode">
            <summary>
            Returns hash code. The hash code is based on the character interval (not
            the destination state).
            </summary>
            <returns> hash code </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.Clone">
            <summary>
            Clones this transition.
            </summary>
            <returns> clone with same character interval and destination state </returns>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.Transition.ToString">
            <summary>
            Returns a string describing this state. Normally invoked via
            <seealso cref="!:Automaton#toString()"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Automaton.UTF32ToUTF8">
            <summary>
            Converts UTF-32 automata to the equivalent UTF-8 representation.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Automaton.UTF32ToUTF8.Convert(Lucene.Net.Util.Automaton.Automaton)">
            <summary>
            Converts an incoming utf32 automaton to an equivalent
             utf8 one.  The incoming automaton need not be
             deterministic.  Note that the returned automaton will
             not in general be deterministic, so you must
             determinize it if that's needed.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder`1">
             <summary>
             Builds a minimal FST (maps an <see cref="T:Lucene.Net.Util.Int32sRef"/> term to an arbitrary
             output) from pre-sorted terms with outputs.  The FST
             becomes an FSA if you use NoOutputs.  The FST is written
             on-the-fly into a compact serialized format byte array, which can
             be saved to / loaded from a Directory or used directly
             for traversal.  The FST is always finite (no cycles).
            
             <para/>NOTE: The algorithm is described at
             http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.3698
            
             <para/>The parameterized type <typeparam name="T"/> is the output type.  See the
             subclasses of <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/>.
            
             <para/>FSTs larger than 2.1GB are now possible (as of Lucene
             4.2).  FSTs containing more than 2.1B nodes are also now
             possible, however they cannot be packed.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,Lucene.Net.Util.Fst.Outputs{`0})">
            <summary>
            Instantiates an FST/FSA builder without any pruning. A shortcut
            to <see cref="!:Builder.Builder(FST.INPUT_TYPE, int, int, bool, bool, int, Outputs&lt;T&gt;, FreezeTail&lt;T&gt;, bool, float, bool, int)"/>
            with pruning options turned off.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,System.Int32,System.Int32,System.Boolean,System.Boolean,System.Int32,Lucene.Net.Util.Fst.Outputs{`0},Lucene.Net.Util.Fst.Builder.FreezeTail{`0},System.Boolean,System.Single,System.Boolean,System.Int32)">
            <summary>
            Instantiates an FST/FSA builder with all the possible tuning and construction
            tweaks. Read parameter documentation carefully.
            </summary>
            <param name="inputType">
               The input type (transition labels). Can be anything from <see cref="T:Lucene.Net.Util.Fst.FST.INPUT_TYPE"/>
               enumeration. Shorter types will consume less memory. Strings (character sequences) are
               represented as <see cref="F:Lucene.Net.Util.Fst.FST.INPUT_TYPE.BYTE4"/> (full unicode codepoints).
            </param>
            <param name="minSuffixCount1">
               If pruning the input graph during construction, this threshold is used for telling
               if a node is kept or pruned. If transition_count(node) &gt;= minSuffixCount1, the node
               is kept.
            </param>
            <param name="minSuffixCount2">
               (Note: only Mike McCandless knows what this one is really doing...)
            </param>
            <param name="doShareSuffix">
               If <c>true</c>, the shared suffixes will be compacted into unique paths.
               this requires an additional RAM-intensive hash map for lookups in memory. Setting this parameter to
               <c>false</c> creates a single suffix path for all input sequences. this will result in a larger
               FST, but requires substantially less memory and CPU during building.
            </param>
            <param name="doShareNonSingletonNodes">
               Only used if <paramref name="doShareSuffix"/> is <c>true</c>.  Set this to
               true to ensure FST is fully minimal, at cost of more
               CPU and more RAM during building.
            </param>
            <param name="shareMaxTailLength">
               Only used if <paramref name="doShareSuffix"/> is <c>true</c>.  Set this to
               <see cref="F:System.Int32.MaxValue"/> to ensure FST is fully minimal, at cost of more
               CPU and more RAM during building.
            </param>
            <param name="outputs"> The output type for each input sequence. Applies only if building an FST. For
               FSA, use <see cref="P:Lucene.Net.Util.Fst.NoOutputs.Singleton"/> and <see cref="P:Lucene.Net.Util.Fst.NoOutputs.NoOutput"/> as the
               singleton output object.
            </param>
            <param name="doPackFST"> Pass <c>true</c> to create a packed FST.
            </param>
            <param name="acceptableOverheadRatio"> How to trade speed for space when building the FST. this option 
               is only relevant when doPackFST is true. <see cref="M:Lucene.Net.Util.Packed.PackedInt32s.GetMutable(System.Int32,System.Int32,System.Single)"/>
            </param>
            <param name="allowArrayArcs"> Pass false to disable the array arc optimization
               while building the FST; this will make the resulting
               FST smaller but slower to traverse.
            </param>
            <param name="bytesPageBits"> How many bits wide to make each
               <see cref="T:byte[]"/> block in the <see cref="T:Lucene.Net.Util.Fst.BytesStore"/>; if you know the FST
               will be large then make this larger.  For example 15
               bits = 32768 byte pages. </param>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.Add(Lucene.Net.Util.Int32sRef,`0)">
            <summary>
            It's OK to add the same input twice in a row with
            different outputs, as long as outputs impls the merge
            method. Note that input is fully consumed after this
            method is returned (so caller is free to reuse), but
            output is not.  So if your outputs are changeable (eg
            <see cref="T:Lucene.Net.Util.Fst.ByteSequenceOutputs"/> or 
            <see cref="T:Lucene.Net.Util.Fst.Int32SequenceOutputs"/>) then you cannot reuse across
            calls.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder`1.Finish">
            <summary>
            Returns final FST.  NOTE: this will return null if
            nothing is accepted by the FST.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder">
            <summary>
            LUCENENET specific type used to access nested types of <see cref="T:Lucene.Net.Util.Fst.Builder`1"/>
            without referring to its generic closing type.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder.FreezeTail`1">
            <summary>
            Expert: this is invoked by Builder whenever a suffix
             is serialized.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder.Arc`1">
            <summary>
            Expert: holds a pending (seen but not yet serialized) arc. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1">
            <summary>
            Expert: holds a pending (seen but not yet serialized) Node. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1.Depth">
            <summary>
            this node's depth, starting from the automaton root. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1.#ctor(Lucene.Net.Util.Fst.Builder{`0},System.Int32)">
            <param name="depth">
                     The node's depth starting from the automaton root. Needed for
                     LUCENE-2934 (node expansion based on conditions other than the
                     fanout size). </param>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ByteSequenceOutputs">
            <summary>
            An FST <see cref="T:Outputs{BytesRef}"/> implementation where each output
            is a sequence of bytes.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum`1">
             <summary>
             Enumerates all input (<see cref="T:Lucene.Net.Util.BytesRef"/>) + output pairs in an
             FST.
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
            doFloor is true, advance positions to the biggest
            term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekCeil(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to smallest term that's &gt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekFloor(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to biggest term that's &lt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekExact(Lucene.Net.Util.BytesRef)">
            <summary>
            Seeks to exactly this term, returning <c>null</c> if the term
            doesn't exist.  This is faster than using
            <see cref="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekFloor(Lucene.Net.Util.BytesRef)"/> or <see cref="M:Lucene.Net.Util.Fst.BytesRefFSTEnum`1.SeekCeil(Lucene.Net.Util.BytesRef)"/> because it
            short-circuits as soon the match is not found.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum">
            <summary>
            LUCENENET specific. This class is to mimic Java's ability to specify
            nested classes of Generics without having to specify the generic type
            (i.e. BytesRefFSTEnum.InputOutput{T} rather than BytesRefFSTEnum{T}.InputOutput{T})
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.BytesRefFSTEnum.InputOutput`1">
            <summary>
            Holds a single input (<see cref="T:Lucene.Net.Util.BytesRef"/>) + output pair. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.#ctor(Lucene.Net.Store.DataInput,System.Int64,System.Int32)">
            <summary>
            Pulls bytes from the provided <see cref="T:Lucene.Net.Store.IndexInput"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteByte(System.Int32,System.Byte)">
            <summary>
            Absolute write byte; you must ensure dest is &lt; max
            position written so far.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteBytes(System.Int64,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Absolute writeBytes without changing the current
            position.  Note: this cannot "grow" the bytes, so you
            must only call it on already written parts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.CopyBytes(System.Int64,System.Int64,System.Int32)">
            <summary>
            Absolute copy bytes self to self, without changing the
            position. Note: this cannot "grow" the bytes, so must
            only call it on already written parts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteInt32(System.Int64,System.Int32)">
            <summary>
            Writes an <see cref="T:System.Int32"/> at the absolute position without
            changing the current pointer.
            <para/>
            NOTE: This was writeInt() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.Reverse(System.Int64,System.Int64)">
            <summary>
            Reverse from <paramref name="srcPos"/>, inclusive, to <paramref name="destPos"/>, inclusive. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.Truncate(System.Int64)">
            <summary>
            Pos must be less than the max position written so far!
            i.e., you cannot "grow" the file with this!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.BytesStore.WriteTo(Lucene.Net.Store.DataOutput)">
            <summary>
            Writes all of our bytes to the target <see cref="T:Lucene.Net.Store.DataOutput"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.CharSequenceOutputs">
            <summary>
            An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation where each output
            is a sequence of characters.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ForwardBytesReader">
            <summary>
            Reads from a single <see cref="T:byte[]"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST`1">
             <summary>
             Represents an finite state machine (FST), using a
             compact <see cref="T:byte[]"/> format.
             <para/> The format is similar to what's used by Morfologik
             (http://sourceforge.net/projects/morfologik).
            
             <para/> See the <a href="https://lucene.apache.org/core/4_8_0/core/org/apache/lucene/util/fst/package-summary.html">
             FST package documentation</a> for some simple examples.
             <para/>
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Store.DataInput,Lucene.Net.Util.Fst.Outputs{`0})">
            <summary>
            Load a previously saved FST. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Store.DataInput,Lucene.Net.Util.Fst.Outputs{`0},System.Int32)">
            <summary>
            Load a previously saved FST; <paramref name="maxBlockBits"/> allows you to
            control the size of the <see cref="T:byte[]"/> pages used to hold the FST bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.GetSizeInBytes">
            <summary>
            Returns bytes used to represent the FST </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.Save(System.IO.FileInfo)">
            <summary>
            Writes an automaton to a file.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.TargetHasArcs(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            returns <c>true</c> if the node at this address has any
            outgoing arcs
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.GetFirstArc(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            Fills virtual 'start' arc, ie, an empty incoming arc to
            the FST's start node
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadLastTargetArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Follows the <paramref name="follow"/> arc and reads the last
            arc of its target; this changes the provided
            <paramref name="arc"/> (2nd arg) in-place and returns it.
            </summary>
            <returns> Returns the second argument
            (<paramref name="arc"/>).  </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadFirstTargetArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Follow the <paramref name="follow"/> arc and read the first arc of its target;
            this changes the provided <paramref name="arc"/> (2nd arg) in-place and returns
            it.
            </summary>
            <returns> Returns the second argument (<paramref name="arc"/>). </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.IsExpandedTarget(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Checks if <paramref name="arc"/>'s target state is in expanded (or vector) format.
            </summary>
            <returns> Returns <c>true</c> if <paramref name="arc"/> points to a state in an
            expanded array format. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            In-place read; returns the arc. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextArcLabel(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Peeks at next arc's label; does not alter <paramref name="arc"/>.  Do
            not call this if arc.IsLast!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ReadNextRealArc(Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Never returns <c>null</c>, but you should never call this if
            arc.IsLast is <c>true</c>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.FindTargetArc(System.Int32,Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Finds an arc leaving the incoming <paramref name="arc"/>, replacing the arc in place.
            this returns <c>null</c> if the arc was not found, else the incoming <paramref name="arc"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.ShouldExpand(Lucene.Net.Util.Fst.Builder.UnCompiledNode{`0})">
             <summary>
             Nodes will be expanded if their depth (distance from the root node) is
             &lt;= this value and their number of arcs is &gt;=
             <see cref="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_SHALLOW"/>.
            
             <para/>
             Fixed array consumes more RAM but enables binary search on the arcs
             (instead of a linear scan) on lookup by arc label.
             </summary>
             <returns> <c>true</c> if <paramref name="node"/> should be stored in an
                     expanded (array) form.
             </returns>
             <seealso cref="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_DEEP"/>
             <seealso cref="P:Lucene.Net.Util.Fst.Builder.UnCompiledNode`1.Depth"/>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.GetBytesReader">
            <summary>
            Returns a <see cref="T:Lucene.Net.Util.Fst.FST.BytesReader"/> for this FST, positioned at
            position 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.#ctor(Lucene.Net.Util.Fst.FST.INPUT_TYPE,Lucene.Net.Util.Fst.Outputs{`0},System.Int32)">
            <summary>
            Creates a packed FST
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST`1.Pack(System.Int32,System.Int32,System.Single)">
             <summary>
             Expert: creates an FST by packing this one.  This
             process requires substantial additional RAM (currently
             up to ~8 bytes per node depending on
             <c>acceptableOverheadRatio</c>), but then should
             produce a smaller FST.
            
             <para/>The implementation of this method uses ideas from
             <a target="_blank" href="http://www.cs.put.poznan.pl/dweiss/site/publications/download/fsacomp.pdf">Smaller Representation of Finite State Automata</a>,
             which describes techniques to reduce the size of a FST.
             However, this is not a strict implementation of the
             algorithms described in this paper.
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST">
            <summary>
            LUCENENET specific: This new base class is to mimic Java's ability to use nested types without specifying
            a type parameter. i.e. FST.BytesReader instead of FST&lt;BytesRef&gt;.BytesReader
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_SHALLOW_DISTANCE">
            <summary>
            <see cref="!:Builder&lt;T&gt;.UnCompiledNode&lt;S&gt;"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_SHALLOW">
            <summary>
            <see cref="!:Builder&lt;T&gt;.UnCompiledNode&lt;S&gt;"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FIXED_ARRAY_NUM_ARCS_DEEP">
            <summary>
            <see cref="!:Builder&lt;T&gt;.UnCompiledNode&lt;S&gt;"/>
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_INT32_NUM_BYTES_PER_ARC">
            <summary>
            Changed numBytesPerArc for array'd case from byte to <see cref="T:System.Int32"/>.
            <para/>
            NOTE: This was VERSION_INT_NUM_BYTES_PER_ARC in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_INT16_BYTE2_LABELS">
            <summary>
            Write BYTE2 labels as 2-byte <see cref="T:System.Int16"/>, not v<see cref="T:System.Int32"/>.
            <para/>
            NOTE: This was VERSION_SHORT_BYTE2_LABELS in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_PACKED">
            <summary>
            Added optional packed format.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.VERSION_VINT32_TARGET">
            <summary>
            Changed from <see cref="T:System.Int32"/> to v<see cref="T:System.Int32"/> for encoding arc targets.
            Also changed maxBytesPerArc from int to v<see cref="T:System.Int32"/> in the array case.
            <para/>
            NOTE: This was VERSION_VINT_TARGET in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.FINAL_END_NODE">
            <summary>
            Never serialized; just used to represent the virtual
            final node w/ no arcs:
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.NON_FINAL_END_NODE">
            <summary>
            Never serialized; just used to represent the virtual
            non-final node w/ no arcs:
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Fst.FST.END_LABEL">
            <summary>
            If arc has this label then that arc is final/accepted </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.TargetHasArcs``1(Lucene.Net.Util.Fst.FST.Arc{``0})">
            <summary>
            returns <c>true</c> if the node at this address has any
            outgoing arcs
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.Read``1(System.IO.FileInfo,Lucene.Net.Util.Fst.Outputs{``0})">
            <summary>
            Reads an automaton from a file.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.BytesReader">
            <summary>
            Reads bytes stored in an FST.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.BytesReader.Position">
            <summary>
            Current read position
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.BytesReader.IsReversed">
            <summary>
            Returns <c>true</c> if this reader uses reversed bytes
            under-the-hood.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.BytesReader.SkipBytes(System.Int32)">
            <summary>
            Skips bytes.
            </summary>
            <param name="count"></param>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.INPUT_TYPE">
            <summary>
            Specifies allowed range of each int input label for this FST.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FST.Arc`1">
            <summary>
            Represents a single arc.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.Node">
            <summary>
            From node (ord or address); currently only used when
            building an FST w/ willPackFST=true:
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.Target">
            <summary>
            To node (ord or address)
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.NextArc">
            <summary>
            address (into the byte[]), or ord/address if label == END_LABEL
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.FST.Arc`1.PosArcsStart">
            <summary>
            This is non-zero if current arcs are fixed array:
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FST.Arc`1.CopyFrom(Lucene.Net.Util.Fst.FST.Arc{`0})">
            <summary>
            Return this
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Lucene.Net.Util.Fst.FSTEnum`1">
            <summary>
            Can Next() and Advance() through the terms in an FST
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
            doFloor is true, advance positions to the biggest
            term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.RewindPrefix">
            <summary>
            Rewinds enum state to match the shared prefix between
            current term and target term
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekCeil">
            <summary>
            Seeks to smallest term that's &gt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekFloor">
            <summary>
            Seeks to largest term that's &lt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.DoSeekExact">
            <summary>
            Seeks to exactly target term. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.PushFirst">
            <summary>
            Appends current arc, and then recurses from its target,
            appending first arc all the way to the final node
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.FSTEnum`1.PushLast">
            <summary>
            Recurses from current arc, appending last arc all the
            way to the first final node
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32SequenceOutputs">
            <summary>
            An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation where each output
            is a sequence of <see cref="T:System.Int32"/>s.
            <para/>
            NOTE: This was IntSequenceOutputs in Lucene
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1">
            <summary>
            Enumerates all input (<see cref="T:Lucene.Net.Util.Int32sRef"/>) + output pairs in an
            FST.
            <para/>
            NOTE: This was IntsRefFSTEnum{T} in Lucene
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.#ctor(Lucene.Net.Util.Fst.FST{`0})">
            <summary>
            doFloor controls the behavior of advance: if it's true
            doFloor is true, advance positions to the biggest
            term before target.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekCeil(Lucene.Net.Util.Int32sRef)">
            <summary>
            Seeks to smallest term that's &gt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekFloor(Lucene.Net.Util.Int32sRef)">
            <summary>
            Seeks to biggest term that's &lt;= target. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekExact(Lucene.Net.Util.Int32sRef)">
            <summary>
            Seeks to exactly this term, returning <c>null</c> if the term
            doesn't exist.  This is faster than using 
            <see cref="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekFloor(Lucene.Net.Util.Int32sRef)"/> or <see cref="M:Lucene.Net.Util.Fst.Int32sRefFSTEnum`1.SeekCeil(Lucene.Net.Util.Int32sRef)"/> because it
            short-circuits as soon the match is not found.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32sRefFSTEnum">
            <summary>
            LUCENENET specific. This class is to mimic Java's ability to specify
            nested classes of Generics without having to specify the generic type
            (i.e. <c>Int32sRefFSTEnum.InputOutput{T}</c> rather than <c>Int32sRefFSTEnum{T}.InputOutput{T}</c>)
            <para/>
            NOTE: This was Int32sRefFSTEnum{T} in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Int32sRefFSTEnum.InputOutput`1">
            <summary>
            Holds a single input (<see cref="T:Lucene.Net.Util.Int32sRef"/>) + output pair. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.NodeHash`1">
            <summary>
            Used to dedup states (lookup already-frozen states)
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NodeHash`1.Hash(Lucene.Net.Util.Fst.Builder.UnCompiledNode{`0})">
            <summary>
            hash code for an unfrozen node.  this must be identical
            to the frozen case (below)!!
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NodeHash`1.Hash(System.Int64)">
            <summary>
            hash code for a frozen node
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NodeHash`1.AddNew(System.Int64)">
            <summary>
            called only by rehash
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.NoOutputs">
            <summary>
            A null FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation; use this if
            you just want to build an FSA.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.NoOutputs.ObjectAnonymousInnerClassHelper.GetHashCode">
            <summary>
            NodeHash calls hashCode for this output; we fix this
            so we get deterministic hashing.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Outputs`1">
             <summary>
             Represents the outputs for an FST, providing the basic
             algebra required for building and traversing the FST.
            
             <para>Note that any operation that returns NO_OUTPUT must
             return the same singleton object from
             <see cref="P:Lucene.Net.Util.Fst.Outputs`1.NoOutput"/>.</para>
            
             @lucene.experimental
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Common(`0,`0)">
            <summary>
            Eg common("foobar", "food") -> "foo" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Subtract(`0,`0)">
            <summary>
            Eg subtract("foobar", "foo") -> "bar" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Add(`0,`0)">
            <summary>
            Eg add("foo", "bar") -> "foobar" </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Write(`0,Lucene.Net.Store.DataOutput)">
            <summary>
            Encode an output value into a <see cref="T:Lucene.Net.Store.DataOutput"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.WriteFinalOutput(`0,Lucene.Net.Store.DataOutput)">
            <summary>
            Encode an final node output value into a
            <see cref="T:Lucene.Net.Store.DataOutput"/>.  By default this just calls 
            <see cref="M:Lucene.Net.Util.Fst.Outputs`1.Write(`0,Lucene.Net.Store.DataOutput)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.Read(Lucene.Net.Store.DataInput)">
            <summary>
            Decode an output value previously written with
            <see cref="M:Lucene.Net.Util.Fst.Outputs`1.Write(`0,Lucene.Net.Store.DataOutput)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Outputs`1.ReadFinalOutput(Lucene.Net.Store.DataInput)">
            <summary>
            Decode an output value previously written with
            <see cref="M:Lucene.Net.Util.Fst.Outputs`1.WriteFinalOutput(`0,Lucene.Net.Store.DataOutput)"/>.  By default this
            just calls <see cref="M:Lucene.Net.Util.Fst.Outputs`1.Read(Lucene.Net.Store.DataInput)"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Outputs`1.NoOutput">
            <summary>
            NOTE: this output is compared with == so you must
            ensure that all methods return the single object if
            it's really no output
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PairOutputs`2">
            <summary>
            An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation, holding two other outputs.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PairOutputs`2.Pair">
            <summary>
            Holds a single pair of two outputs. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.PairOutputs`2.NewPair(`0,`1)">
            <summary>
            Create a new <see cref="T:Lucene.Net.Util.Fst.PairOutputs`2.Pair"/> </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.PositiveInt32Outputs">
             <summary>
             An FST <see cref="T:Lucene.Net.Util.Fst.Outputs`1"/> implementation where each output
             is a non-negative <see cref="!:long?"/> value.
             <para/>
             NOTE: This was PositiveIntOutputs in Lucene
            
             @lucene.experimental
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.ReverseBytesReader">
            <summary>
            Reads in reverse from a single <see cref="T:byte[]"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util">
            <summary>
            Static helper methods.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.Get``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Int32sRef)">
            <summary>
            Looks up the output for this input, or <c>null</c> if the
            input is not accepted.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.Get``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.BytesRef)">
            <summary>
            Looks up the output for this input, or <c>null</c> if the
            input is not accepted
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64)">
             <summary>
             Reverse lookup (lookup by output instead of by input),
             in the special case when your FSTs outputs are
             strictly ascending.  This locates the input/output
             pair where the output is equal to the target, and will
             return <c>null</c> if that output does not exist.
            
             <para/>NOTE: this only works with <see cref="T:FST{long?}"/>, only
             works when the outputs are ascending in order with
             the inputs.
             For example, simple ordinals (0, 1,
             2, ...), or file offets (when appending to a file)
             fit this.
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64,Lucene.Net.Util.Fst.FST.BytesReader,Lucene.Net.Util.Fst.FST.Arc{System.Nullable{System.Int64}},Lucene.Net.Util.Fst.FST.Arc{System.Nullable{System.Int64}},Lucene.Net.Util.Int32sRef)">
            <summary>
            Expert: like <see cref="M:Lucene.Net.Util.Fst.Util.GetByOutput(Lucene.Net.Util.Fst.FST{System.Nullable{System.Int64}},System.Int64)"/> except reusing
            <see cref="T:Lucene.Net.Util.Fst.FST.BytesReader"/>, initial and scratch Arc, and result.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.FSTPath`1">
            <summary>
            Represents a path in TopNSearcher.
            <para/>
            @lucene.experimental
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.FSTPath`1.#ctor(`0,Lucene.Net.Util.Fst.FST.Arc{`0},Lucene.Net.Util.Int32sRef)">
            <summary>
            Sole constructor </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TieBreakByInputComparer`1">
            <summary>
            Compares first by the provided comparer, and then
            tie breaks by <see cref="P:Lucene.Net.Util.Fst.Util.FSTPath`1.Input"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TopNSearcher`1">
            <summary>
            Utility class to find top N shortest paths from start
            point(s).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.#ctor(Lucene.Net.Util.Fst.FST{`0},System.Int32,System.Int32,System.Collections.Generic.IComparer{`0})">
            <summary>
            Creates an unbounded TopNSearcher </summary>
            <param name="fst"> the <see cref="T:Lucene.Net.Util.Fst.FST`1"/> to search on </param>
            <param name="topN"> the number of top scoring entries to retrieve </param>
            <param name="maxQueueDepth"> the maximum size of the queue of possible top entries </param>
            <param name="comparer"> the comparer to select the top N </param>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.AddIfCompetitive(Lucene.Net.Util.Fst.Util.FSTPath{`0})">
            <summary>
            If back plus this arc is competitive then add to queue:
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.TopNSearcher`1.AddStartPaths(Lucene.Net.Util.Fst.FST.Arc{`0},`0,System.Boolean,Lucene.Net.Util.Int32sRef)">
            <summary>
            Adds all leaving arcs, including 'finished' arc, if
            the node is final, from this node into the queue.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.Result`1">
            <summary>
            Holds a single input (<see cref="T:Lucene.Net.Util.Int32sRef"/>) + output, returned by
            <see cref="M:Lucene.Net.Util.Fst.Util.ShortestPaths``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32,System.Boolean)"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Fst.Util.TopResults`1">
            <summary>
            Holds the results for a top N search using <see cref="T:Lucene.Net.Util.Fst.Util.TopNSearcher`1"/>
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Util.TopResults`1.IsComplete">
            <summary>
            <c>true</c> iff this is a complete result ie. if
            the specified queue size was large enough to find the complete list of results. this might
            be <c>false</c> if the <see cref="T:Lucene.Net.Util.Fst.Util.TopNSearcher`1"/> rejected too many results.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Fst.Util.TopResults`1.TopN">
            <summary>
            The top results
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ShortestPaths``1(Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32,System.Boolean)">
            <summary>
            Starting from node, find the top N min cost
            completions to a final node.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToDot``1(Lucene.Net.Util.Fst.FST{``0},System.IO.TextWriter,System.Boolean,System.Boolean)">
             <summary>
             Dumps an <see cref="T:Lucene.Net.Util.Fst.FST`1"/> to a GraphViz's <c>dot</c> language description
             for visualization. Example of use:
            
             <code>
             using (TextWriter sw = new StreamWriter(&quot;out.dot&quot;))
             {
                 Util.ToDot(fst, sw, true, true);
             }
             </code>
            
             and then, from command line:
            
             <code>
             dot -Tpng -o out.png out.dot
             </code>
            
             <para/>
             Note: larger FSTs (a few thousand nodes) won't even
             render, don't bother.  If the FST is &gt; 2.1 GB in size
             then this method will throw strange exceptions.
             <para/>
             See also <a href="http://www.graphviz.org/">http://www.graphviz.org/</a>.
             </summary>
             <param name="sameRank">
                      If <c>true</c>, the resulting <c>dot</c> file will try
                      to order states in layers of breadth-first traversal. This may
                      mess up arcs, but makes the output FST's structure a bit clearer.
             </param>
             <param name="labelStates">
                      If <c>true</c> states will have labels equal to their offsets in their
                      binary format. Expands the graph considerably.
             </param>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.EmitDotState(System.IO.TextWriter,System.String,System.String,System.String,System.String)">
            <summary>
            Emit a single state in the <c>dot</c> language.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.PrintableLabel(System.Int32)">
            <summary>
            Ensures an arc's label is indeed printable (dot uses US-ASCII).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF16(System.String,Lucene.Net.Util.Int32sRef)">
            <summary>
            Just maps each UTF16 unit (char) to the <see cref="T:System.Int32"/>s in an
            <see cref="T:Lucene.Net.Util.Int32sRef"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF32(System.String,Lucene.Net.Util.Int32sRef)">
            <summary>
            Decodes the Unicode codepoints from the provided
            <see cref="T:Lucene.Net.Support.ICharSequence"/> and places them in the provided scratch
            <see cref="T:Lucene.Net.Util.Int32sRef"/>, which must not be <c>null</c>, returning it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToUTF32(System.Char[],System.Int32,System.Int32,Lucene.Net.Util.Int32sRef)">
            <summary>
            Decodes the Unicode codepoints from the provided
            <see cref="T:char[]"/> and places them in the provided scratch
            <see cref="T:Lucene.Net.Util.Int32sRef"/>, which must not be <c>null</c>, returning it.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToInt32sRef(Lucene.Net.Util.BytesRef,Lucene.Net.Util.Int32sRef)">
            <summary>
            Just takes unsigned byte values from the <see cref="T:Lucene.Net.Util.BytesRef"/> and
            converts into an <see cref="T:Lucene.Net.Util.Int32sRef"/>.
            <para/>
            NOTE: This was toIntsRef() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ToBytesRef(Lucene.Net.Util.Int32sRef,Lucene.Net.Util.BytesRef)">
            <summary>
            Just converts <see cref="T:Lucene.Net.Util.Int32sRef"/> to <see cref="T:Lucene.Net.Util.BytesRef"/>; you must ensure the
            <see cref="T:System.Int32"/> values fit into a <see cref="T:System.Byte"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Fst.Util.ReadCeilArc``1(System.Int32,Lucene.Net.Util.Fst.FST{``0},Lucene.Net.Util.Fst.FST.Arc{``0},Lucene.Net.Util.Fst.FST.Arc{``0},Lucene.Net.Util.Fst.FST.BytesReader)">
            <summary>
            Reads the first arc greater or equal that the given label into the provided
            arc in place and returns it iff found, otherwise return <c>null</c>.
            </summary>
            <param name="label"> the label to ceil on </param>
            <param name="fst"> the fst to operate on </param>
            <param name="follow"> the arc to follow reading the label from </param>
            <param name="arc"> the arc to read into in place </param>
            <param name="in"> the fst's <see cref="T:Lucene.Net.Util.Fst.FST.BytesReader"/> </param>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValue">
             <summary>
             Base class for all mutable values.
            
             @lucene.internal
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueBool">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <code>boolean</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueDate">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <seealso cref="!:Date"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueDouble">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <code>double</code>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueSingle">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type <see cref="T:System.Single"/>.
            <para/>
            NOTE: This was MutableValueFloat in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueInt32">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type <see cref="T:System.Int32"/>.
            <para/>
            NOTE: This was MutableValueInt in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueInt64">
            <summary>
            <see cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type <see cref="T:System.Int64"/>.
            <para/>
            NOTE: This was MutableValueLong in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Mutable.MutableValueStr">
            <summary>
            <seealso cref="T:Lucene.Net.Util.Mutable.MutableValue"/> implementation of type
            <seealso cref="!:String"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer">
            <summary>
            Common functionality shared by <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> and <seealso cref="T:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer"/>. 
            <para/>
            NOTE: This was AbstractAppendingLongBuffer in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Count">
            <summary>
            Get the number of values that have been added to the buffer.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Add(System.Int64)">
            <summary>
            Append a value to this buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Get(System.Int64,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk get: read at least one and at most <code>len</code> longs starting
            from <code>index</code> into <code>arr[off:off+len]</code> and return
            the actual number of values that have been read.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.GetIterator">
            <summary>
            Return an iterator over the values of this buffer. 
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Iterator.HasNext">
            <summary>
            Whether or not there are remaining values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Iterator.Next">
            <summary>
            Return the next long in the buffer. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.RamBytesUsed">
            <summary>
            Return the number of bytes used by this instance. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractAppendingInt64Buffer.Freeze">
            <summary>
            Pack all pending values in this buffer. Subsequent calls to <seealso cref="!:#add(long)"/> will fail. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.WriteVInt64(Lucene.Net.Store.DataOutput,System.Int64)">
            <summary>
            NOTE: This was writeVLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a multiple of <tt>64</tt> </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Reset(Lucene.Net.Store.DataOutput)">
            <summary>
            Reset this writer to wrap <code>out</code>. The block size remains unchanged. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Add(System.Int64)">
            <summary>
            Append a new long. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Finish">
            <summary>
            Flush all buffered data to disk. this instance is not usable anymore
             after this method has been called until <seealso cref="!:#reset(DataOutput)"/> has
             been called.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractBlockPackedWriter.Ord">
            <summary>
            Return the number of values which have been added. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AbstractPagedMutable`1">
            <summary>
            Base implementation for <seealso cref="T:Lucene.Net.Util.Packed.PagedMutable"/> and <seealso cref="T:Lucene.Net.Util.Packed.PagedGrowableWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Count">
            <summary>
            The number of values.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Set(System.Int64,System.Int64)">
            <summary>
            Set value at <code>index</code>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.RamBytesUsed">
            <summary>
            Return the number of bytes used by this object. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Resize(System.Int64)">
            <summary>
            Create a new copy of size <code>newSize</code> based on the content of
             this buffer. this method is much more efficient than creating a new
             instance and copying values one by one.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Grow(System.Int64)">
            <summary>
            Similar to <seealso cref="!:ArrayUtil#grow(long[], int)"/>. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AbstractPagedMutable`1.Grow">
            <summary>
            Similar to <seealso cref="!:ArrayUtil#grow(long[])"/>. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer">
             <summary>
             Utility class to buffer a list of signed longs in memory. this class only
             supports appending and is optimized for the case where values are close to
             each other.
             <para/>
             NOTE: This was AppendingDeltaPackedLongBuffer in Lucene
            
             @lucene.internal
             </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.#ctor(System.Int32,System.Int32,System.Single)">
            <summary>
            Create <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> </summary>
            <param name="initialPageCount">        the initial number of pages </param>
            <param name="pageSize">                the size of a single page </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio per value </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.#ctor">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<seealso cref="!:PackedInt32s#DEFAULT"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer.#ctor(System.Single)">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer">
            <summary>
            Utility class to buffer a list of signed longs in memory. this class only
            supports appending and is optimized for non-negative numbers with a uniform distribution over a fixed (limited) range
            <para/>
            NOTE: This was AppendingPackedLongBuffer in Lucene
            
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer.#ctor(System.Int32,System.Int32,System.Single)">
             <summary>
            <seealso cref="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer"/> </summary>
             <param name="initialPageCount">        the initial number of pages </param>
             <param name="pageSize">                the size of a single page </param>
             <param name="acceptableOverheadRatio"> an acceptable overhead ratio per value </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer.#ctor">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<seealso cref="!:PackedInt32s#DEFAULT"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer.#ctor(System.Single)">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BlockPackedReader">
            <summary>
            Provides random access to a stream written with <seealso cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int64,System.Boolean)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReader.RamBytesUsed">
            <summary>
            Returns approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.BlockPackedReaderIterator" -->
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.ReadVInt64(Lucene.Net.Store.DataInput)">
            <summary>
            NOTE: This was readVLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.#ctor(Lucene.Net.Store.DataInput,System.Int32,System.Int32,System.Int64)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a block, must be equal to the
                             block size of the <seealso cref="T:Lucene.Net.Util.Packed.BlockPackedWriter"/> which has
                             been used to write the stream </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Reset(Lucene.Net.Store.DataInput,System.Int64)">
            <summary>
            Reset the current reader to wrap a stream of <code>valueCount</code>
            values contained in <code>in</code>. The block size remains unchanged.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Skip(System.Int64)">
            <summary>
            Skip exactly <code>count</code> values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Next">
            <summary>
            Read the next value. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Next(System.Int32)">
            <summary>
            Read between <tt>1</tt> and <code>count</code> values. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BlockPackedReaderIterator.Ord">
            <summary>
            Return the offset of the next value to read. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.BlockPackedWriter" -->
        <member name="M:Lucene.Net.Util.Packed.BlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a power of 2 </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperation">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperation.Int64ValueCount">
            <summary>
            NOTE: This was longValueCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperation.Int64BlockCount">
            <summary>
            NOTE: This was longBlockCount() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BulkOperation.WriteInt64(System.Int64,System.Byte[],System.Int32)">
            <summary>
            NOTE: This was writeLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BulkOperation.ComputeIterations(System.Int32,System.Int32)">
             <summary>
             For every number of bits per value, there is a minimum number of
             blocks (b) / values (v) you need to write in order to reach the next block
             boundary:
              - 16 bits per value -> b=2, v=1
              - 24 bits per value -> b=3, v=1
              - 50 bits per value -> b=25, v=4
              - 63 bits per value -> b=63, v=8
              - ...
            
             A bulk read consists in copying <code>iterations*v</code> values that are
             contained in <code>iterations*b</code> blocks into a <code>long[]</code>
             (higher values of <code>iterations</code> are likely to yield a better
             throughput) => this requires n * (b + 8v) bytes of memory.
            
             this method computes <code>iterations</code> as
             <code>ramBudget / (b + 8v)</code> (since a long is 8 bytes).
             </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked">
            <summary>
            Non-specialized <seealso cref="T:Lucene.Net.Util.Packed.BulkOperation"/> for <seealso cref="!:PackedInt32s.Format#PACKED"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPacked.Int64BlockCount">
            <summary>
            NOTE: This was longBlockCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPacked.Int64ValueCount">
            <summary>
            NOTE: This was longValueCount() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked1">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked10">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked11">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked12">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked13">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked14">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked15">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked16">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked17">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked18">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked19">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked2">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked20">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked21">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked22">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked23">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked24">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked3">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked4">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked5">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked6">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked7">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked8">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPacked9">
            <summary>
            Efficient sequential read/write of packed integers.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock">
            <summary>
            Non-specialized <seealso cref="T:Lucene.Net.Util.Packed.BulkOperation"/> for <seealso cref="!:PackedInt32s.Format#PACKED_SINGLE_BLOCK"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock.Int64BlockCount">
            <summary>
            NOTE: This was longBlockCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock.Int64ValueCount">
            <summary>
            NOTE: This was longValueCount() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.BulkOperationPackedSingleBlock.ReadInt64(System.Byte[],System.Int32)">
            <summary>
            NOTE: This was readLong() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct16">
            <summary>
            Direct wrapping of 16-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct32">
            <summary>
            Direct wrapping of 32-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct64">
            <summary>
            Direct wrapping of 64-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Direct8">
            <summary>
            Direct wrapping of 8-bits values to a backing array.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.EliasFanoDecoder">
            <summary>
            A decoder for an <seealso cref="P:Lucene.Net.Util.Packed.EliasFanoDecoder.EliasFanoEncoder"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoDecoder.LOG2_INT64_SIZE">
            <summary>
            NOTE: This was LOG2_LONG_SIZE in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.#ctor(Lucene.Net.Util.Packed.EliasFanoEncoder)">
            <summary>
            Construct a decoder for a given <seealso cref="P:Lucene.Net.Util.Packed.EliasFanoDecoder.EliasFanoEncoder"/>.
            The decoding index is set to just before the first encoded value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.EliasFanoEncoder">
            <returns> The Elias-Fano encoder that is decoded. </returns>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.NumEncoded">
            <summary>
            The number of values encoded by the encoder. </summary>
            <returns> The number of values encoded by the encoder. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentIndex">
            <summary>
            The current decoding index.
            The first value encoded by <seealso cref="!:EliasFanoEncoder#encodeNext"/> has index 0.
            Only valid directly after
            <seealso cref="!:#nextValue"/>, <seealso cref="!:#advanceToValue"/>,
            <seealso cref="!:#previousValue"/>, or <seealso cref="!:#backToValue"/>
            returned another value than <seealso cref="!:#NO_MORE_VALUES"/>,
            or <seealso cref="!:#advanceToIndex"/> returned true. </summary>
            <returns> The decoding index of the last decoded value, or as last set by <seealso cref="!:#advanceToIndex"/>. </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentValue" -->
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentHighValue">
             <returns> The high value for the current decoding index. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.UnPackValue(System.Int64[],System.Int32,System.Int64,System.Int64)">
            <summary>
            See also <seealso cref="!:EliasFanoEncoder#packValue"/> </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentLowValue">
             <returns> The low value for the current decoding index. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.CombineHighLowValues(System.Int64,System.Int64)">
             <returns> The given highValue shifted left by the number of low bits from by the EliasFanoSequence,
                      logically OR-ed with the given lowValue. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToBeforeSequence">
            <summary>
            Set the decoding index to just before the first encoded value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentRightShift">
            <returns> the number of bits in a long after (setBitForIndex modulo Long.SIZE) </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToAfterCurrentHighBit">
            <summary>
            Increment efIndex and setBitForIndex and
            shift curHighLong so that it does not contain the high bits before setBitForIndex. </summary>
            <returns> true iff efIndex still smaller than numEncoded. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToNextHighInt64">
            <summary>
            The current high long has been determined to not contain the set bit that is needed.
            Increment setBitForIndex to the next high long and set curHighLong accordingly.
            <para/>
            NOTE: this was toNextHighLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToNextHighValue">
            <summary>
            setBitForIndex and efIndex have just been incremented, scan to the next high set bit
             by incrementing setBitForIndex, and by setting curHighLong accordingly.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NextHighValue">
            <summary>
            setBitForIndex and efIndex have just been incremented, scan to the next high set bit
             by incrementing setBitForIndex, and by setting curHighLong accordingly. </summary>
             <returns> the next encoded high value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.NextValue">
            <summary>
            If another value is available after the current decoding index, return this value and
            and increase the decoding index by 1. Otherwise return <seealso cref="!:#NO_MORE_VALUES"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToIndex(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.AdvanceToValue(System.Int64)" -->
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToAfterSequence">
            <summary>
            Set the decoding index to just after the last encoded value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDecoder.CurrentLeftShift">
            <returns> the number of bits in a long before (setBitForIndex modulo Long.SIZE) </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToBeforeCurrentHighBit">
            <summary>
            Decrement efindex and setBitForIndex and
            shift curHighLong so that it does not contain the high bits after setBitForIndex. </summary>
            <returns> true iff efindex still >= 0 </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.ToPreviousHighInt64">
            <summary>
            The current high long has been determined to not contain the set bit that is needed.
            Decrement setBitForIndex to the previous high long and set curHighLong accordingly.
            <para/>
            NOTE: this was toPreviousHighLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.PreviousHighValue">
            <summary>
            setBitForIndex and efIndex have just been decremented, scan to the previous high set bit
             by decrementing setBitForIndex and by setting curHighLong accordingly. </summary>
             <returns> the previous encoded high value. </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDecoder.PreviousValue">
            <summary>
            If another value is available before the current decoding index, return this value
            and decrease the decoding index by 1. Otherwise return <seealso cref="!:#NO_MORE_VALUES"/>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.BackToHighValue(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoDecoder.BackToValue(System.Int64)" -->
        <member name="T:Lucene.Net.Util.Packed.EliasFanoDocIdSet">
            <summary>
            A DocIdSet in Elias-Fano encoding.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.#ctor(System.Int32,System.Int32)">
            <summary>
            Construct an EliasFanoDocIdSet. For efficient encoding, the parameters should be chosen as low as possible. </summary>
            <param name="numValues"> At least the number of document ids that will be encoded. </param>
            <param name="upperBound">  At least the highest document id that will be encoded. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.SufficientlySmallerThanBitSet(System.Int64,System.Int64)">
            <summary>
            Provide an indication that is better to use an <seealso cref="T:Lucene.Net.Util.Packed.EliasFanoDocIdSet"/> than a <seealso cref="T:Lucene.Net.Util.FixedBitSet"/>
             to encode document identifiers. </summary>
             <param name="numValues"> The number of document identifiers that is to be encoded. Should be non negative. </param>
             <param name="upperBound"> The maximum possible value for a document identifier. Should be at least <code>numValues</code>. </param>
             <returns> See <seealso cref="!:EliasFanoEncoder#sufficientlySmallerThanBitSet(long, long)"/> </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.EncodeFromDisi(Lucene.Net.Search.DocIdSetIterator)">
            <summary>
            Encode the document ids from a DocIdSetIterator. </summary>
             <param name="disi"> this DocIdSetIterator should provide document ids that are consistent
                         with <code>numValues</code> and <code>upperBound</code> as provided to the constructor.   </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoDocIdSet.GetIterator">
            <summary>
            Provides a <seealso cref="T:Lucene.Net.Search.DocIdSetIterator"/> to access encoded document ids.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoDocIdSet.IsCacheable">
            <summary>
            this DocIdSet implementation is cacheable. </summary>
            <returns> <code>true</code> </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.EliasFanoEncoder" -->
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.LOG2_INT64_SIZE">
            <summary>
            NOTE: This was LOG2_LONG_SIZE in Lucene
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.DEFAULT_INDEX_INTERVAL">
            <summary>
            The default index interval for zero upper bits. </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.EliasFanoEncoder.upperZeroBitPositionIndex">
            <summary>
            upperZeroBitPositionIndex[i] (filled using packValue) will contain the bit position
             just after the zero bit ((i+1) * indexInterval) in the upper bits.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoEncoder.#ctor(System.Int64,System.Int64,System.Int64)" -->
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.#ctor(System.Int64,System.Int64)">
            <summary>
            Construct an Elias-Fano encoder using <seealso cref="!:#DEFAULT_INDEX_INTERVAL"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.NumInt64sForBits(System.Int64)">
            <summary>
            NOTE: This was numLongsForBits() in Lucene
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoEncoder.EncodeNext(System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.EliasFanoEncoder.SufficientlySmallerThanBitSet(System.Int64,System.Int64)" -->
        <member name="M:Lucene.Net.Util.Packed.EliasFanoEncoder.GetDecoder">
            <summary>
            Returns an <seealso cref="T:Lucene.Net.Util.Packed.EliasFanoDecoder"/> to access the encoded values.
            Perform all calls to <seealso cref="!:#encodeNext"/> before calling <seealso cref="!:#getDecoder"/>.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.LowerBits">
            <summary>
            Expert. The low bits. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.UpperBits">
            <summary>
            Expert. The high bits. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.EliasFanoEncoder.IndexBits">
            <summary>
            Expert. The index bits. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.GrowableWriter" -->
        <member name="M:Lucene.Net.Util.Packed.GrowableWriter.#ctor(System.Int32,System.Int32,System.Single)">
            <param name="startBitsPerValue">       the initial number of bits per value, may grow depending on the data </param>
            <param name="valueCount">              the number of values </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer">
            <summary>
            Utility class to buffer signed longs in memory, which is optimized for the
            case where the sequence is monotonic, although it can encode any sequence of
            arbitrary longs. It only supports appending.
            <para/>
            NOTE: This was MonotonicAppendingLongBuffer in Lucene
            
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.#ctor(System.Int32,System.Int32,System.Single)">
            <param name="initialPageCount">        the initial number of pages </param>
            <param name="pageSize">                the size of a single page </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio per value </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.#ctor">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer"/> with initialPageCount=16,
            pageSize=1024 and acceptableOverheadRatio=<seealso cref="!:PackedInt32s#DEFAULT"/>
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicAppendingInt64Buffer.#ctor(System.Single)">
            <summary>
            Create an <seealso cref="T:Lucene.Net.Util.Packed.AppendingDeltaPackedInt64Buffer"/> with initialPageCount=16,
            pageSize=1024
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.MonotonicBlockPackedReader">
            <summary>
            Provides random access to a stream written with
            <seealso cref="T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter"/>.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.#ctor(Lucene.Net.Store.IndexInput,System.Int32,System.Int32,System.Int64,System.Boolean)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.Count">
            <summary>
            Returns the number of values.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedReader.RamBytesUsed">
            <summary>
            Returns the approximate RAM bytes used </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter" -->
        <member name="M:Lucene.Net.Util.Packed.MonotonicBlockPackedWriter.#ctor(Lucene.Net.Store.DataOutput,System.Int32)">
            <summary>
            Sole constructor. </summary>
            <param name="blockSize"> the number of values of a single block, must be a power of 2 </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed16ThreeBlocks">
            <summary>
            Packs integers into 3 shorts (48 bits per value).
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.Packed64" -->
        <member name="F:Lucene.Net.Util.Packed.Packed64.blocks">
            <summary>
            Values are stores contiguously in the blocks array.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.Packed64.maskRight">
            <summary>
            A right-aligned mask of width BitsPerValue used by <seealso cref="!:#get(int)"/>.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.Packed64.bpvMinusBlockSize">
            <summary>
            Optimization: Saves one lookup in <seealso cref="!:#get(int)"/>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates an array with the internal structures adjusted for the given
            limits and initialized to 0. </summary>
            <param name="valueCount">   the number of elements. </param>
            <param name="bitsPerValue"> the number of bits available for any given value. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.#ctor(System.Int32,Lucene.Net.Store.DataInput,System.Int32,System.Int32)">
            <summary>
            Creates an array with content retrieved from the given DataInput. </summary>
            <param name="in">       a DataInput, positioned at the start of Packed64-content. </param>
            <param name="valueCount">  the number of elements. </param>
            <param name="bitsPerValue"> the number of bits available for any given value. </param>
            <exception cref="!:java.io.IOException"> if the values for the backing array could not
                                        be retrieved. </exception>
        </member>
        <member name="M:Lucene.Net.Util.Packed.Packed64.Get(System.Int32)">
            <param name="index"> the position of the value. </param>
            <returns> the value at the given index. </returns>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed64SingleBlock">
            <summary>
            this class is similar to <seealso cref="T:Lucene.Net.Util.Packed.Packed64"/> except that it trades space for
            speed by ensuring that a single block needs to be read/written in order to
            read/write a value.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.Packed8ThreeBlocks">
            <summary>
            Packs integers into 3 bytes (24 bits per value).
            @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.PackedDataInput" -->
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.#ctor(Lucene.Net.Store.DataInput)">
            <summary>
            Create a new instance that wraps <code>in</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.ReadInt64(System.Int32)">
            <summary>
            Read the next long using exactly <code>bitsPerValue</code> bits.
            <para/>
            NOTE: This was readLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataInput.SkipToNextByte">
            <summary>
            If there are pending bits (at most 7), they will be ignored and the next
            value will be read starting at the next byte.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.PackedDataOutput" -->
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.#ctor(Lucene.Net.Store.DataOutput)">
            <summary>
            Create a new instance that wraps <code>out</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.WriteInt64(System.Int64,System.Int32)">
            <summary>
            Write a value using exactly <code>bitsPerValue</code> bits.
            <para/>
            NOTE: This was writeLong() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedDataOutput.Flush">
            <summary>
            Flush pending bits to the underlying <seealso cref="T:Lucene.Net.Store.DataOutput"/>.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s">
             <summary>
             Simplistic compression for array of unsigned long values.
             Each value is >= 0 and &lt;= a specified maximum value.  The
             values are stored as packed ints, with each value
             consuming a fixed number of bits.
             <para/>
             NOTE: This was PackedInts in Lucene
            
             @lucene.internal
             </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.FASTEST">
            <summary>
            At most 700% memory overhead, always select a direct implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.FAST">
            <summary>
            At most 50% memory overhead, always select a reasonably fast implementation.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.DEFAULT">
            <summary>
            At most 20% memory overhead.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.COMPACT">
            <summary>
            No memory overhead at all, but the returned implementation may be slow.
            </summary>
        </member>
        <member name="F:Lucene.Net.Util.Packed.PackedInt32s.DEFAULT_BUFFER_SIZE">
            <summary>
            Default amount of memory to use for bulk operations.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.CheckVersion(System.Int32)">
            <summary>
            Check the validity of a version number.
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.PackedFormat">
            <summary>
            Returns the ID of the format.
            </summary>
            <summary>
            Computes how many byte blocks are needed to store <code>values</code>
            values of size <code>bitsPerValue</code>.
            </summary>
            <summary>
            Computes how many long blocks are needed to store <code>values</code>
            values of size <code>bitsPerValue</code>.
            </summary>
            <summary>
            Tests whether the provided number of bits per value is supported by the
            format.
            </summary>
            <summary>
            Returns the overhead per value, in bits.
            </summary>
            <summary>
            Returns the overhead ratio (<code>overhead per value / bits per value</code>).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.PackedSingleBlockFormat.Int64Count(System.Int32,System.Int32,System.Int32)">
            <summary>
            NOTE: This was longCount() in Lucene
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Format.Int64Count(System.Int32,System.Int32,System.Int32)">
            <summary>
            NOTE: This was longCount() in Lucene
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.FormatAndBits">
            <summary>
            Simple class that holds a format and a number of bits per value.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.FastestFormatAndBits(System.Int32,System.Int32,System.Single)" -->
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.IDecoder">
            <summary>
            A decoder for packed integers.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Int64BlockCount">
            <summary>
            The minimum number of long blocks to encode in a single iteration, when
            using long encoding.
            <para/>
            NOTE: This was longBlockCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Int64ValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#longBlockCount()"/> long
            blocks.
            <para/>
            NOTE: This was longValueCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.ByteBlockCount">
            <summary>
            The minimum number of byte blocks to encode in a single iteration, when
            using byte encoding.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.ByteValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#byteBlockCount()"/> byte
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Int64[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Byte[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>8 * iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Int64[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IDecoder.Decode(System.Byte[],System.Int32,System.Int32[],System.Int32,System.Int32)">
            <summary>
            Read <code>8 * iterations * blockCount()</code> blocks from <code>blocks</code>,
            decode them and write <code>iterations * valueCount()</code> values into
            <code>values</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start reading blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start writing values </param>
            <param name="iterations">   controls how much data to decode </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.IEncoder">
            <summary>
            An encoder for packed integers.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Int64BlockCount">
            <summary>
            The minimum number of long blocks to encode in a single iteration, when
            using long encoding.
            <para/>
            NOTE: This was longBlockCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Int64ValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#longBlockCount()"/> long
            blocks.
            <para/>
            NOTE: This was longValueCount() in Lucene
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.ByteBlockCount">
            <summary>
            The minimum number of byte blocks to encode in a single iteration, when
            using byte encoding.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.ByteValueCount">
            <summary>
            The number of values that can be stored in <seealso cref="!:#byteBlockCount()"/> byte
            blocks.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int64[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int64[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>8 * iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int32[],System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IEncoder.Encode(System.Int32[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Read <code>iterations * valueCount()</code> values from <code>values</code>,
            encode them and write <code>8 * iterations * blockCount()</code> blocks into
            <code>blocks</code>.
            </summary>
            <param name="blocks">       the long blocks that hold packed integer values </param>
            <param name="blocksOffset"> the offset where to start writing blocks </param>
            <param name="values">       the values buffer </param>
            <param name="valuesOffset"> the offset where to start reading values </param>
            <param name="iterations">   controls how much data to encode </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Reader">
            <summary>
            A read-only random access array of positive integers.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Reader.Get(System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk get: read at least one and at most <code>len</code> longs starting
            from <code>index</code> into <code>arr[off:off+len]</code> and return
            the actual number of values that have been read.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Reader.BitsPerValue">
            <returns> the number of bits used to store any given value.
                    Note: this does not imply that memory usage is
                    {@code bitsPerValue * #values} as implementations are free to
                    use non-space-optimal packing of bits. </returns>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Reader.Count">
            <summary>
            the number of values. 
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Reader.RamBytesUsed">
            <summary>
            Return the in-memory size in bytes.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.Reader.GetArray" -->
        <!-- Badly formed XML comment ignored for member "P:Lucene.Net.Util.Packed.PackedInt32s.Reader.HasArray" -->
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator">
            <summary>
            Run-once iterator interface, to decode previously saved PackedInts.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Next">
            <summary>
            Returns next value </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Next(System.Int32)">
            <summary>
            Returns at least 1 and at most <code>count</code> next values,
            the returned ref MUST NOT be modified
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.BitsPerValue">
            <summary>
            Returns number of bits per value </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Count">
            <summary>
            Returns number of values.
            NOTE: This was size() in Lucene.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator.Ord">
            <summary>
            Returns the current position </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Mutable">
            <summary>
            A packed integer array that can be modified.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Set(System.Int32,System.Int64)">
            <summary>
            Set the value at the given index in the array. </summary>
            <param name="index"> where the value should be positioned. </param>
            <param name="value"> a value conforming to the constraints set by the array. </param>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Set(System.Int32,System.Int64[],System.Int32,System.Int32)">
            <summary>
            Bulk set: set at least one and at most <code>len</code> longs starting
            at <code>off</code> in <code>arr</code> into this mutable, starting at
            <code>index</code>. Returns the actual number of values that have been
            set.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Fill(System.Int32,System.Int32,System.Int64)">
            <summary>
            Fill the mutable from <code>fromIndex</code> (inclusive) to
            <code>toIndex</code> (exclusive) with <code>val</code>.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Clear">
            <summary>
            Sets all values to 0.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Save(Lucene.Net.Store.DataOutput)">
            <summary>
            Save this mutable into <code>out</code>. Instantiating a reader from
            the generated data will return a reader with the same number of bits
            per value.
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Mutable.Format">
            <summary>
            The underlying format. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.ReaderImpl">
            <summary>
            A simple base for Readers that keeps track of valueCount and bitsPerValue.
            @lucene.internal
            </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.NullReader">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> which has all its values equal to 0 (bitsPerValue = 0). </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.NullReader.#ctor(System.Int32)">
            <summary>
            Sole constructor. </summary>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Writer">
            <summary>
            A write-once Writer.
            @lucene.internal
            </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Writer.Format">
            <summary>
            The format used to serialize values. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Writer.Add(System.Int64)">
            <summary>
            Add a value to the stream. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Writer.BitsPerValue">
            <summary>
            The number of bits per value. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Writer.Finish">
            <summary>
            Perform end-of-stream operations. </summary>
        </member>
        <member name="P:Lucene.Net.Util.Packed.PackedInt32s.Writer.Ord">
            <summary>
            Returns the current ord in the stream (number of values that have been
            written so far minus one).
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetDecoder(Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32)">
            <summary>
            Get a <seealso cref="T:Lucene.Net.Util.Packed.PackedInt32s.IDecoder"/>.
            </summary>
            <param name="format">         the format used to store packed ints </param>
            <param name="version">        the compatibility version </param>
            <param name="bitsPerValue">   the number of bits per value </param>
            <returns> a decoder </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetEncoder(Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32)">
            <summary>
            Get an <seealso cref="T:Lucene.Net.Util.Packed.PackedInt32s.IEncoder"/>.
            </summary>
            <param name="format">         the format used to store packed ints </param>
            <param name="version">        the compatibility version </param>
            <param name="bitsPerValue">   the number of bits per value </param>
            <returns> an encoder </returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Header)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetReader(Lucene.Net.Store.DataInput)">
            <summary>
            Restore a <seealso cref="T:Lucene.Net.Util.Packed.PackedInt32s.Reader"/> from a stream.
            </summary>
            <param name="in">           the stream to read data from </param>
            <returns>             a Reader </returns>
            <exception cref="!:IOException"> If there is a low-level I/O error
            @lucene.internal </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderIteratorNoHeader(Lucene.Net.Store.DataInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32,System.Int32)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetReaderIterator(Lucene.Net.Store.DataInput,System.Int32)">
            <summary>
            Retrieve PackedInts as a <seealso cref="T:Lucene.Net.Util.Packed.PackedInt32s.IReaderIterator"/> </summary>
            <param name="in"> positioned at the beginning of a stored packed int structure. </param>
            <param name="mem"> how much memory the iterator is allowed to use to read-ahead (likely to speed up iteration) </param>
            <returns> an iterator to access the values </returns>
            <exception cref="!:IOException"> if the structure could not be retrieved.
            @lucene.internal </exception>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReaderNoHeader(Lucene.Net.Store.IndexInput,Lucene.Net.Util.Packed.PackedInt32s.Header)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetDirectReader(Lucene.Net.Store.IndexInput)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetMutable(System.Int32,System.Int32,System.Single)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.GetMutable(System.Int32,System.Int32,Lucene.Net.Util.Packed.PackedInt32s.Format)">
            <summary>
            Same as <seealso cref="!:#getMutable(int, int, float)"/> with a pre-computed number
             of bits per value and format.
             @lucene.internal
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetWriterNoHeader(Lucene.Net.Store.DataOutput,Lucene.Net.Util.Packed.PackedInt32s.Format,System.Int32,System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.GetWriter(Lucene.Net.Store.DataOutput,System.Int32,System.Int32,System.Single)" -->
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.BitsRequired(System.Int64)">
            <summary>
            Returns how many bits are required to hold values up
             to and including maxValue </summary>
            <param name="maxValue"> the maximum value that should be representable. </param>
            <returns> the amount of bits needed to represent values from 0 to maxValue.
            @lucene.internal </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.MaxValue(System.Int32)">
            <summary>
            Calculates the maximum unsigned long that can be expressed with the given
            number of bits. </summary>
            <param name="bitsPerValue"> the number of bits available for any given value. </param>
            <returns> the maximum value for the given bits.
            @lucene.internal </returns>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Copy(Lucene.Net.Util.Packed.PackedInt32s.Reader,System.Int32,Lucene.Net.Util.Packed.PackedInt32s.Mutable,System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy <code>src[srcPos:srcPos+len]</code> into
            <code>dest[destPos:destPos+len]</code> using at most <code>mem</code>
            bytes.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.Copy(Lucene.Net.Util.Packed.PackedInt32s.Reader,System.Int32,Lucene.Net.Util.Packed.PackedInt32s.Mutable,System.Int32,System.Int32,System.Int64[])">
            <summary>
            Same as <seealso cref="!:#copy(Reader, int, Mutable, int, int, int)"/> but using a pre-allocated buffer. </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Lucene.Net.Util.Packed.PackedInt32s.ReadHeader(Lucene.Net.Store.DataInput)" -->
        <member name="T:Lucene.Net.Util.Packed.PackedInt32s.Header">
            <summary>
            Header identifying the structure of a packed integer array. </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.CheckBlockSize(System.Int32,System.Int32,System.Int32)">
            <summary>
            Check that the block size is a power of 2, in the right bounds, and return
             its log in base 2.
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PackedInt32s.NumBlocks(System.Int64,System.Int32)">
            <summary>
            Return the number of blocks required to store <code>size</code> values on
             <code>blockSize</code>.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Lucene.Net.Util.Packed.PagedGrowableWriter" -->
        <member name="M:Lucene.Net.Util.Packed.PagedGrowableWriter.#ctor(System.Int64,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.Packed.PagedGrowableWriter"/> instance.
            </summary>
            <param name="size"> the number of values to store. </param>
            <param name="pageSize"> the number of values per page </param>
            <param name="startBitsPerValue"> the initial number of bits per value </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio </param>
        </member>
        <member name="T:Lucene.Net.Util.Packed.PagedMutable">
            <summary>
            A <seealso cref="T:Lucene.Net.Util.Packed.PagedMutable"/>. this class slices data into fixed-size blocks
            which have the same number of bits per value. It can be a useful replacement
            for <seealso cref="T:Lucene.Net.Util.Packed.PackedInt32s.Mutable"/> to store more than 2B values.
            @lucene.internal
            </summary>
        </member>
        <member name="M:Lucene.Net.Util.Packed.PagedMutable.#ctor(System.Int64,System.Int32,System.Int32,System.Single)">
            <summary>
            Create a new <seealso cref="T:Lucene.Net.Util.Packed.PagedMutable"/> instance.
            </summary>
            <param name="size"> the number of values to store. </param>
            <param name="pageSize"> the number of values per page </param>
            <param name="bitsPerValue"> the number of bits per value </param>
            <param name="acceptableOverheadRatio"> an acceptable overhead ratio </param>
        </member>
    </members>
</doc>
